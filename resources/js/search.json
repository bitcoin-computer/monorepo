[[{"l":"Introduction","p":["The Bitcoin Computer is a Turing-complete metaprotocol for UTXO-based blockchains. You can build of games, social networks, tokens, decentralized exchanges, enterprise applications and much more.","Free Computation. Execution costs are fixed and independent of the number of computational steps of a smart contract.","Metaprotocol. There is no trusted intermediaries and no extra blockchain or token. It works just like Ordinals or Runes, just that it's Turing complete, meaning that you can build applications that are as decentralized and secure as the underlying blockchain is.","Multicoin. We supports Bitcoin, Litecoin, Dogecoin, and Pepecoin, with Bitcoin Cash support coming soon. You can launch into all of these communities simultaneously because the same code works across all of these chains.","JavaScript. Smart contracts are written in JavaScript or TypeScript, leveraging vast ecosystems and enabling seamless integration with web applications.","Data Ownership. An on-chain object is stored in a UTXO (Unspent Transaction Output) and can only be updated by spending the UTXO. Thus the owner of the UTXO is the owner of the data and data ownership is as secure as cryptocurrency ownership.","Compatible. You can build application that use assets from other protocols - for example a game with ordinals or a DEX for Runes. Other protocols like BitVM are orthogonal and can be \"plugged in\" to enforce complex data ownership conditions.","Simple. To deploy a smart contract, inscribe a JavaScript class, to create an on-chain object, inscribe a constructor call and to update an on-chain object, inscribe a function call.","Fast. Built-in optimizations avoid any redundant computation. Apps are fast out of the box.","History. As every state update is recorded in a transaction, each historical state is recoverable. Additionally, all updates are timestamped and digitally signed, making it easy to audit applications.","Privacy. On-chain objects are public by default, but the protocol has support for end-to-end encryption and off-chain data storage. This enables CCPA and GDPR compliant enterprise applications.","The Bitcoin Computer is developed by BCDB Inc. If you have any questions, please let us know in our Telegram group, on Twitter, or by email at clemens@bitcoincomputer.io."]}],[{"l":"Start"},{"l":"Use in the Browser","p":["Create the following file and open it in a browser.","The browser will initially show *. When the on-chain object is created it will show 0 an when the object is updated it will show 1."]},{"i":"use-in-nodejs","l":"Use in Node.js","p":["You need to have node.js installed. First download and install the Bitcoin Computer library from npm:","Then create a file index.mjs.","Execute the smart contract.","The expected output is:","In both examples above you are using a Bitcoin Computer Node that we provide at rltc.node.bitcoincomputer.io configured to Litecoin Regtest. You can use this node for free but it is rate limited. For serious development we recommend to clone the monorepo so you can run your own, unlimited, node."]},{"l":"Run a Node","p":["To run a node we recommend to clone the monorepo with all Bitcoin Computer related materials, including the Bitcoin Computer library, the node, these docs, and example applications."]},{"l":"Install"},{"l":"Start the node","p":["To start your node at http://localhost:1031 run the commands below. The node is ready once the log activity subsides. On regtest this will take a few minutes, on mainnet and testnet it can take hours or even days, depending on your hardware and network connection."]},{"l":"Test","p":["Once the node is up an running, open a separate terminal window and navigate the monorepo folder. You can run the following commands","The commands will be executed in each package. You can also navigate the a package and run the same scripts there."]},{"l":"Start your own Project","p":["We provide two templates, vite-template for client side projects and node-template for server side projects, featuring:","Bitcoin Computer","Typescript","Eslint","Testing environment","The easiest thing to do is just to rename the folder. Alternatively have a look at our example apps (e.g. our wallet, blockchain explorer, or nft app) to see if any of them are a good starting point for your project."]},{"l":"Getting Help","p":["Telegram","Twitter"]}],[{"l":"Tutorial","p":["In this tutorial we explain how to build a decentralized chat. We will start with a comically simple version but we will work our way up to a real world chat."]},{"l":"Write a Smart Contract","p":["The Javascript program below is a smart contract for a one-person chat.","We recommend to ignore the syntax for initializing messages in the constructor for now. If you are interested in the details you can find them here."]},{"l":"Create a Client-Side Wallet","p":["The Computer class is a client-side Javascript wallet that manages a Bitcoin private-public key pair. It can create normal Bitcoin transactions but also ones that contain metadata according to the Bitcoin Computer protocol. This allows for the creation, updating, and retrieval of on-chain objects.","You can pass a BIP39 mnemonic into the constructor to create a specific private-public key pair, or leave the mnemonic parameter undefined to generate a wallet from a random mnemonic. More configuration options are described here."]},{"l":"Create an On-Chain Object","p":["The computer.new function broadcasts a transaction inscribed with a Javascript expression consisting of a class and a constructor call. For example, the call","broadcasts a transaction inscribed with the expression below.","The Bitcoin Computer protocol interprets such a transaction as creating an on-chain object of type Chat at an output of the transaction.","The object chat returned from the computer.new call is similar to the object returned from the call new Chat('hello'). However it has additional properties _id, _rev, _root, _owners and _amount:","The properties _id, _rev, _root are set to strings of the form tx-id:out-num where tx-id is the id of the transaction broadcast by the computer.new call.","The _owners property is set to an array containing public keys.","The _amount property specifies an amount in satoshis.","We refer to chat as an on-chain object.","Note that the transaction that created chat does not contain an encoding of the object itself. It only contains code that evaluates to its state."]},{"l":"Update an On-Chain Object","p":["When a function is called on an on-chain object, a transaction is broadcast that is inscribed with a Javascript expression encoding the function call and an environment determining the undefined variables in the expressions. For example, the call","broadcasts a transaction tx that is inscribed with the data below.","The transaction's zeroth input spends the output in which the previous revision of the chat object was stored.","Note that it is not possible to compute a value from the expression chat.post('world') alone because the variable chat is not defined. To make the expression determined the transaction's inscription contains an environment env that associates the variable name chat with its zeroth input.","To compute the value of the chat after the post function is called and the transaction tx is broadcast, the Bitcoin Computer protocol first computes the value stored at the output spent by the zeroth input of tx. This value is then substituted for the name chat in the expression chat.post('world'). Now the expression is completely determined and can be evaluated. The new value for chat is associated with the zeroth output of tx. In our example, this value is","The property _rev has been updated and now refers to the zeroth output of tx. The properties _id, _root, _owners, _amount have not changed. The meaning of these special properties is as follows:","_id is the output in which the on-chain object was first created. As this output never changes the _id property never changes","_rev is the output where the current revision of the object is stored. Therefore, initially, the revision is equal to the id, then the revision is changed every time the object is updated.","_root is never updated. As it is not relevant to the chat example we refer the interested reader to this section.","_owners is set to the public key of the data owner. More on that below.","amount is set to the amount of satoshi of the output in which an on-chain object is stored. More here.","The properties _id, _rev, and _root are read only and an attempt to assign to them will throw an error. The properties _owners and _amount can be assigned in a smart contract to determine the transaction that is built.","The state of the on-chain objects is never stored in the blockchain, just the Javascript expression that creates it. This makes it possible to store data compressed to its Kolmogorov complexity which is optimal."]},{"l":"Read an On-Chain Object","p":["The computer.sync function computes the state of an on-chain object given its revision. For example, if the function is called with an the id of an on-chain object, it returns the initial state of the object","If computer.sync is called with latest revision it returns the current state."]},{"l":"Find On-Chain Objects"},{"l":"Find the Latest Revisions","p":["The computer.query function returns an array of strings containing the latest revisions of on-chain objects. For example, it can return the latest revision of an object given its id:","A basic pattern in applications is to identify a on-chain object by its ids, look up the object's latest revision using computer.query, and then to compute its latest state using computer.sync. For example, in our chat app the url could contain a chat's id and the latest state of the chat could be computed as shown below."]},{"l":"Find All Objects of a User","p":["computer.query can also return all revisions of on-chain objects owned by a public key. This could be useful for creating a user page for the chat application."]},{"l":"Navigating the History","p":["It is also possible to navigate the revision history of a on-chain object using computer.next and computer.prev:","Note that the code above only works because there are only two revisions of the chat in our example, otherwise computer.next or computer.prev would have to be called multiple times."]},{"l":"Data Ownership","p":["We are finally ready to elevate our one-person chat to a multi-person chat!","The owner of an on-chain object is the user that can spend the output that stores it, just like the owner of the satoshi in a output is the user that can spend it.","The owners can be set by assigning the _owners property. If this property is set to an array of public keys, the output script is a 1-of-n bare multisig script. If it is set to an ASM encoded script the output will have that script, more on that later. If the _owners property is not assigned the owners default to the public key of the computer object that created the on-chain object.","In the chat example, the initial owner is the public key of the computer object on which computer.new function was called. Only that user can post to the chat. We can add a function invite to update the owners array to allow other users to post.","While a user can never change an on-chain object that they do not own, the owner has complete control. This includes the ability to destroy their own objects by spending their outputs with a transaction that does not conform to the Bitcoin Computer protocol. In this case the value of the object will be an Error value.","This is reminiscent of the real world where people have the right to destroy their own property but not the right to destroy somebody else's property."]},{"l":"Encryption","p":["By default, the state of an on-chain object is public in the sense that any user can compute the state from its revision using computer.sync. However, you can restrict read access to an object by setting its _readers property to an array of public keys. If _readers is assigned, the meta-data on the transaction is encrypted using a combination of AES and ECIES so that only the specified readers have read access.","For example, if we want to ensure that only people invited to the chat can read the messages, we can update our example code as follows:","As all updates to an on-chain object are recorded in immutable transactions it is not possible to restrict access to a revision once it is granted. It is also not possible to grant read access to a revision without granting read access to its entire history as the entire history is needed to compute the value of a revision. It is however possible to revoke read access from some point forward or to restrict access to all revisions all together.","When on-chain objects are encrypted the flow of cryptocurrency is not obfuscated."]},{"l":"Off-Chain Storage","p":["It is possible to store the metadata of a transaction off-chain in the database of a Bitcoin Computer Node. In this case a hash of the data and a url where the metadata can be retrieved is stored on chain, while the metadata itself is stored on the server. To use this feature, set a property _url of an on-chain object to the URL of a Bitcoin Computer Node.","For example, if users want to send images to the chat that are too large to store on-chain, they can use the off-chain solution:"]},{"l":"Cryptocurrency","p":["Recall that an on-chain object is stored in an output and that the owners of the on-chain object are the users that can spend the output. Thus the owners of an on-chain object are always the owners of the satoshi in the output that stores it. We therefore say that the satoshi are stored in the on-chain object.","The amount of satoshi in the output of an on-chain object can be configured by setting the _amount property to a number. If this property is undefined, the object will store an a minimal (non-dust) amount.","If the value of the _amount property is increased, the additional satoshi must be provided by the wallet of the computer object that executes the call. In the case of a constructor call with computer.new that is that computer object. In the case of a function call it is the computer object that created the on-chain object.","If the value of the _amount property is decreased, the difference in satoshi is credited to the wallet with the associated computer object.","For example, if a user Alice wants to send 21000 satoshis to a user Bob, then Alice can create an on-chain object of the following Payment class.","When the payment on-chain object is created, the wallet inside the computerA object funds the 21000 satoshi that are stored in the payment object. Bob can withdraw the satoshi by calling the cashOut function."]},{"l":"Expressions","p":["The syntax for on-chain objects introduced provides a high-level abstraction over the transactions of the Bitcoin Computer protocol. However we also provide low-level access to the protocol via the computer.encode() function. This gives more control over the transaction being built, enabling advanced applications like DEXes.","The computer.encode function takes three arguments:","A Javascript expression exp,","an environment env that maps names to output specifiers,","and a module specifier mod.","It returns a transaction but does not broadcast it. Therefore calling the encode function does not alter the state of any on-chain object. In addition to the transaction the function returns an object effect that represents the state that will emerge on-chain if the transaction were included in the blockchain. If the transaction is not included, the on-chain state will not change. This gives the user complete predictability over the state change that will be induced by their action.","The effect object has two sub-objects: res contains the value returned from the expression and env contains the side-effect, specifically the new values of the names in the environment.","The code below is equivalent to calling await computer.new(Chat, ['hello']). In fact the smart contract abstraction introduced above is just syntactic sugar for using the encode function.","The encode function allows fine grained control over the transaction being built via an options object as a second parameter. Specifically one can specify","whether to fund the transaction","whether to include or exclude specific UTXOs when funding","whether to sign the transaction","which sighash type to use","which inputs to sign","to use a technique called mocking in order to build transactions when some of its inputs aren't known yet (see more below)"]},{"l":"Module System","p":["The computer.deploy function stores an ES6 modules on the blockchain. It returns a string representing the output where the module is stored. Modules can refer to one another using the familiar import syntax.","Note that moduleB refers to moduleA via specifierA.","These modules can also be loaded from the blockchain using computer.load.","Modules can also be passed into computer.encode:"]},{"l":"Bitcoin Script Support","p":["Todo"]},{"l":"Mocking","p":["Todo"]}],[{"l":"How it Works"},{"l":"Intuition","p":["The Bitcoin Computer embeds JavaScript expression in standard Bitcoin transactions. This expression is evaluated, and the result of that evaluation determines the transaction's outputs. If the JavaScript expression evaluates to a primitive value (e.g., number, string, boolean) or an object without sub-objects, that value is used to create a single output. If the expression evaluates to a JavaScript object with sub-objects, the object and each of its sub-objects is mapped to a separate output. This enables the creation of multiple outputs from a single expression.","A key feature is the ability to handle dependencies on data not directly available within the current transaction. For expressions with an undefined variable (for example, the variable x is undefined in the expression x + 1), the smart contract developer can associate that variables with an input of the transaction. The Bitcoin Computer then recursively calculates the values of these outputs, and replaces the undefined variables with their computed values from previous transactions to evaluate the expression."]},{"l":"Basic Example","p":["In this example, the transaction is inscribed with the arithmetic expression 1+2, which evaluates to 3. This value is then associated with the transaction’s first output. In a subsequent transaction, an expression x+4 uses this output's value as its variable x. Given that the output from the first transaction was 3, the expression in the second transaction evaluates to 7, and this new value is assigned to its output. This demonstrates how values can be propagated and transformed across transactions in the Bitcoin Computer system."]},{"l":"Detailed Description"},{"l":"Smart Contracts and Objects","p":["In the tutorial section, we introduced the concept of Smart Contract, typically referred as Javascript classes that extends from Contract. We also introduced the concept of Smart Object, which are instances of these classes. In this section, we will provide a more formal definition of these concepts.","In the Bitcoin Computer system, we refer to a smart contract as any valid JavaScript expression that is inscribed in a transaction. The value that such an expression evaluates to is called a smart value. When a smart value is of an object type, it is referred to as a smart object. This terminology is borrowed from object oriented programming and helps distinguish between a class and instances of that class, i.e. the objects created from such a class."]},{"l":"Data Ownership","p":["In the Bitcoin Computer, data ownership is linked to the ability to spend an output, similar to the ownership of Bitcoin. For enhanced security and ownership clarity, every “smart object” includes an _owners property, listing the public keys of its owners. Conversely, if an object is created with a property _owners that is set to an array of n string encoded public keys, then the output that represents the object has a 1-of- n multisig script with these public keys."]},{"l":"Creating Objects and Object Identity","p":["Associating values with transaction outputs facilitates the use of the transaction ID and output number as a unique identifier for each smart object. This identifier is assigned to the _id property of the smart object upon its creation and remains unchanged for the object’s entire lifespan."]},{"l":"Updating Objects and Object Revisions","p":["When a smart object is updated, a transaction is broadcast that spends the old state’s UTXO with new one, reflecting the object’s updated state. This transaction ID and output number are designated as the object’s revision and stored in the _rev property of the object. This mechanism ensures that each update is traceable and securely linked to the specific transaction."]},{"l":"Ancestors and Roots of Objects","p":["If an object is created in a function call of the form x.f(\\ldots) we say that x is its parent. We say that an object x_1 is the ancestor of an object x_n if there is a sequence of objects x_2 \\ldots x_{n-1} such that x_i is the parent of x_{i+1} for all i. The root of an object is its (unique) ancestor that does not have a parent. The Bitcoin Computer assigns the root of a smart object to the property _root. The root can be used to create fungible tokens with the Bitcoin Computer.","In other words, an object’s lineage is defined by its function calls. If an object is created within a function, the object calling the function is deemed the parent. An ancestor of an object is defined by a lineage of parent-child relationships leading back to a unique ancestor with no parent, which is called the root. The root identity is critical for creating fungible tokens, as it provides a stable reference point for all transactions and interactions related to that object."]},{"l":"Examples"},{"l":"Non Fungible Tokens","p":["The code on the left side of the picture below defines a class NFT with two properties _owners and url and a method send to update the _owners. The _owners property of a smart contract can be set to an array of string encoded public keys.","The right side of the picture shows a transaction in which both the class and a constructor call is inscribed. This expression evaluates to a new object of class NFT. It also shows that all three special properties _id, _rev, _root are assigned the same value: the transaction id of the transaction shown and the first output (we represent this string as a blue circle in the picture).","The picture below shows the same object after two updates. First, the expression nft.send('038e2...') is evaluated where nft refers to the object immediately after the constructor call. The second update is due to the evaluation of the expression nft.send('03f0b...') where this time nft refers to the object after the first update. We can see that the revision is changed after every update but the identity and the root stays the same.","The computer.sync function can be called with each revision of a smart object. This provides access to all historical states of a smart object."]},{"l":"Fungible Tokens","p":["The figure below illustrates the minting and sending of 100 fungible tokens. The blue user, with public key 03a1d..., mints the tokens in the first transaction, producing one output that represents the 100 newly minted tokens. The second transaction represents the distribution of tokens after the blue user sends 3 tokens to the green user, with public key 03f0b....","The blue output of the second transaction represents the 97 tokens that the blue user still holds, while the green output represents the three tokens now owned by the green user. The _root property of both outputs in the second transaction is linked to the output of the first transaction, as the memory cell for the three tokens was allocated within a function call.","This setup prevents forgery, as any two tokens with the same root can be traced back to the same mint. To mint a second token with the same root, one would have to broadcast a transaction with the transaction id of the first transaction, which is impossible."]}],[{"l":"Smart Contract Language","p":["The Bitcoin Computer uses Javascript with slight modifications. Specifically:","Property assignments are not permitted outside function calls. This makes it possible to impose constraints on all future values of an object, thereby making Javascript a viable smart contract language","Certain keyword properties have a special semantics. This gives the smart contract programmer fine grained control over the transaction being built.","Assignments to this is not permitted in constructor calls. This is necessary to ensure the first two properties.","These properties are technically enforced by the requirement that all objects returned from a smart contract inherit from a class Contract that is exported from the Bitcoin Computer Library.","In the following we explain the three properties in detail."]},{"l":"Assigning Properties Outside of Function Calls is Prohibited","p":["Assigning to a property outside of a function call throws an error.","This makes it possible to write classes that impose constraints on all future values of an object. Consider for example the class Even below. The condition guarantees that all instances of the class will always have an even value.","Calling await even.inc2() works as expected.","However, assigning to even.n outside of a function call throws an error.","While this is not a very useful example for a constraint, all smart contracts are based on constraints to future values in a similar way."]},{"l":"Special Semantics of Keyword Properties","p":["The Bitcoin Computer uses special properties (called keyword properties) that","control details of the transaction being build, and","give the user information as to where on the blockchain a smart object was created and where it is currently stored.","In the following we describe these properties in details"]},{"l":"Control Keyword Properties","p":["Properties named _amount, _owners, _readers, and _url provide control over the transaction being built. These properties can optionally be set in the smart contract.","The effect that these properties have on the transaction being built is described below:","If a property _amount is set it needs to be set to a number. It determines the amount of Satoshi stored in the output representing the current revision. If it is not set the revision will have a minimal (non-dust) amount of Satoshi.","If a property _owners is set it needs to be set to either an array of strings [p_1\\ ...\\ p_n] or to a string.","Array of strings: These determine the output script of the current revision. Specifically, the script for the current revision is a 1-of-n multisig script with the public keys p_1\\ ...\\ p_n. This guarantees that only a user that has a private key corresponding to one of the public keys can update the object. If the property is not set it defaults to the public key of the computer that created the object.","String: If the property is set to a string p, it should be set to an ASM representation of a script. This script is used as the output script of the current revision. This allows for more complex ownership conditions. For example, the script could be non-standard or it could be a multisig script with a different number of required signatures than 1.","If a property _readers is set it needs to be set to an array of strings [p_1\\ ...\\ p_n]. If this property is set the meta data in the corresponding transaction is encrypted such that only users with corresponding private keys can decrypt the expression and compute the value of the smart object. If the _readers property is not set the meta data is not encrypted and any user can compute the value of the smart object.","If a property _url is set it needs to be set to the url of a Bitcoin Computer node. If it is set the expression is not stored in the transaction but on the node instead. The transaction only contains a hash of the expression and the location where the expression can be obtained from the node. This is convenient if the expression is large, for example because it contains a lot of data."]},{"l":"Location Keyword Properties","p":["The properties _id, _rev, _root contain information about where a smart object was created and where it is currently stored. These properties are set by the runtime. While they can be read, attempts to overwrite their state will lead to an error.","The value of the _id property is the output (encoded as <transaction id>:<output index>) that represented the object immediately after it was created.","The value of the _rev property is the output of the currently representing the object (that is, the object's revision).","The value of the _root property is assigned once when the object is created and is never modified subsequently. If the expression that creates the object is of the form new C(...) then its root is equal to its id. If the expression is of the form x.f(...) then the root of the new object is equal to the id of x. Otherwise the root is set to n/a. The root property is useful for building fungible tokens."]},{"l":"Assigning to this in Constructors is Prohibited","p":["In order to enforce the properties above, it is currently not permitted to assign to this in constructor calls. Instead, an initialization object can be passed into the constructor:","This has the same effect as assigning to this in a normal Javascript program"]}],[{"l":"Transaction Format","p":["Coming soon."]}],[{"l":"Apps","p":["The following are examples of open source applications builded with the Bitcoin Computer. They are all published under MIT licence so you can clone, copy, modify, contribute or use them as a starting point for you project."]},{"l":"Wallet","p":["Non custodial, open source wallet for Bitcoin and Litecoin. You can send cryptocurrency to a friend and see your balance, and the transactions sent and received.","wallet.bitcoincomputer.io"]},{"l":"Explorer","p":["Bitcoin Computer Explorer. You can explore all objects created, or log in to update your smart objects using the UI. Use the playground to create any smart contract you can imagine!","explorer.bitcoincomputer.io"]},{"l":"Non Fungible Token","p":["You can mint an NFT and trustless list it for sale. You also can see your own NFTs or buy any NFT listed.","nft.bitcoincomputer.io"]}],[{"l":"Examples","p":["Method","Description","Non Fungible Token (NFT)","A non fungible token similar to ERC721","Fungible Token","A fungible token similar to ERC20","Encrypted Chat","An encrypted chat","Swap","Trustlessly exchange two smart object","Sale","Trustlessly sell a smart object to an unknown buyer"]}],[{"l":"Non Fungible Token"},{"l":"Smart Contract","p":["Our example class for a non-fungible token only has two properties name and symbol. It has one function transfer that updates the _owners property."]},{"l":"Usage","p":["To create a non-fungible token you can call the new function as shown below. The faucet function funds the sender object when the sender object is configured to regtest. The sender.new function mints a new NFT and the transfer function send the NFT to another user.","If more than one NFT are broadcast one can save transaction fees by broadcasting a module containing the NFT smart contract first. The class TCB721 is a helper class for that purpose."]},{"l":"Code","p":["You can find the code here."]}],[{"l":"Fungible Token"},{"l":"Smart Contract","p":["A fungible token has three properties, a amount indicating the number of tokens stored in the current smart object, a property symbol that stores the identifier of the tokens, and an _owners property set to the current owner of the smart object.","The transfer function takes two arguments, the public key of the recipient and an amount to be sent. This function first checks if the current smart object contains sufficient supply and throws an error if it does not. If the supply is sufficient the supply of the current smart object is reduced by the amount to be sent. A new smart object is created that is owned by recipient and that contains the amount to be sent. This object is returned from the function call to create a new smart object."]},{"l":"Usage","p":["The usage is as in the case of a non-fungible token."]},{"l":"Code","p":["You can find the code here."]}],[{"l":"Chat"},{"l":"Smart Contract","p":["A chat is just a smart object with a property messages of type string[]. Like all smart objects it has an _owners property set to the current data owner. The _readers property can be used to restrict read access."]},{"l":"Usage","p":["A new chat can be created using the new function. Note that Bob can initially post to the chat and read it's state as Bob's public key was added by Alice to the _owners array and to the _readers array upon creation of the chat.","Later, Alice called the remove function removing Bob's public key from these arrays. After this point Bob cannot read or write anymore.","Eve was never part of the _readers array so she cannot read the content of the chat, nor write to it."]},{"l":"Code","p":["You can find the code here."]}],[{"l":"Token Swap","p":["A token swap is the direct and immediate exchange of ownership of two tokens on the same chain. The swaps described below are atomic in the sense that either both assets change their owner or none of them. This enables trustless exchange, as the situation where the other party does not pay cannot arise.","A token swap is similar to an atomic swap, the difference being that atomic swaps usually refer to the exchange of cryptocurrency on two different chains, whereas token swaps exchange tokens on the same chain.","We note that the definition of a token swap differs wildly from the legal definition of a swap. While a token swap is the immediate exchange of two tokens, a swap in the legal sense involves an option to buy or sell an asset in the future."]},{"l":"Swap Using a Static Function","p":["You can build a swap as a static function that takes two arguments and exchanges their owners. This method preserves ordinal ranges, so it is safe to use this in smart objects that contain ordinals."]},{"l":"Smart Contracts","p":["The code below shows the NFT class. While this example uses NFTs as arguments, the same function can be used to swap any pair of smart objects that have a transfer function."]},{"l":"Minting the NFTs","p":["Alice and Bob mint NFTs using the computer.new function."]},{"l":"Building the Swap Transaction","p":["A swap transaction has two inputs and two outputs. The inputs spend the NFTs to be swapped. The outputs are the NFTs after the swap with their owners exchanged.","Alice passes an expression containing both the code of the StaticSwap class and the expression StaticSwap.exec(a, b) to the encode function. The second argument is an environment that determines that the values to be used for a and b are stored at revisions a._rev and b._rev.","The encode function will automatically sign all inputs of the transaction that can be signed with the private key of the computer object on which the function is called. In this case, this is the input as revision a._rev.","The function encode will not broadcast automatically. This feature is useful when you want to check the transaction before broadcasting it. It also allows more advanced use cases, for example, using different signature hash types, or signing only specific inputs. More on this in the API documentation."]},{"l":"Executing the Swap","p":["The transaction created above was partially signed (only Alice's signature was added). Bob now signs the input b._rev and broadcasts the transaction. When the transaction is included in the blockchain the swap is executed and the owners of the two NFTs are reversed."]},{"l":"Full Example","p":["The code snippet below shows how to create two nfts and swap them using the smart contract above."]},{"l":"Reducing Fees","p":["The disadvantage of the code above is that the swap class is written into the blockchain on every swap. This wastes block space and is expensive. A more efficient approach is to deploy the Swap function as a module first and then refer to the module from the transactions executing the swap. To make this easier, we provide a helper class SwapHelper for swaps and NftHelper for NFTs that can be used as follows:"]},{"l":"Code","p":["Have a look at the code on Github for details."]}],[{"l":"Sale","p":["We explain how to sell a smart object to an unknown buyer atomically and trustlessly. Whereas both objects are known in advance in a swap, the output containing the payment that Buyer will use in the sale is unknown when Seller is building the swap transaction. Seller builds a partial transaction consisting of only one input for the asset and one output for the payment received. Buyer can later add an input for the payment and an output for the asset after the sale.","These examples use several advanced features (sighash types, mocking, and controlling the order of inputs and outputs, ordinal safe programming) that are not sufficiently documented elsewhere. If you would like to use these features we suggest to ask about their safe use here."]},{"l":"Smart Object Sale","p":["We first explain a simpler version that works for the Bitcoin Computer but not for ordinals. The next section explains a version that can be used with ordinals.","Seller needs to build a partial transaction containing an input spending the asset and an output for receiving the payment. The sighash type SIGHASH_SINGLE | SIGHASH_ANYONECANPAY allows Seller to sign only the first input and output.","Buyer wants to obtain the smart object in the first input so Buyer is incentivized to build the transaction according to the protocol. If he broadcasts transaction that is invalid in the Bitcoin Computer protocol, Buyer destroys the smart object but pays the Seller."]},{"l":"Smart Contracts","p":["We call this transaction described above the \"crossover\" transaction because the asset passes from the first input to the second output and the payment passes from the second input to the first output. In order to build it with the Bitcoin Computer, one needs to know that the order of inputs is determined by the order of objects in the environment and the order of outputs is determined by the order of objects in the value returned from the expression.","Seller uses an environment { n: ..., p: ... }, indicating that the first input will spend the NFT n and the second input will spend the payment p. Seller will use the expression ${Sale} Sale.exec(n, p). As the exec function of the Sale contract returns an array [p, n] the first output wil represent p and the second output will represent n. This is exactly the \"crossover\" transaction described above.","The first argument to the exec function is an nft of the following class.","The second argument is created by Buyer to pay for the nft.","In the following sections, we explain the process of seller minting an NFT and creating a sales transaction as well as a buyer going through a purchase."]},{"l":"Minting an NFT","p":["To mint an nft, Seller can use the computer.new function."]},{"l":"Building the Sales Transaction","p":["The challenge in creating the sales transaction arises from the fact that the output containing the payment is not yet created at the time of building the transaction. This is a problem because, in order to evaluate an expression on the Bitcoin Computer, either a smart object or a revision of an existing smart object is required for all parameters of the call.","To handle such scenarios the Bitcoin Computer provides a feature called mocking. A mock is a class that has the properties _id, _rev, _root, _amount, and _owners, and sets them to strings of the form mock:transaction-id:output-number. A mock does not have to extend from Contract. Each mocked object must have a distinct transaction id and output number.","The following code shows the class to create the payment mock as well as Seller creating a new instance with the standard Javascript new keyword.","Now Seller is ready to create and sign the partial sale transaction using as shown below. There is a lot going on here, so we will break down the arguments below.","The expression contains the source code of the Sale class and an expression that calls the static exec function.","The next two lines contain the instructions for the mocking system. Seller can use the mock object that was created earlier as shown in the code below. The revision of the mock is passed in as the payment revision to the environment; and an object is passed to the mocks key that maps the name payment to the mock object. If an object is mocked up, the Bitcoin Computer will build a transaction without checking that mocked up objects exist on the blockchain and will assume that the value is as in the object passed into mocks. Later buyer will update the input that spends the revision of the payment mock with the revision and output number of an actual payment.","To enable Buyer to modify Seller's transaction later, Seller signs the first input with the sighash type SIGHASH_SINGLE | SIGHASH_ANYONECANPAY. This means that Seller's signature remains valid even when arbitrary inputs and outputs are added to the transaction as long as the input and the output that Seller has signed have the same index. This guarantees that any transaction that contains the input that spends Sellers NFT will also contain the output that pays Seller. This is how Seller is guaranteed to always get paid. Essentially, the Seller is stating: \"you can spend the output containing the NFT as long as you include the output that pays me\".","Finally, Seller set's funding to false to prevent the transaction from being funded by the encode function as Seller wants Buyer to cover the transaction fees.","Seller can publish the sales transaction to the general public. An interested buyer can create a payment object and complete and broadcast the sale transaction to purchase the nft. This is described in the next section."]},{"l":"Buying the NFT","p":["First, Buyer creates a smart object that can be used in the sale.","Next, Buyer updates the second input of the transaction that currently spends the payment swap.","Then Buyer updates the second output to contain Buyer's public key. This ensures that Buyer will be new owner of the nft.","Finally Buyer funds, signs, and broadcasts to execute the sale."]},{"l":"Full Example","p":["The code below shows the whole process of minting an nft, listing it for sale, and a purchase. Working code can be found here"]},{"l":"Reducing Fees","p":["The example before is wasteful because the source code of the Sale class is written into the blockchain on every sale. To avoid this, we recommend to deploy the Sale class and refer to the module when executing a sale.","We provide a class NftHelper that helps with deploying the smart contract as a module, minting the nfts with a reference to the deployed module, transferring NFTs, and returning the balance and owner of an NFT.","The code below shows how the same flow as above can be implemented using the NftHelper class."]},{"l":"Ordinal Sale","p":["The Sale smart contract is not safe to use with ordinals because the smart objects have different ordinal ranges before and after the call. To preserve the ordinal ranges the expression must not use the _amount keyword and must not return an object or an array containing an object.","Building a sale contract for ordinals is more complicated than for smart objects. A very clever construction was proposed by Rodarmor here and later refined. Our smart contract below implements this exact idea."]},{"i":"smart-contracts-1","l":"Smart Contracts","p":["The exec function of the OrdSale class swaps the owners just like in the Sale class. However it then proceeds to double the amount of b1 and return [b1, t, p, b2].","When the exec function is evaluated, a transaction of the following form is built:","The amount of b1 after the call is the sum of the amounts of b1 and b2 before combined. The smart object b1 therefore absorbs the entire ordinals range of b2. The objects n and p do not change their amounts during the call, these objects preserve their ordinal ranges.","We now explain the whole process of minting an NFT, listing it for sale, and processing a purchase. We skip the step for minting as it was described above."]},{"i":"building-the-sales-transaction-1","l":"Building the Sales Transaction","p":["In order to build the sale transaction, Seller first needs to create the objects b1, b2, and p:","Next Seller can build the sales transaction by executing the following code:","Conceptually this is very similar to the use of encode above. Note however, that Seller signs the third input output pair this time. This is because the NFT is spent by the third input and the payment that Seller wants to obtain is in the third output."]},{"l":"Buying the Ordinal NFT","p":["This process is similar to the case of a smart object sale above. See the example blow."]},{"i":"full-example-1","l":"Full Example"},{"i":"reducing-fees-1","l":"Reducing Fees","p":["Just like in the case of selling smart object sales, one can save transaction fees by using the module system through a helper class as shown below."]},{"l":"Code","p":["You can find the code here."]}],[{"l":"Lib","p":["The Bitcoin Computer Library (available on Github and Npm) provides all the functionality needed to write smart contracts with the Bitcoin Computer.","To interface with the blockchain, the Bitcoin Computer Lib connects to a Bitcoin Computer node. By default the Bitcoin Computer Lib connects to a node in regtest node that we provide. You can find more information about configuration options in the section constructor."]},{"l":"Api"},{"l":"Basic","p":["You can build almost all smart contracts with following methods.","Method","Description","constructor","Creates an instance of class Computer","new","Creates a smart object from a smart contract","query","Finds the latest revisions of smart object","sync","Computes the state of a smart object from a given revision"]},{"l":"Advanced","p":["To build advanced applications like swaps have a look at the following.","Method","Description","encode","Encodes a Javascript expression into a Bitcoin transaction","encodeNew","Encodes a constructor call into a Bitcoin transaction","encodeCall","Encodes a function call into a Bitcoin transaction","decode","Parses a Bitcoin transaction and returns Javascript expression","faucet","Fund a computer object on Regtest"]},{"l":"Modules","p":["You can save transaction fees by using our ES6 module system.","Method","Description","deploy","Deploys an ES6 module on the blockchain","load","Loads an ES6 module from the blockchain"]},{"l":"Wallet","p":["Access Bitcoin's RPC interface","broadcast","Broadcasts a Bitcoin transaction","Confirmed, unconfirmed and total balance in sats","Description","getAddress","getBalance","getChain","getMnemonic","getNetwork","getPassphrase","getPrivateKey","getPublicKey","getUtxos","Method","Returns a BIP39 mnemonic sentence","Returns an array of unspent transaction outputs","Returns the Bitcoin address of the computer wallet","Returns the blockchain","Returns the network","Returns the passphrase","Returns the private key","Returns the public key","rpcCall","send","Sends satoshis to an address","sign","Signs a Bitcoin transaction","The wallet functionality within a Computer instance can be accessed using the following."]}],[{"l":"broadcast","p":["The broadcast function broadcasts a Bitcoin transaction to the Bitcoin mining network."]},{"l":"Type"},{"l":"Syntax"},{"l":"Parameters","p":["Parameter","Description","tx","A Bitcoin transaction object."]},{"l":"Return value","p":["If broadcast is successful, it returns an string encoding the transaction id. Otherwise, an error is thrown."]},{"l":"Examples"}],[{"l":"constructor","p":["The constructor of the Computer class creates an instance. It's functionality is described in this API documentation."]},{"l":"Type"},{"l":"Syntax"},{"l":"Parameters"},{"l":"config","p":["2","30000 on LTC and 3000 on BTC","A configuration object","addressType","BIP32 passphrase","BIP32 path","BIP39 mnemonic phrase","chain","Default Value","Description","Dust relay fee","dustRelayFee","Fee in satoshi per byte","https://rltc.node.bitcoincomputer.io","Key","LTC","m/44'/0'/0'","mnemonic","moduleStorageType","network","p2pkh","passphrase","path","Random phrase","regtest","satPerByte","Store ES6 modules on Taproot or multisig scripts","taproot","Target blockchain. Values can be 'LTC' or 'BTC'","Target network. Values in 'testnet', 'regtest' or 'mainnet'","The address script type. Values in 'p2pkh', 'p2wpkh', 'p2tr'","The empty string","url","Url of a Bitcoin Computer Node"]},{"l":"Return Value","p":["An instance of the Computer class"]},{"l":"Examples"}],[{"l":"decode","p":["The decode function parses a Bitcoin transaction to determine if it is a Bitcoin Computer transaction. If so it returns an expression exp, a blockchain environment env, and a module specifier mod. The function decode is the inverse of encode when the latter is called with exp, env, and mod."]},{"l":"Type"},{"l":"Syntax"},{"l":"Parameters","p":["Parameter","Description","tx","A Bitcoin transaction object."]},{"l":"Return value","p":["It returns a Bitcoin transaction and an object of type Effect.","The object of type Effect captures the changes induced by evaluating the expression: It contains the result of the evaluation (property res) and the side effects of the evaluation (property env). The object of type Effect can be used to determine if the evaluation had the desired effect. If it did, the transaction can be broadcast to commit the update to the blockchain. If the transaction is not broadcast, the state on the blockchain does not change. The transaction can be broadcast at an arbitrarily long delay after calling encode. If during the time between calling encode and broadcasting the transaction the blockchain undergoes any updates that could affect the evaluation, the miners will reject the transaction. However, if the transaction is accepted by the miners, it is guaranteed to have the effect indicated by object of type Effect.","If fund is required, and the wallet has insufficient funds, an error is thrown. If sign is required, the default behavior is to sign all inputs. The encode function will make a best effort to sign all inputs, but will not throw any error if the signature cannot be added due to hash mismatch. This is useful in the case of partially signed transactions, where a user can encode an expression, sign with the user private key and send the generated partially signed transaction to another user. Then, the receiver can sign the remaining inputs."]},{"l":"Examples"}],[{"l":"deploy","p":["The deploy function stores an ES6 module on the blockchain and returns an identifier for that module. This identifier can be passed into the functions computer.new, computer.encode, computer.encodeNew, and computer.encodeCall to make the exports of the module available there.","The advantage of deploying your code is that it can save transaction fees: A large piece of code can be deployed once and then used to create or update many smart objects.","Please note that modules are not encrypted, even if objects that use them have the _readers property set.","There are two different modes to store a module on the blockchain: taproot or multisig mode. The default mode is taproot. The mode can be changed by passing the option moduleStorageType into the constructor of the Computer class. In Taproot mode, the module is stored in a Taproot script. This is cheeper and it enables you to store larger Javascript programs in a module. The multisig mode stores the module in multisig scripts. This is more expensive but compatible with chains that do not support Taproot."]},{"l":"Type"},{"l":"Syntax"},{"l":"Parameters","p":["Parameter","Description","module","A string encoding an ES6 module."]},{"l":"Return value","p":["A string encoding the location where the module is stored. The format is <transaction id>:<output number>."]},{"l":"Examples","p":["Previously this function was called export but this name is deprecated since version 0.16.0."]}],[{"l":"encode","p":["The encode function builds a Bitcoin transaction from a Javascript expression according to the Bitcoin Computer protocol. In addition to the transaction, this function also returns the value of the expression.","If the expression contains free variables (for example the variable x in the expression x.f()) a \"blockchain environment\" must be passed. A blockchain environment is a JSON object that maps variable names to the latest revisions of smart objects.","A module specifier can be provided in order to make the exports of that module are available to the evaluation.","Other options can customize the funding and signing process.","The state update effected by a Bitcoin Computer transaction is completely predictable:","If the transaction is included in a block the new state will be exactly the state returned from the effect function.","If the transaction is not included the state is not updated."]},{"l":"Type"},{"l":"Syntax"},{"l":"Parameters"},{"l":"opts","p":["[]","{}","1=SIGHASH_ALL","A Blockchain environment, maps free variables to latest revisions","A Javascript expression","A module specifier","A pair <name, object>. The object is an instance of a mocked class (A class that does not extends from Contract but has the keywords _id, _root, _amount,_owners)","An object with the basic configuration parameters to encode the expression in a transaction.","boolean","Default Value","Description","env","exclude","exp","fund","If set to a string a custom input script can be provided. If undefined a signature script is generated","If set to an number the corresponding input is signed. If undefined all inputs are signed.","include","inputIndex","inputScript","Key","mocks","mod","Module specifiers and UTXOs are encoded as strings of the form <transaction id>:<output number>","number","Record<string, any>","Record<string, string>","sighashType","sign","string","string[]","The sighash type","true","Type","undefined","UTXOs to exclude when funding","UTXOs to include when funding","Whether the transaction should be funded","Whether to sign the transaction"]},{"l":"Return value","p":["It returns an object { tx, effect } where tx is a Bitcoin transaction and effect is an object with keys res and env.","The transaction tx is an object from the NakamotoJS library - a BitcoinJS clone that supports LTC, BTC, PEPE and DOGE, and has some extra features that make is easier to build advanced applications like exchanges.","The res object contains the result of the evaluation.","The env object has the same keys as the blockchain environment. However, whereas the values of the blockchain environment are revision strings, the values of env and the smart object at these revisions after evaluating the expression."]},{"l":"Examples"}],[{"l":"encodeCall","p":["Encodes a function call. This function is syntactic sugar for encode."]},{"l":"Type"},{"l":"Syntax"},{"l":"Parameters"},{"l":"params","p":["A module specifier","An object with the configuration parameters to encode the expression in a transaction.","args","Description","InstanceType<T>","Key","mod","Module specifiers are encoded as strings of the form <transaction id>:<output number>","Parameters<InstanceType<T>[K]>","property","string","target","The arguments to the function call","The name of the function being called","The smart object on which to call the function","Type"]},{"l":"Return value","p":["It returns an object { tx, effect } where tx is a Bitcoin transaction and effect is an object with keys res and env. For more details see the description of the return type of encode."]},{"l":"Examples"}],[{"l":"encodeNew","p":["Encodes a constructor call. This function is syntactic sugar for encode."]},{"l":"Type"},{"l":"Syntax"},{"l":"Parameters"},{"l":"params","p":["An object with the configuration parameters to encode the expression in a transaction.","Key","Type","Description","constructor","T extends new (...args: any) => any","A Javascript class that extends from Contract","args","ConstructorParameters<T>","Arguments to the constructor of the class","mod","string","A module specifier","Module specifiers are encoded as strings of the form <transaction id>:<output number>"]},{"l":"Return value","p":["It returns an object { tx, effect } where tx is a Bitcoin transaction and effect is an object with keys res and env. For more details see the description of the return type of encode."]},{"l":"Examples"}],[{"l":"faucet","p":["The faucet function funds a computer object. It is only available when the computer object is connected to a node in regtest mode. The faucet function creates a utxo to fund the address. The utxo is created with the amount of satoshis specified in the first parameter. The address to be funded can be specified in the second parameter. If the address is not specified, the address of the computer object is used. The transaction is broadcasted to the network, and a block is mined immediately to confirm the transaction."]},{"l":"Type"},{"l":"Syntax"},{"l":"Parameters","p":["Parameter","Description","amount","An amount of Satoshi","address","An string encoded address to be funded"]},{"l":"Return value","p":["The utxo created to fund the address."]},{"l":"Examples"}],[{"l":"fund","p":["Funds a Bitcoin transaction."]},{"l":"Type"},{"l":"Syntax"},{"l":"Parameters","p":["Parameter","Description","tx","A Bitcoin transaction object."]},{"l":"opts","p":["An optional object can be passed as parameter to include or exclude certain UTXOs. When using include, the transaction will be funded with the UTXOs specified as the first inputs.","Key","Type","Description","Default Value","include","string[]","UTXOs to include","[]","exclude","UTXOs to exclude"]},{"l":"Return value","p":["If the wallet does not have sufficient funds, an error is thrown."]},{"l":"Examples"}],[{"l":"getAddress","p":["Returns a string encoding Bitcoin address. Will return an address according to the type set in the Computer constructor."]},{"l":"Type"},{"l":"Syntax"},{"l":"Return value","p":["Returns a string encoded Bitcoin address."]}],[{"l":"getBalance","p":["Returns an object with the current balance in Satoshi, the confirmed balance in Satoshi (at least 1 confirmation), and the unconfirmed balance in Satoshi."]},{"l":"Type"},{"l":"Syntax"},{"l":"Return value","p":["Returns the current balance in Satoshi."]}],[{"l":"getChain","p":["Returns the chain."]},{"l":"Type"},{"l":"Syntax"},{"l":"Return value","p":["Returns a string encoding the chain."]}],[{"l":"getMnemonic","p":["Returns a string encoding a BIP39 mnemonic sentence."]},{"l":"Type"},{"l":"Syntax"},{"l":"Return value","p":["The mnemonic."]}],[{"l":"getNetwork","p":["Returns the network."]},{"l":"Type"},{"l":"Syntax"},{"l":"Return value","p":["Returns a string encoding the network."]}],[{"l":"getPassphrase","p":["Returns the BIP39 passphrase."]},{"l":"Type"},{"l":"Syntax"},{"l":"Return value","p":["Returns the BIP39 passphrase."]}],[{"l":"getPrivateKey","p":["Returns a string encoded private key."]},{"l":"Type"},{"l":"Syntax"},{"l":"Return value","p":["Returns a string encoded private key."]}],[{"l":"getPublicKey","p":["Returns a string encoding a public key."]},{"l":"Type"},{"l":"Syntax"},{"l":"Return value","p":["Returns a string encoding a public key."]}],[{"l":"getUtxos","p":["Returns an array of unspent transaction outputs (UTXOs). Each UTXO is encoded as a string of the form <transaction id>:<output number>"]},{"l":"Syntax"},{"l":"Type"},{"l":"Return value","p":["Returns an array of unspent transaction outputs (UTXOs)."]}],[{"l":"load","p":["Imports a ES6 module from a module specifier encoded as a string <transaction id>:<output number>."]},{"l":"Type"},{"l":"Syntax"},{"l":"Parameters","p":["Parameter","Description","rev","A string encoding a module specifier."]},{"l":"Return value","p":["A ES6 module."]},{"l":"Examples"}],[{"l":"new","p":["Creates a new smart object. The parameters are a smart contract (a Javascript class inheriting from Contract), a list of arguments for the constructor of the class and an optional module specifier. The arguments of the constructor can be of basic data type or smart objects. The new function builds a transaction that records the creation of a new smart object, signs it and broadcasts it. Smart objects can be updated by calling their functions, see here."]},{"l":"Type","p":["Here a MetaData is the type"]},{"l":"Syntax"},{"l":"Parameters","p":["Parameter","Description","constructor","A named Javascript class that extends from Contract.","args","Arguments to the constructor of the class.","mod","A module specifier, i.e., the revision string of a deployed module (see deploy)."]},{"l":"Return value","p":["Returns an instance of the class T. The class T should extend from Contract. The returned object has extra properties _id, _rev, _root, _owners, _amount and possibly _url, _readers."]},{"l":"Examples"}],[{"l":"next","p":["Documentation coming soon."]}],[{"l":"prev","p":["Documentation coming soon."]}],[{"l":"query","p":["Returns the latest revisions of smart objects. Conditions can be passed in to determine the smart objects. When multiple conditions are passed in, the latest revisions of the smart objects that satisfy all conditions are returned."]},{"l":"Type"},{"l":"Syntax"},{"l":"Parameters"},{"l":"params","p":["'ASC' | 'DEC'","An object with the query parameters.","Description","ids","Key","limit","mod","number","offset","order","Order results in ascending or descending order","publicKey","Return latest revision of smart objects with ids in order","Return latest revisions of smart objects owned by a public key","Return only limited number of revisions","Return results starting from offset","Return the latest revision of smart objects created with this module specifier","string","string[]","Type"]},{"l":"Return value","p":["Given the query parameters, returns an array of strings encoding the latest revisions of smart objects that matches the specified conditions."]},{"l":"Examples"}],[{"l":"rpcCall","p":["Calls a Bitcoin RPC method with the given parameters."]},{"l":"Type"},{"l":"Syntax"},{"l":"Parameters","p":["Parameter","Description","method","An string encoding the name of the rpc function to be called.","params","An string with the argument list of the rpc function call to be called, separated by spaces."]},{"l":"Return value","p":["A JSON object with the result of the rpc method call."]},{"l":"Examples"}],[{"l":"send","p":["Sends a payment."]},{"l":"Type"},{"l":"Syntax"},{"l":"Parameters","p":["Parameter","Description","amount","A number representing the amount of satoshis to be sent.","address","An string encoding the receiver address."]},{"l":"Return value","p":["If successful, it returns the id of the transaction broadcast."]},{"l":"Examples"}],[{"l":"sign","p":["Signs a Bitcoin transaction. Options can be passed in that determine which inputs to sign, the sigHash type to use, and which script to use."]},{"l":"Type"},{"l":"Syntax"},{"l":"Parameters","p":["A Bitcoin transaction, possibly partially signed.","A buffer encoding the signature","A valid sighash type number","An object with specific parameters to use when signing.","Buffer","Description","inputIndex","inputScript","Key","number","opts","Parameter","sighashType","The input index to be signed","The opts object can have the following properties:","tx","Type"]},{"l":"Return value","p":["By default, the sign function will make a best effort to sign all inputs, but will not throw an error if the signature cannot be added due to hash mismatch.","This is useful in the case of partially signed transactions, where a user can encode an expression, sign with the user private key and send the generated partially signed transaction to another user. Then, the receiver can sign other inputs."]},{"l":"Examples"}],[{"l":"sync","p":["Returns smart objects given a location on the blockchain. The location can either be a revision (a string of the for <transaction id>:<output number>) or a transaction id."]},{"l":"Type"},{"l":"Syntax"},{"l":"Parameters","p":["Parameter","Description","location","An string encoding a revision or a transaction id."]},{"l":"Return value","p":["If the function is called with a revision, it returns the smart object stored at the provided revision. Note that the revision must not be a latest revision. In that case a historical state of the revision is returned.","If the function is called with a transaction id, it returns an object of type { res: Json; env: Json }. The value of res is the result of evaluating the expression inscribed into the transaction. The env object has the same keys as the blockchain environment of the transaction, the values of env are the smart objects at these revisions after evaluating the expression.","If the parameter is not a valid revision or transaction id, an error is thrown."]},{"l":"Examples"},{"l":"Sync to a Revision","p":["Synchronizing to the revision returns a smart object."]},{"l":"Sync to a transaction id","p":["Synchronizing to a transaction id returns all smart objects on that transaction."]}],[{"l":"Node"},{"l":"Prerequisites","p":["You need to have git, node.js and docker installed."]},{"l":"Installation"},{"l":"Usage"},{"l":"Start the Node","p":["To start your node at http://localhost:1031 run the commands below. The node is ready once the log activity subsides. On regtest this will take a few minutes, on mainnet and testnet it can take days or even weeks, depending on your hardware.","The node will create the docker volumes in the packages/node/chain-setup/** directory of the selected chain and network. This folder contains the blockchain data and the database. The postgres database is used to efficiently store the complete blockchain data, for fast access and indexing."]},{"l":"Run the Tests","p":["You can run the integration tests with the command below.","On Litecoin regtest, the halving period is set to infinity. This makes it possible to run a large number of tests without having to restart the node."]},{"l":"Fund the Wallet","p":["In regtest mode, you can fund a wallet with the following commands."]},{"l":"Stop the Node","p":["You can stop the node with the command below. When you restart the process, it will resume from the last block processed."]},{"l":"Reset the Node","p":["The command below will reset the database, delete all blockchain data, and stop all docker containers."]},{"l":"Configuration","p":["You can configure several options by editing the .env file."]},{"l":"Client Side Library","p":["The Bitcoin Computer Library can connect to a Bitcoin Computer Node to provides access to its functionality.","If you do not specify a url property it will default to the url below. The node at that url runs Litecoin on regtest network mode and uses the latest version of the Bitcoin Computer Node software."]},{"l":"Api","p":["The Bitcoin Computer Node exposes an API that can be used to interact with the node. The variables CHAIN and NETWORK are used to define the chain and network that the node is running on."]},{"l":"Wallet","p":["Method","Description","balance","Get the balance of a wallet.","list-txs","List sent and received transactions for a given address.","sent-outputs","List sent outputs of a wallet.","received-outputs","List received outputs of a wallet.","utxos","List unspent outputs of a wallet."]},{"l":"Transactions","p":["Method","Description","ancestors","Get the ancestors of a transaction.","bulk","Get raw transactions for a list of transaction ids.","json","Get a transaction in json format.","post","Post a transaction to the Bitcoin network."]},{"l":"Blockchain","p":["Method","Description","height","Get the height of an specific block.","mine","Mine an specific number of blocks to a random address.","rpc","Call a Bitcoin RPC method."]},{"l":"Regtest Faucet","p":["Method","Description","faucet","Get coins from the faucet.","faucetScript","Get coins from the faucet using a script."]},{"l":"Query revisions","p":["Method","Description","next","Get the next revision of a given revision.","prev","Get the previous revision of a given revision.","non-standard-utxos","Query revisions by module specifier, public key, limit, order, offset and list of transaction ids.","revs","Get the revisions of a list of transactions.","revToId","Given a revision, get the id of the smart contract."]},{"l":"OffChain","p":["Method","Description","id","Get the data stored in the offchain storage.","store","Stores the hex of the data in the offchain storage."]},{"l":"Versioning","p":["If you run your own node, make sure to use the same versions of Lib and Node."]}],[{"l":"height"},{"i":"v1chainnetworkidheight","l":"/v1/CHAIN/NETWORK/:id/height","p":["Get the height of an specific block. The id can be best or a block given hash."]}],[{"l":"mine"},{"i":"v1chainnetworkmine","l":"/v1/CHAIN/NETWORK/mine","p":["Mine an specific number of blocks to a random address."]}],[{"l":"rpc"},{"i":"v1chainnetworkrpc","l":"/v1/CHAIN/NETWORK/rpc","p":["Call a Bitcoin RPC method."]}],[{"l":"id"},{"i":"v1storeid","l":"/v1/store/:id","p":["Get the data stored in the offchain storage."]}],[{"l":"store"},{"i":"v1store","l":"/v1/store","p":["Stores the hex of the data in the offchain storage."]}],[{"l":"next"},{"i":"v1chainnetworknextrev","l":"/v1/CHAIN/NETWORK/next/:rev","p":["Get the next revision of a given revision."]}],[{"l":"non-standard-utxos"},{"i":"v1chainnetworknon-standard-utxos","l":"/v1/CHAIN/NETWORK/non-standard-utxos","p":["Query revisions by module specifier, public key, limit, order, offset and list of transaction ids."]}],[{"l":"prev"},{"i":"v1chainnetworkprevrev","l":"/v1/CHAIN/NETWORK/prev/:rev","p":["Get the previous revision of a given revision."]}],[{"l":"revs"},{"i":"v1chainnetworkrevs","l":"/v1/CHAIN/NETWORK/revs","p":["Get the revisions of a list of transactions."]}],[{"l":"revToId"},{"i":"v1chainnetworkrevrevtoid","l":"/v1/CHAIN/NETWORK/rev/:revToId","p":["Given a revision, returns the id of the smart contract."]}],[{"l":"faucet"},{"i":"v1chainnetworkfaucet","l":"/v1/CHAIN/NETWORK/faucet","p":["Send coins to an address."]}],[{"l":"faucetScript"},{"i":"v1chainnetworkfaucetscript","l":"v1/CHAIN/NETWORK/faucetScript","p":["Send coins to a script."]}],[{"l":"ancestors"},{"i":"v1chainnetworktxtxidancestors","l":"/v1/CHAIN/NETWORK/tx/:txId/ancestors","p":["Returns an array with the transaction IDs of the ancestors of a given transaction. An ancestor is a transaction that is an input to the given transaction."]}],[{"l":"bulk"},{"i":"v1chainnetworktxbulk","l":"/v1/CHAIN/NETWORK/tx/bulk","p":["Returns the raw transaction hexes for a given list of transaction IDs."]}],[{"l":"json"},{"i":"v1chainnetworktxtxidjson","l":"/v1/CHAIN/NETWORK/tx/:txId/json","p":["Returns the JSON representation of a given transaction."]}],[{"l":"post"},{"i":"v1chainnetworktxpost","l":"/v1/CHAIN/NETWORK/tx/post","p":["Posts a raw transaction to the network and returns its transaction ID."]}],[{"l":"balance"},{"i":"v1chainnetworkaddressaddressbalance","l":"/v1/CHAIN/NETWORK/address/:address/balance","p":["Returns the confirmed, unconfirmed and total balance for a given address."]}],[{"l":"list-txs"},{"i":"v1chainnetworkwalletaddresslist-txs","l":"/v1/CHAIN/NETWORK/wallet/:address/list-txs","p":["Returns the sent and received transactions for a given address."]}],[{"l":"received-outputs"},{"i":"v1chainnetworkwalletaddressreceived-outputs","l":"/v1/CHAIN/NETWORK/wallet/:address/received-outputs","p":["Returns the outputs that were received by a given address."]}],[{"l":"sent-outputs"},{"i":"v1chainnetworkwalletaddresssent-outputs","l":"/v1/CHAIN/NETWORK/wallet/:address/sent-outputs","p":["Returns the outputs that were sent from a given address."]}],[{"l":"utxos"},{"i":"v1chainnetworkwalletaddressutxos","l":"/v1/CHAIN/NETWORK/wallet/:address/utxos","p":["Returns the UTXOs for a given address."]}],[{"l":"Api","p":["The Bitcoin Computer Node exposes an API that can be used to interact with the node. The variables CHAIN and NETWORK are used to define the chain and network that the node is running on."]},{"l":"Wallet","p":["Method","Description","balance","Get the balance of a wallet.","list-txs","List sent and received transactions for a given address.","sent-outputs","List sent outputs of a wallet.","received-outputs","List received outputs of a wallet.","utxos","List unspent outputs of a wallet."]},{"l":"Transactions","p":["Method","Description","ancestors","Get the ancestors of a transaction.","bulk","Get raw transactions for a list of transaction ids.","json","Get a transaction in json format.","post","Post a transaction to the Bitcoin network."]},{"l":"Blockchain","p":["Method","Description","height","Get the height of an specific block.","mine","Mine an specific number of blocks to a random address.","rpc","Call a Bitcoin RPC method."]},{"l":"Regtest Faucet","p":["Method","Description","faucet","Get coins from the faucet.","faucetScript","Get coins from the faucet using a script."]},{"l":"Query revisions","p":["Method","Description","next","Get the next revision of a given revision.","prev","Get the previous revision of a given revision.","non-standard-utxos","Query revisions by module specifier, public key, limit, order, offset and list of transaction ids.","revs","Get the revisions of a list of transactions.","revToId","Given a revision, get the id of the smart contract."]},{"l":"OffChain","p":["Method","Description","id","Get the data stored in the offchain storage.","store","Stores the hex of the data in the offchain storage."]}],[{"l":"Comparison","p":["We explain how smart contract systems for Bitcoin work in simple terms. We then compare the Bitcoin Computer to other systems according to the following properties:","Trustlessness. We call a system trustless if no trusted third party is required for its operation. Trustlessness is the main point of the entire crypto endeavour as Satoshi pointed out in the second sentence of the Bitcoin white paper: \"the main benefits are lost if a trusted third party is still required\".","Expressiveness. A system is expressive if it can express all computable smart contracts, formally if it is Turing Complete. Assets created in such general purpose protocols can be freely composed and moved between applications.","Efficiency. A system is efficient if it is possible to compute some smart contract data without having to parse all transactions in the blockchain. This is important for two reasons: the obvious one is that it is faster to compute some values. The other is that it is possible to compute values in parallel.","This writeup is based on a presentation we gave at the Litecoin Summit in 2024. You can find the slides here and a video recording here."]},{"l":"Results","p":["-","Bitcoin","Bitcoin Computer","Channels","Efficient","Ethereum","Expressive","Interoperable","No","Order based","Rollup","Sidechain","The table below captures the results of our comparison. Each result is explained in detail in the following sections.","Trustless","UTXO based","Yes"]},{"l":"Blockchains","p":["For context we briefly discuss to what extent Bitcoin and Ethereum have the three properties we are interested in."]},{"l":"Bitcoin","p":["Bitcoin is a trustless peer-to-peer currency. We will assume familiarity with the basic working of Bitcoin and focus on the three properties from above.","Bitcoin is assumed to be trustless as long as a majority of the hash power is honest. However it is not expressive as it only supports one application: a currency. It is also not efficient as one needs to validate all transactions and check the proof of work of every block in order to determine if the amount in an output is unspent and the transaction containing the output is valid."]},{"l":"Ethereum","p":["Ethereum is the first blockchain to popularize general purpose smart contracts. It assumed to be trustless as longs as a majority of the staked cryptocurrency is owned by honest validators. In addition it is expressive due to its native smart contract support. However, it is not efficient: to determine the storage of one address, a full node needs to synchronize with the entire blockchain, validating all transactions and computing all smart contract invocations."]},{"l":"State Channels and Networks","p":["State channels, originally designed to reduce fees, have recently found applications in smart contract systems. They allow two parties to conduct transactions off-chain with only the final agreed-upon state recorded on the blockchain. Two parties can send payments back and forth an unlimited number of times at a constant cost. However the fee reduction is less pronounced for unidirectional payments.","While state channels work well between two users, they do not scale to a large number of users, because creating channels between all users quickly becomes uneconomical. To address this shortcoming, channel networks have been developed. These use smart contracts called Hashed-Timelock-Contracts (HTLCs) to create chains of channels that securely forward payments, ensuring that intermediate nodes cannot steal funds. This enables efficient hub-and-spoke architectures where a central hub forwards payments between users. One downside is the existence of a central point of failure in the form of the hub; another is that users need to be online to receive payments securely."]},{"l":"Examples","p":["The Lightning Network extends the hub-and-spoke model to a decentralized network of payment channels. The key challenge is to solve the routing problem: to send a payment between two users, a path of channels must be determined where each channel has sufficient liquidity to forward the payment. To determine such a path, users must have up to date knowledge of the balances of all channels. If a user's knowledge of channel balances is outdated, the payment can fail.","Watchtowers allow users to accept payments whilst offline. These are third party services that monitor end users' channels for suspicious activity and react accordingly. The downside is that this introduces a trusted third party. More info","The ARK protocol is a layer-two solution designed for off-chain Bitcoin transactions, aiming to provide a low-cost, setup-free payment system. ARK relies on trusted intermediaries called ARK Service Providers (ASPs) to manage shared UTXOs. In ARK, transactions are conducted using virtual UTXOs (VTXOs), which are off-chain transaction outputs that can be converted into on-chain UTXOs when needed. Payments within ARK are coordinated by the ASPs through periodic \"rounds,\" where users exchange their VTXOs for new ones off-chain. Additionally, ARK offers \"out-of-round\" payments for faster, direct transactions between parties. More info","The RGB protocol enables smart contracts. All meta data is stored offline, which lowers availability guarantees. RGB uses transaction outputs as \"single-use seals\" that ensure that only the owner can modify the contract state. RGB uses specially-designed virtual machine called AluVM, which is is nearly computationally universal, but with a bounded by number of operation steps, similar to in Ethereum-like systems. RGB has support for for enhanced privacy via a modified form of confidential transactions. RGB can operate over regular Bitcoin transactions and over the lightning network. More info","The Bitcoin Computer currently does not support channels networks. However we mention it here as an integration could be built in principal. The Bitcoin Computer will be further discussed here."]},{"l":"Evaluation","p":["Trustlessness. State channels and networks are trustless as long as users are online. When users are not online they need to trust watchtowers to keep user funds safe. Smart contract systems that rely on channel networks inherit these properties.","Expressiveness. Most channel networks are geared towards payments, therefor they cannot express smart contracts. However some smart contract protocols can integrate with state channels, in which case all smart contracts of the respective protocol can be expressed.","Efficiency. Our definition of efficiency only makes sense for smart contract systems, so this property does not apply to payment networks."]},{"l":"Interoperable Blockchains","p":["An interoperable blockchain is a separate blockchain that connects to Bitcoin in various ways. In most cases smart contracts of the interoperable blockchain can read and write transaction from and to Bitcoin. In some cases, Bitcoin is used in the consensus of the interoperable blockchain."]},{"i":"examples-1","l":"Examples","p":["Stacks enables smart contracts that use Bitcoin as an asset in a trust-minimized way. It has its own native asset called STX. The Stacks blockchain relies on STX and BTC for its consensus mechanism called Proof of Transfer (PoX). Stacks miners bid by spending BTC, and their probability of mining the next block on the STX chain is proportional to the amount bid. This amount is paid to STX holders that lock up or \"stack\" their STX. As a consequence the price ratio between BTC and STX is continually recorded and available on-chain. Stacks's smart contract language is a non-Turing complete language called Clarity. More info","Todo. More info"]},{"i":"evaluation-1","l":"Evaluation","p":["Trustlessness. Interoperable blockchains are as trustless as the blockchain that is connected to Bitcoin.","Expressiveness. Typically, all smart contract systems can be expressed.","Efficiency. Interoperable blockchains that support smart contracts are typically based on the account model like Ethereum and are therefore not efficient."]},{"l":"Sidechains","p":["A sidechain is a separate blockchain linked to Bitcoin through a two-way peg.","A user sends their Bitcoin to a dedicated address controlled by the group of users that maintain the peg. These users then create the corresponding value of tokens on the sidechain. Those tokens can be used to access the functionality of the sidechain. Later, the sidechain user can transfer tokens back to the maintainers the peg, who will hopefully send the corresponding amount of tokens back to the sidechain user.","Two-way pegs can be centralized, federation-based, or SPV-based. In centralized two-way pegs a trusted third party controls the Bitcoin in the peg and is responsible for locking and unlocking the Bitcoin. In a federated peg, the locked Bitcoins are at the custody of a group of users called the federation. A common implementation is to use a multisignature address, in which a quorum of participants is required to spend the funds. Simplified Payment Verification (SPV) makes it possible to verify the inclusion of a transaction in a blockchain without verifying the entire blockchain. A SPV two-way peg scheme could work as follows: The locked Bitcoin are stored in an output that can only be spent if an SPV proof is provided that a corresponding number of tokens have been burnt on the sidechain."]},{"i":"examples-2","l":"Examples","p":["Liquid Network is a federated sidechain, relying on the concept of strong federation. A strong federation consists of two independent entities: block signers and watchmen. Block signers maintain the consensus and advance the sidechain, while watchmen realize the cross-chain transactions by signing transactions on the mainchain using a multisignature scheme.","The members of the federation maintain the consensus of the sidechain by signing blocks in a round-robin fashion. The federation consists of large exchanges, financial institutions, and Bitcoin-focused companies but their identities are not public. Users trust that at least two-thirds of the federation is acting honestly to ensure security. Watchmen sign each block transferred between the mainchain and the sidechain on the mainchain using a multisignature scheme.","The sidechain Liquid is based on the Bitcoin codebase, however it has a 10x higher throughput due its block time of just one minute. Liquid supports the creation of on chain assets as well as enhanced privacy through confidential transactions. More info.","Rootstock (RSK) is a smart contract platform with a native token called Smart Bitcoin (RBTC) that is pegged 1:1 with Bitcoin (BTC) and is used to pay for gas when executing smart contracts on the RSK network. RSK is merge-mined with Bitcoin, meaning that RSK miners also mine Bitcoin but not vice versa.","RSK relies on a combination of a federated two-way peg and an SPV (Simplified Payment Verification) scheme. Users can send Bitcoin to the peg and they are issued RBTC on the RSK sidechain. Each transfer between the sidechain and the main chain requires a multi-signature by the RSK federation to complete the transferring process. Federation members use hardware security modules to protect their private keys and enforce transaction validation. More info"]},{"i":"evaluation-2","l":"Evaluation","p":["Both centralized and federation based sidechains have the disadvantage of introducing trusted third parties, arguably defeating the purpose of a blockchain solution. SPV based solutions have the advantage of being trustless, however users have to wait for lengthy confirmation periods. The second problem is that the consensus mechanism of the sidechain is typically less secure than Bitcoin's, making it the weakest link in the system and prone to attacks.","Trustlessness. Only for pure SPV based solutions. Expressiveness. If the sidechain uses the account model. Efficiency. No as the sidechain typically uses the account model."]},{"l":"Rollups","p":["A rollup is similar to a sidechain but (a) the federation is replaced by a smart contract and (b) transaction data is stored on the main chain instead of a separate blockchain. The rollup can have its own transaction format independent from the main chain and we will refer to these transactions as L2 transactions.","To use a rollup, a user deposits funds to the rollup smart contract on the main chain. These funds can then be used in L2 transactions. To use the rollup, a user sends a L2 transaction to a designated user called aggregator. Periodically, the aggregator selects a batch of L2 transactions, creates a main chain transaction and publishes it. This main chain transaction contains the L2 transactions in compressed form and the hash of the new state. The rollup’s smart contract on the main chain assures the aggregator posted the hash of the correct new state. There are different ways that this check occurs, optimistically or using zero knowledge proofs, as discussed below. When users wish to redeem their deposit, they transact with the rollup’s smart contract on the main chain and receive funds equal to the amount of their balance on the L2."]},{"l":"Optimistic Rollups","p":["In an optimistic rollup the aggregator posts the compressed L2 transactions and the hash of the new state to the main chain without any verification. A group of users called verifiers check that the new state matches the instructions in the L2 transactions. Verifiers can then publish a \"fraud proof\", claiming that the aggregator posted an incorrect hash.","To discourage aggregators and verifiers from acting maliciously, both the aggregator and verifier need to stake a bond. If the verifier can provide a valid fraud proof, the verifier earns half of the aggregator’s bond while the other half is burned (this is to prevent a scenario where a malicious aggregator tries to front-run an honest validator by publishing another fraud proof). If the fraud proof is invalid, the verifier gets fined."]},{"l":"Zero-knowledge Rollups","p":["While optimistic rollups use fraud proofs, zero-knowledge (ZK) rollups, and validity rollups more generally, use validity proofs. Instead of allowing the aggregator to publish a transaction and then question it, in ZK rollups, the aggregator must prove that the state hash is the correct using a validity proof.","Similarly to optimistic rollups, an aggregator (sometimes called sequencer) evaluates L2 transactions and published compressed transaction data and the new state hash to the main chain. However they add a ZK proof that is evaluated by a smart contract on the main chain. The smart contract ensures that only correct executions are recorded on the main chain. In contrast to optimistic rollups, ZK rollups do not require second layer verifiers and there is no dispute resolution. This means transactions achieve finality rapidly; there is no extended period of time where verifiers can trigger a dispute phase.","The two most commonly used ZK proofs used for rollups are called SNARKs and STARKs. SNARKs are computationally efficient: the time needed to verify a SNARK grows slower than the time of the computation itself. However, they require a trusted setup. STARKs require no trusted setup, but require much more time for proof generation and verification."]},{"i":"examples-3","l":"Examples","p":["BitVM is an optimistic rollup. Its primary purpose is facilitating trust minimized bridges between Bitcoin and other chains.","A federation of 1000 members engage in a trusted setup and users trust that at least 1 participant is honest, otherwise the federation can steal all funds. Peg-ins can be censored by any federation member as a peg in requires the collaboration of all federation members. In addition all federation members need to pre-sign 100 peg-out transactions each (100.000 transactions in total), therefore peg-ins only occur every 6 months.","There are 100 operators and users trust that at least one online operator is honest, otherwise the user can be prevented from pegging out. Operators must be able to front the money for a peg out for two weeks, so only well capitalized institutions can be operators. Withdraws can take months to give validators the chance to go through the challenge process. Any user can be a validator.","The transactions that are broadcast in the BitVM protocol","To \"peg in\", a user called Bob sends 100 Bitcoin to a n-of-n multisig address controlled by the federation. In exchange, the federation will issue Bob tokens on the destination blockchain. When Bob want's to \"peg out\", Bob signals his wish to the federation by burning tokens on the destination blockchain. Operators can front the 100 Bitcoin to Bob in a \"Peg Out\" transaction. The operator then broadcasts the \"kick-off\" transaction. If all goes well, and there is no dispute, the federation will broadcast the \"Take 1\" transaction that spends 100 Bitcoin to the operator.","In the case of a dispute, any validator will broadcast the \"Challenge\" transaction. Once this transaction is broadcast, the \"Take 1\" transaction cannot be spend anymore, as both transaction spend the same output (this is called a connector output). Once the \"Challenge\" transaction is broadcast the operator will broadcast the \"Assert\" transaction that breaks down the high level statement that the operator originally made, into smaller, easily disprovable statements. If any of these lower level statements are incorrect, any verifier can broadcast a \"Disprove\" transaction that points to the false statement by the operator. If no validator broadcasts a Disprove transaction, the operator can broadcast a \"Take 2\" transaction to regain control of the original 100 Bitcoin. More info here and here.","Todo. More info"]},{"i":"evaluation-3","l":"Evaluation","p":["Rollups rely on smart contracts on the main chain, therefore it is easier to make them trustless and practical on chains with strong native smart contract support like Ethereum. By understanding the properties of rollups on Ethereum, we can understand how rollups on Bitcoin can work in the best case.","On Ethereum rollups generally introduce trusted third parties, central points of failures, and lockup periods.","As building a validity proof requires heavy computations ZK rollups’ L2 fees are higher than optimistic rollups. Additionally, ZK rollup main chain transaction fees are higher as the validity proof needs to be validated on the main chain for every batch.","On the other hand, optimistic rollups have a period where verifiers have an opportunity to publish a fraud proof. Thus users need to wait (usually a week on Ethereum, on Bitcoin it will likely be longer) until their deposits can be withdrawn. In ZK-rollups, deposits could be withdrawn immediately, however in many cases users have to wait for 24h due to safety concerns. In most cases there is only one aggregator and a very small number of validators and users trust that they do not collude.","Trustlessness. In optimistic rollups users trust that one honest validator is online at all times. STARKs are trustless, SNARKS are not.","Expressiveness. Depends on the expressiveness of the L2.","Efficiency. Depends on the efficiency of the L2."]},{"l":"Complexity of SNARKs and STARKs","p":["The Big-O notation is used in Computer Science to describe the upper bound of the runtime of an algorithm in terms of the size of its input. An algorithm is said to run in time O(f(n)) if for sufficiently large input sizes n, the algorithm's runtime will not exceed c * f(n) steps.","Prover Complexity refers to the computational complexity associated with generating a proof for a given computation. Verifier Complexity refers to the computational complexity associated with verifying the correctness of a proof for a given computation. The table below is obtained from here","Type","Trustless","Prover Complexity","Verifier Complexity","SNARKs","No","O(n \\cdot \\text{log}(n))","O(1)","STARKs","Yes","O(n \\cdot \\text{log}(n)^c)","O(\\text{log}(n)^c)","Verifier complexity for SNARKs is O(1) meaning that the time to verify a computation can be take longer for small inputs but is faster (even constant) for large enough inputs. Verifier complexity for STARKs is O(\\text{log}(n)^c) meaning that it can take much longer to verify a short computation but for very large computations verification is faster than computation."]},{"l":"Meta Protocols","p":["A user of a meta protocol that wants to write smart contract data adds meta data to a transaction and sends it to the Bitcoin miners. Software that is specific to the protocol parses the meta data and computed smart contract data (like the number of tokens owned by a user) from it.","There are two basic types of meta protocols called block-order based and UTXO based. These two types result form two basic ways of viewing a UTXO based blockchains: as a list of transactions and as a graph of transactions."]},{"l":"Block-order based","p":["The software for a block-order based protocol reads all transactions in the main chain in block-order to find transactions with meta data specific for that protocol. It will then interpret that sequence of meta data values as instructions and build up a data structure of smart contract data. The smart contract data will for example store which user owns which tokens."]},{"l":"Formal Description","p":["We denote the set of transactions by T. We denote by V the set of smart contract data values where \\{\\} \\in V denotes the empty value. We denote the set of sequences of values in a set X by X^*.","A block-order based meta protocol P consists of a function f: V \\times T \\rightarrow V. Let t_1 \\ldots t_n \\in T^* be the sequence of meta data values for P in the main chain in the order of their occurrence. Then P computes the smart contract data value f( \\ldots f(f(\\{\\}, t_1), t_2) \\ldots , t_n)."]},{"i":"example-brc20","l":"Example: BRC20","p":["Example trace in the BRC20 protocol","The BRC20 protocol is a protocol for fungible tokens.","The image on the right shows an example execution of the BRC20 protocol. The left column shows the meta data values and the column on the right shows the value that is computed after parsing each respective meta data value. The smart contract data value is initialized to the empty element \\{\\}. The first meta data value { op: deploy, ... } specifies the deployment of a fungible token called \"lite\" with a maximum supply of 1000. Once the BRC20 software parses this meta data value it updates its computed value to { lite: { max : 1000 }} as shown on the right. The next transaction contains a mining instruction and the software will update it's internal value accordingly as shown on the right. The bottom row shows a transaction shows a transfer transaction and the computed value that reflects that ownerB received one token from ownerA. The ownership of the assets is determined by the ownership of the outputs that contain the meta data. See here for more details."]},{"i":"evaluation-4","l":"Evaluation","p":["Trustlessness. Yes.","Expressiveness. No, the existing block-order based protocols that we are aware of are single purpose only.","Efficiency. No, block order based protocols need to parse all transactions to compute a single value.","There are two other issues issues: Block-order based protocols cannot be real time as there is no indication in which order the transactions will occur on the mempool before a block is mined. Miners are incentivized to include transactions in an order that is advantageous to them. This is a common problem in Ethereum called \"miner extracted value\" (MEV)."]},{"l":"UTXO based","p":["Whereas block order based systems compute one global value from all transactions, UTXO based protocols compute a value for each output that is relevant to that protocol. The value computed for an output can usually depend on the meta data on that transaction and the valued computed for the inputs spent."]},{"l":"Formal Description","p":["Let O be the set of outputs. A UTXO based protocol P is a function P: O \\rightarrow V that map outputs to smart contract data values.","We will say that a protocol P is well designed if P(o) can be computed from the meta data on the transaction containing o and the values of the outputs spent by t. That is, there is a function f_P: O \\times V^* \\rightarrow V such that P(o) = f_P(o, P(o_1) \\ldots P(o_n)) where o_1 \\ldots o_n are the outputs spent by the transaction containing o.","We can see that all well designed UTXO based protocols are efficient: You can compute the value of an output by parsing \"only\" the transactions that are reachable form the transaction containing the output via the of the spending relation, potentially using multiple hops. This is still a large number of transactions in general, but for some values for example those on the outputs of a coinbase transaction can be computed from one transaction."]},{"i":"example-ordinals","l":"Example: Ordinals","p":["The ordinals protocol is a protocol for non-fungible token. It associates an integer with every satoshi and a list of integers with each output. The length of the list of integers is equal to the number of satoshis stored in the block. It does not require any meta data.","The Ordinals protocol","The ordinals algorithm computes the block rewards r_1, r_2, \\ldots for every block in a chain. It then labels the output of the coinbase transaction of block i with the numbers ranging from r_0 + \\ldots + r_{i-1} to r_0 + \\ldots + r_i where r_0 = 0. To label the outputs of a transaction with inputs, the algorithm first determined the ordinal ranges of the outputs being spent and concatenates them. This array is used to label the outputs as follows: for each output, the algorithm will remove as many numbers from the array as the output has satoshis and assign that list of numbers to the output. The array will be sufficiently long as the number of satoshis spent by a transaction transaction must always be at least the number of satoshis in the output. This presentation is slightly simplified as it does not take fees into account, for details see here.","We can see an example in the picture. The top transaction is the coinbase transaction of the first block. As the output of this transaction contains 5 Billion satoshis (= 50 Bitcoin) this output is labelled with the numbers 1, 2, \\ldots 5.000.000.000. The transaction below spends that output and contains two outputs with 20 and 30 Bitcoin. The first of these outputs is labelled with the numbers 1, 2, \\ldots 2.000.000.000 and the second with 2.000.000.001 \\ldots 5.000.000.000. You can find more information here.","Trustlessness. Yes. Expressiveness. No. Efficiency. Yes."]},{"i":"example-runes","l":"Example: Runes","p":["The Runes protocol","The runes protocol is a protocol for fungible tokens. Its smart contract data values are key value pairs where keys are token ids and its values are numbers. The meta data values are an efficient encoding of nested json objects.","There are distinct kinds of meta data values: \"etchings\" are used to deploy tokens, they can specify for example how many times a token is mined through the cap key and the number of tokens created in each mint via a key called amount. Minting instruction specify a token id (encoded as block-number.offset). \"Edicts\" transfer the tokens spent by the inputs into the outputs. A transfer transaction contains a list of edicts, each of which transfers the token id to transfer, the amount, and the output number. The meta-data is encoded into an array of integers which is stored in the op-return.","The picture shows an etching that deploys a new fungible token called \"lite\" that can be minted 10 times, creating 100 tokens on every mint. This transaction is assumed to be the 4th transaction in block 123. The second transaction show mints 100 tokens, the third transaction transfers the minted tokens into two outputs with one and 99 tokens each. You can find more information in the ordinals docs.","Trustlessness. Yes. Expressiveness. No. Efficiency. Yes."]},{"i":"example-bitcoin-computer","l":"Example: Bitcoin Computer","p":["The Bitcoin Computer protocol","This Bitcoin Computer is a general purpose meta protocol, meaning that it can express all computable smart contracts. The smart contract data values are arbitrarily nested Javascript objects. The meta data values contain mostly Javascript expressions.","There are two types of transactions: \"modules\" contain Javascript (ES6) modules. All other transactions contain a Javascript expression, a \"blockchain environment\" that associated (free) variables in the expressions with input numbers, and an optional \"module specifier\" containing a transaction id. In order to compute the value of an output, the Bitcoin Computer software","imports the module from the transaction referred to","computes the values for the outputs being spent and then substitutes these values for the free variables in the expressions as designated by the blockchain environment","evaluate the expression with the substitution applied in the scope of the module","The picture shows the deployment, minting, and sending a non fungible token and a non fungible token. For more details see the rest of the documentation.","Trustlessness. Yes. Expressiveness. Yes. Efficiency. Yes."]},{"l":"Sources","p":["[1] SoK: Applications of Sketches and Rollups in Blockchain Networks, Arad Kotzer, Daniel Gandelman and Ori Rottenstreich; Technion, Florida State University[2] Blockchain Scaling Using Rollups: A Comprehensive Survey, Louis Tremblay Thibault, Tom Sarry, and Abdelhakim Senhaji Hafid; Montreal[3] SoK: unraveling Bitcoin smart contracts, Nicola Atzei, Massimo Bartoletti, Tiziana Cimoli, Stefano Lande, Roberto Zunino; Cagliari, Trento[4] Beyond Bitcoin: A Review Study on the Diverse Future of Cryptocurrency, Mohammed Faez Hasan, University of Kerbala[5] BitML: A Calculus for Bitcoin Smart Contracts, Massimo Bartoletti, Roberto Zunino; Cagliari, Trento[6] An Overview of Smart Contract and Use cases in Blockchain Technology, Bhabendu Kumar Mohanta, Soumyashree S Panda, Debasish Jena; IIIT Bhubaneswar[7] Layer 2 Blockchain Scaling: a Survey, Cosimo Sguanci, Roberto Spatafora, Andrea Mario Vergani; Polytechnico Milano[8] A Rollup Comparison Framework, Jan Gorzny, Martin Derka; Zircuit[9] SoK: Decentralized Finance (DeFi)[10] SoK: Communication Across Distributed Ledgers[11] Colored Coins whitepaper, Yoni Assia, Vitalik Buterin, liorhakiLior, Meni Rosenfeld, Rotem Lev[12] Exploring Blockchains Interoperability: A Systematic Survey[13] bitcoinlayers.org[14] bitcoinrollups.io[15] Hiro Blog[16] Validity Rollups validity_rollups_on_bitcoin.md"]}],[{"l":"Legal Notice","p":["Sanctioned Users are Prohibited. You may not access or use software developed and published by us if you are (i) a resident of any country with which transactions or dealings are prohibited by governmental sanctions imposed by the U.S., the United Nations, the European Union, the United Kingdom, or any other applicable jurisdiction (collectively, “Sanctions Regimes”); (ii) a person, entity or government prohibited under an applicable Sanctions Regime (“Sanctioned Person”), including the Office of Foreign Assets Control, Specially Designated Nationals and Blocked Persons List; or (iii) prohibited from accessing or using the Software pursuant to the laws, rules, and regulations in the jurisdiction in which you reside or otherwise access and use the Software.","Users Must Comply with Applicable Law. You may only access or use the Software in compliance with laws, rules, and regulations in the jurisdiction in which you reside or otherwise access and use the Software, including, as applicable, Sanctions Regimes, anti-money laundering laws and regulations, and securities laws and regulations.","BCDB Does Not Endorse or Promote User Software Activity. We are publishing certain portions of the Software, on an open-source basis, to demonstrate the utility of the Bitcoin Computer. As this Software is open-source, it may be modified and deployed for a wide range of uses that we may not have intended. We do not endorse or promote, and expressly disclaim liability for, any non-BCDB use or modification of the Software."]}]]