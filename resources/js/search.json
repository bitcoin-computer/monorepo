[[{"l":"Bitcoin Computer"},{"l":"A Turing-complete Metaprotocol for UTXO-based Blockchains","p":["The Bitcoin computer is a protocol for building applications that are as secure and decentralized as Bitcoin is. You can build games, tokens, exchanges and more without relying on a sidechain, an extra token, or a trusted third party.","Free Computation- Smart contracts are executed on the client. Execution costs are fixed and independent of the number of computational steps.","Multicoin. Deploy on Bitcoin, Litecoin, Dogecoin, and Pepecoin (Bitcoin Cash coming soon) using the same code.","JavaScript & Typescript- Build decentralized applications that integrate seamlessly into web applications using your favorite tools and execute on high performance Javascript engines.","Simple- Deploy a smart contract by inscribing a JavaScript class, create an on-chain object by inscribing a constructor call and update an on-chain object by inscribing a function call.","Fast- Built-in optimizations eliminate redundant computation, ensuring high-performance applications out of the box.","History- Every historical state is recoverable. Each update is stored in a timestamped, digitally signed transaction.","Data Ownership- On-chain objects are stored in UTXOs, meaning only the UTXO owner can modify the data. This ensures data ownership is as secure as cryptocurrency ownership.","Compatible- Compatible with existing Bitcoin protocols. Build apps for Ordinals, Runes, or even integrate with BitVM to enforce complex data ownership rules.","Privacy- Public by default, but supports encryption and off-chain storage for CCPA- and GDPR-compliant applications.","The Bitcoin Computer is developed by BCDB Inc. Join our community on Telegram or on X."]}],[{"l":"Start"},{"l":"Use in the Browser","p":["Create the file below and open it in a browser. It show *, then 0 and finally 1."]},{"i":"use-in-nodejs","l":"Use in Node.js","p":["You need to have node.js installed. First download and install the Bitcoin Computer library from npm:","Then create a file index.mjs.","Execute the smart contract.","The expected output is:"]},{"l":"Run a Node","p":["In the examples above you are using a Bitcoin Computer Node that we provide at rltc.node.bitcoincomputer.io configured to Litecoin Regtest. You can use this node for free but it is rate limited. For serious development we recommend to clone the monorepo so you can run your own, unlimited, node. To run a node we recommend to clone the monorepo with all Bitcoin Computer related materials."]},{"l":"Clone and Install"},{"l":"Start the node","p":["To start your node at http://localhost:1031 run the commands below. The node is ready once the log activity subsides. On regtest this will take a few minutes, on mainnet and testnet it can take hours or even days, depending on your hardware and network connection."]},{"l":"Run the Tests","p":["Once the node is up an running, open a separate terminal window and navigate the monorepo folder. You can run the following commands. The commands will be executed in each package. You can also navigate the a package and run the same scripts there."]},{"l":"Configure Client Side Library","p":["To run the examples above with your own node, change the line that creates to Computer instance as below."]},{"l":"Start A Project","p":["We provide two templates, vite-template for client side projects and node-template for server side projects. Alternatively have a look at our example apps (e.g. our wallet, blockchain explorer, or nft app) to see if any of them are a good starting point for your project."]},{"l":"Getting Help","p":["Telegram","Twitter"]}],[{"l":"Tutorial","p":["In this tutorial we explain how to build a decentralized chat. We will start with a comically simple version of a one person chat, but we will work our way up to a chat platform where users can build a community and sell it trustlessly through a smart contract."]},{"l":"A Smart Contract","p":["The Javascript program below is a smart contract for a one-person chat.","We recommend to ignore the syntax for initializing messages in the constructor for now. If you are interested in the details you can find them here."]},{"l":"The Client-Side Wallet","p":["The Computer class is a client-side Javascript wallet that manages a Bitcoin private-public key pair. It can create normal Bitcoin transactions but also ones that contain metadata according to the Bitcoin Computer protocol. This allows for the creation, updating, and retrieval of on-chain objects.","You can pass a BIP39 mnemonic into the constructor to create a specific private-public key pair, or leave the mnemonic parameter undefined to generate a random wallet. More configuration options are described here."]},{"l":"Creating On-Chain Objects","p":["The computer.new function broadcasts a transaction inscribed with a Javascript expression consisting of a class and a constructor call. For example, the call","broadcasts a transaction inscribed with the expression below.","The Bitcoin Computer protocol interprets such a transaction as creating an on-chain object of type Chat at the first output of the transaction.","The object chat returned from the computer.new call is similar to the object returned from the call new Chat('hello'). However it has additional properties _id, _rev, _root, _owners and _amount:","The properties _id, _rev, _root are set to strings of the form id:num where id is the id of the transaction broadcast by the computer.new call and num is an output number.","The _owners property is set to an array containing public keys.","The _amount property specifies an amount in satoshis.","We refer to chat as an on-chain object.","Note that the transaction that created chat does not contain an encoding of the object itself. It only contains code that evaluates to its state."]},{"l":"Updating On-Chain Objects","p":["When a function is called on an on-chain object, a transaction is broadcast that is inscribed with a Javascript expression encoding the function call and an environment determining the undefined variables in the expressions. For example, the call","broadcasts a transaction tx that is inscribed with the data below.","The transaction's first input spends the output in which the previous revision of the chat object was stored.","Note that it is not possible to compute a value from the expression chat.post('world') alone because the variable chat is not defined. To make the expression determined the transaction's inscription contains an environment env that associates the variable name chat with its first input.","To compute the value of the chat after the post function is called and the transaction tx is broadcast, the Bitcoin Computer protocol first computes the value stored at the output spent by the first input of tx. This value is then substituted for the name chat in the expression chat.post('world'). Now the expression is completely determined and can be evaluated. The new value for chat is associated with the first output of tx. In our example, this value is","The property _rev has been updated and now refers to the first output of tx. The properties _id, _root, _owners, _amount have not changed. The meaning of these special properties is as follows:","_id is the output in which the on-chain object was first created. As this output never changes the _id property never changes","_rev is the output where the current revision of the object is stored. Therefore, initially, the revision is equal to the id, then the revision is changed every time the object is updated.","_root is never updated. As it is not relevant to the chat example we refer the interested reader to this section.","_owners is set to the public key of the data owner. More on that below.","amount is set to the amount of satoshi of the output in which an on-chain object is stored. More here.","The properties _id, _rev, and _root are read only and an attempt to assign to them throws an error. The properties _owners and _amount can be assigned in a smart contract to determine the transaction that is built.","The state of the on-chain objects is never stored in the blockchain, just the Javascript expression that creates it. This makes it possible to store data compressed to its Kolmogorov complexity which is optimal."]},{"l":"Reading On-Chain Objects","p":["The computer.sync function computes the state of an on-chain object given its revision. For example, if the function is called with an the id of an on-chain object, it returns the initial state of the object","If computer.sync is called with latest revision it returns the current state."]},{"l":"Finding On-Chain Objects","p":["The computer.query function returns an array of strings containing the latest revisions of on-chain objects. For example, it can return the latest revision of an object given its id:","A basic pattern in applications is to identify a on-chain object by its id, to look up the object's latest revision using computer.query, and then to compute its latest state using computer.sync. For example, in our chat app the url could contain a chat's id and the latest state of the chat could be computed as shown below.","computer.query can also return all revisions of on-chain objects owned by a public key. This could be useful for creating a user page for the chat application.","It is also possible to navigate the revision history of a on-chain object using computer.next and computer.prev:","Note that the code above only works because there are only two revisions of the chat in our example, otherwise computer.next or computer.prev would have to be called multiple times."]},{"l":"Data Ownership","p":["We are finally ready to elevate our one-person chat to a three-person chat! We will explain how to allow an unlimited number of users further below.","The owner of an on-chain object is the user that can spend the output that stores it, just like the owner of the satoshi in a output is the user that can spend it.","The owners can be set by assigning the _owners property. If this property is set to an array of public keys, the output script is a 1-of-n bare multisig script, meaning that any owner can update the object. If it is undefined the owner default to the public key of the computer object that created the on-chain object.","In the chat example, the initial owner is the public key of the computer object on which computer.new function was called. Only that user can post to the chat. We can add a function invite to update the owners array to allow other users to post.","While a user can never change an on-chain object that they do not own, the owner has complete control. This includes the ability to destroy their own objects by spending their outputs with a transaction that does not conform to the Bitcoin Computer protocol. In this case the value of the object will be an Error value.","This is reminiscent of the real world where people have the right to destroy their own property but not the right to destroy somebody else's property."]},{"l":"Encryption","p":["By default, the state of an on-chain object is public in the sense that any user can compute its state by using computer.sync. However, read access can be restricted by setting an objects _readers property to an array of public keys. If _readers is assigned, the meta-data on the transaction is encrypted using a combination of AES and ECIES so that only the specified readers have read access.","For example, to ensure that only people invited to the chat can read the messages, you can update our example code as follows:","As all updates to an on-chain object are recorded in immutable transactions it is not possible to restrict access to a revision once it is granted. It is also not possible to grant read access to a revision without granting read access to its entire history as the entire history is needed to compute the value of a revision. It is however possible to revoke read access from some point forward or to restrict access to all revisions all together.","When on-chain objects are encrypted the flow of cryptocurrency is not obfuscated."]},{"l":"Off-Chain Storage","p":["It is possible to store the metadata of a transaction off-chain in the database of a Bitcoin Computer Node. In this case a hash of the metadata and a url where the metadata can be retrieved is stored on chain, while the metadata itself is stored on the server. To use this feature, set a property _url of an on-chain object to the URL of a Bitcoin Computer Node.","For example, if users want to send images to the chat that are too large to store on-chain, they can use the off-chain solution:"]},{"l":"Cryptocurrency","p":["Recall that an on-chain object is stored in an output and that the owners of the object are the users that can spend the output. Thus the owners of an object are always the owners of the satoshi in the output that stores the object. We therefore say that the satoshi are stored in the on-chain object.","The amount of satoshi in the output of an on-chain object can be configured by setting the _amount property to a number. If this property is undefined, the object will store an a minimal (non-dust) amount.","If the value of the _amount property is increased, the additional satoshi must be provided by the wallet of the computer object that executes the call. In the case of a constructor call with computer.new that is that computer object. In the case of a function call it is the computer object that created the on-chain object.","If the value of the _amount property is decreased, the difference in satoshi is credited to the associated computer object's wallet.","For example, if a user Alice wants to send 21000 satoshis to a user Bob, then Alice can create an on-chain object of the following Payment class.","When the payment on-chain object is created, the wallet inside the computerA object funds the 21000 satoshi that are stored in the payment object. Bob can withdraw the satoshi by calling the cashOut function."]},{"l":"Expressions","p":["A Javascript expression exp,","an environment env that maps names to output specifiers,","and a module specifier mod.","It returns a transaction but does not broadcast it. Therefore calling the encode function does not alter the state of any on-chain object. In addition to the transaction the function returns an object effect that represents the state that will emerge on-chain if the transaction is broadcast.","The code below is equivalent to calling await computer.new(Chat, ['hello']). In fact the computer.new function is just syntactic sugar for using the encode function.","The computer.encode function takes three arguments:","The effect object has two sub-objects: res contains the value returned from the expression and env contains the side-effect, specifically the new values of the names in the environment.","The effect object returned from the encode function provides absolute certainty about a transaction's impact before broadcasting. If the transaction is included, the state updates exactly as reflected in the effect object, independent of other users' transactions; otherwise, the state remains unchanged.","The encode function allows fine grained control over the transaction being built via an options object as a second argument that can specify","The syntax for on-chain objects introduced above provides a high-level abstraction over the Bitcoin Computer protocol. However we also provide low-level access to the protocol via the computer.encode() function. This gives more control over the transaction being built, enabling advanced applications like DEXes.","whether to fund the transaction","whether to include or exclude specific UTXOs when funding","whether to mock objects to do not exist yet on-chain (see more below)","whether to sign the transaction","which inputs to sign","which sighash type to use when signing"]},{"l":"Module System","p":["The computer.deploy function stores an ES6 modules on the blockchain. It returns a string representing the output where the module is stored. Modules can refer to one another using the familiar import syntax. In the example below moduleB refers to moduleA via specifierA. Module specifiers can be passed into computer.encode and computer.new functions.","Modules can be loaded from the blockchain using computer.load."]},{"l":"Bitcoin Script Support","p":["In addition to setting the _owners property to an array of strings as described above, it is possible to set _owners to a string encoding a Bitcoin Script ASM. In this case the output created for that on-chain object will use a pay-to-script-hash (p2sh) output with that script.","In order to spend an output with a p2sh script, one needs to alter the transaction returned from encode. The example below shows how to build a transaction with an inputs script OP_3.","A Bitcoin Script could be used to allow more than three users to post to a chat. The idea is to use a Taproot script that has one spending path for each user. Taproot scripts have a large number of spending paths, so a large number of users could be supported. When this kind of Taproot chat is updated, only the spending path for the posting user needs to be revealed, meaning that the cost to post is constant and independent of the number of users in the chat."]},{"l":"Mocking","p":["It is sometimes necessary to build a Bitcoin Computer transaction that spends an output of a transaction that has not been broadcast to the blockchain. One example is using smart contracts over payment channels or networks. Another example is selling an object to an unknown buyer: in this case the object to be used for the payment is not known when the seller builds the transaction (see for example here).","To facilitate such application the Bitcoin Computer has a feature called Mocking. \"Mocked\" objects can be passed into the encode function. In this case, when a transaction is build the Bitcoin Computer protocol assumes that an object with that value exists at the specified revision. To create a mock you can just instantiate an object that extends from Mock.","To use a mock, pass it into the mocks property of the encode function. When the object being mocked up becomes available on the blockchain, the mocked transaction can be modified to point to the actual object."]},{"l":"Building the Chat Platform","p":["We now sketch how a chat platform could be built where moderators can create a community and then sell it over the internet.","Every community would be represented through multiple on-chain objects that are similar to the Chat object. Each of these objects contains a constant-size chunk of messages. When the current chunk object is full, a new object that would refer to the previous chunk would be created. When a user joins a chat the app would sync to the latest chunk. If the user scrolls up to the first message of the chunk, the user could click a button to load the previous chunk of messages.","In order to support an unlimited number of users, the technique sketched at the end of this section could be used. However the kinds of scripts described there would have a 1-of-n ownership structure which could lead to abuse (for example, any member of the chat could destroy the current chunk object). This could be mitigated by maintaining an additional \"moderators\" object for every community. Moderators could spin up a new chunk in the case of abuse and have other privileges like kicking out users and deleting messages from the UI. The moderatos object could have an n-of-m ownership structure. To sell a community one could sell the moderators object. This can be accomplished by using the technique described here.","Many more details need to be figured out (for example how to implement a \"moderator object\" and how to prevent abuse). If you want to build such an app please reach out, we would be delighted to try to help you."]}],[{"l":"How it Works","p":["The Bitcoin Computer protocol associates JavaScript values with the outputs of Bitcoin transactions that contain JavaScript expressions."]},{"l":"Storing Values","p":["To compute the value associated with an output, the expression is first evaluated. If the expression evaluates to a basic type, this value is associated with the first output. If the value is nested and contains multiple sub-objects, each sub-object is associated with a separate output.","This simple mechanism makes it possible to store arbitrarily complex Javascript values in the outputs of a transaction using an highly efficient encoding: Instead of storing a value, an expression is stored that computes the value. This is much more efficient. In fact, it makes it possible to store a value at its optimal compression (see the Kologromov Complexity)."]},{"l":"Example","p":["Consider a transaction that contains the JavasScript expression '0'.repeat(100000). In this case the first output of the transaction is associated with a string of 100,000 zeroes.","Note that this encodes a 100,000 character string in just 18 characters"]},{"l":"Updating Values","p":["Expressions can contain undefined variables. For example, the variable x is undefined in the expression x+4. It is not possible to evaluate an expression with an undefined variable. For example, an Javascript interpreter will throw a ReferenceError when trying to evaluate x+4.","In the Bitcoin Computer protocol, expressions with undefined variables are used to encode data updates. To determine a value for the undefined variables, the undefined variables in an expression must be associated with inputs of the transaction. The protocol will then compute the values associated with the outputs spent. These values are the substituted (aka plugged into) the respective undefined variables. This yields an expression where all variables are defined that can be evaluated. The value returned from this evaluation is associated with the outputs as explained in the previous section."]},{"i":"example-1","l":"Example","p":["Consider the transactions on the left. The first is labelled with 1+2. This expression contains no undefined variables and evaluates to 3, therefore the output of the first transaction is associated with the value 3.","The expression x+4 on the second transaction contains the undefined variable x. The input of this transaction is associated with this undefined variable. To compute the value associated with the output of the second transaction, the Bitcoin Computer protocol first computed the value of the output spent, which is 3. This value is then substituted for x in the expression x+4. This yields the expression 3+4 which evaluates to 7. This is the value associated with the output of the second transaction."]},{"l":"The Interface","p":["We call a string of the form id:num where id is a transaction if and num is an output number a revision. The following two functions provide access to the protocol through two main functions:","sync maps a revision to a value.","encode maps an expression and a blockchain environment to a transaction."]},{"l":"Provenance","p":["If the value returned from sync contains an object, it has extra properties _id, _rev, _root that specify its location on the blockchain and its provenance.","The identity of an object, denoted obj._id, is a unique identifier that remains unchanged throughout the object's lifecycle. It is set to the transaction and output that the object was associated to when it was first created.","The revision of an object, denoted obj._rev, encodes an object's current location on the blockchain.","The root of an object, denoted obj._root, records whether obj was created in a function call of another object, and if so which object that was."]},{"l":"Keyword Properties","p":["Smart contracts can contain the keyword properties _owners, _amount, _url and _readers that determine how the transaction is built. Specifically","The _owners property of a smart object determines the output script of the output that is associated with it. If it is set to an array of strings that encode public keys, then the output script will be a 1-of-n multisig script with these public keys. If it is set to a string that encodes a Bitcoin Script ASM, then that will be the script of the output.","The _amount property can be set to a number and determined the amount of satoshi of the output associated with a smart object. If this property is undefined the output will contain a minimal, non-dust amount of satoshis.","The _url property can be set to the url of a Bitcoin Computer node. If set the metadata that would otherwise be stored in the transaction is stored on that node. The metadata will consist only of a url where the data can be obtained.","The _readers property can be set to encrypt the meta data. It can be set to an array of strings encoding public keys. In this case the metadata on the transaction will be encrypted such that only the specified users can decrypt the data and read the object."]}],[{"l":"Smart Contract Language","p":["Writing smart contracts is all about imposing constraints of future values. These constraints can be local or global. An example of a local constraint is a non-fungible token: These are objects that can change their owners but the data itself typically cannot be changed. A non-fungible token is an example of a class with a non-local constraint: the number of tokens must remain constant across all objects emerging from the same mint.","In order to make it possible to write smart contracts in Javascript, the Bitcoin Computer library exports a class Contract that enforces that whenever a class extends from it, its properties can only be assigned through function calls. This is reminiscent to the behavior of Solidity and makes it possible to write smart contracts in Javascript.","We call an expression a smart contract if it returns a value that contains only sub-objects whose classes that extend from Contract. The function encode throws an error if it called with an expression that is not a smart contract. Likewise, the function sync throws an error if it is called with a transaction whose expression is not a smart contract.","To describe the behavior of Contract more precisely, let obj be an object of a class that extends from Contract. Then an error is thrown if either","a property of obj is assigned outside of a method of obj,","a property _id, _rev, and _root is assigned, or","this is assigned to in the constructor of C.","To initialize objects without violating rule 3. an initialization object can be passed into super in a constructor:","This has the same effect as assigning to this in a normal Javascript program"]}],[{"l":"Transaction Format","p":["Coming soon."]}],[{"l":"Development","p":["Coming soon."]}],[{"l":"Apps","p":["The following are examples of open source applications builded with the Bitcoin Computer. They are all published under MIT licence so you can clone, copy, modify, contribute or use them as a starting point for you project."]},{"l":"Wallet","p":["Non custodial, open source wallet for Bitcoin and Litecoin. You can send cryptocurrency to a friend and see your balance, and the transactions sent and received.","wallet.bitcoincomputer.io"]},{"l":"Explorer","p":["Bitcoin Computer Explorer. You can explore all objects created, or log in to update your smart objects using the UI. Use the playground to create any smart contract you can imagine!","explorer.bitcoincomputer.io"]},{"l":"Non Fungible Token","p":["You can mint an NFT and trustless list it for sale. You also can see your own NFTs or buy any NFT listed.","nft.bitcoincomputer.io"]}],[{"l":"Examples","p":["Method","Description","Non Fungible Token (NFT)","A non fungible token similar to ERC721","Fungible Token","A fungible token similar to ERC20","Encrypted Chat","An encrypted chat","Swap","Trustlessly exchange two smart object","Sale","Trustlessly sell a smart object to an unknown buyer","Ordinal Sale","Trustlessly sell an ordinal to an unknown buyer"]}],[{"l":"Non Fungible Token"},{"l":"Smart Contract","p":["A smart contract for an NFT is a class with two properties and one function to update the _owners property."]},{"l":"Usage","p":["To create an on-chain object of class NFT, you can use the new function of the Computer class. The faucet function funds the sender object on regtest. The sender.new function mints a new NFT and the transfer function send the NFT to another user.","The transaction that is broadcast when sender.new is called contains the expression below."]},{"l":"The Module System","p":["If many NFTs are created, it is wasteful to store the same Javascript class in the blockchain multiple times. In this case, it is possible to use the module system to store the smart contract one time and refer to it multiple times.","In this case, each transaction encoding the minting of an NFT contains the module specifier (a transaction id and an output number) and the following expression."]},{"l":"Code","p":["You can find a slightly more elaborate implementation here."]}],[{"l":"Fungible Token"},{"l":"Smart Contract","p":["A fungible token is stored and transferred in a similar way to how satoshis are stored and transferred in Bitcoin. Its current state is stored in a set of UTXOs. When tokens are transferred a utxo is spent and two new UTXOs are created: one containing the amount sent and one containing the change.","The transfer function checks if the current on-chain object contains a sufficient number of tokens and throws an error if not. If sufficient, the supply of the current on-chain object is reduced by the amount to be sent. A new on-chain object, owned by the recipient and containing the sent amount, is created and returned."]},{"l":"Usage","p":["The usage is as in the case of a non-fungible token."]},{"l":"Code","p":["You can find the code here."]}],[{"l":"Chat"},{"l":"Smart Contract","p":["The smart contract below creates a chat that can be initialized with an array of participants. All messages are encrypted so that only the members can read the messages. It is not possible to add a new participant, but any current participant can remove another participant from the chat."]},{"l":"Usage","p":["A new chat can be created using the new function. Note that Bob can initially post to the chat and read it's state as Bob's public key was added by Alice to the _owners array and to the _readers array upon creation of the chat.","Later, Alice called the remove function removing Bob's public key from these arrays. After this point Bob cannot read or write anymore."]},{"l":"Code","p":["You can find the code here."]}],[{"l":"Token Swap","p":["In this section we explain how to exchange to on-chain objects atomically. This means that either both assets change their owner or none of them.","A token swap is similar to an atomic swap, the difference being that atomic swaps usually refer to the exchange of cryptocurrency on two different chains, whereas token swaps exchange tokens on the same chain.","We note that the definition of a token swap differs wildly from the legal definition of a swap. While a token swap is the immediate exchange of two on-chain objects, a swap in the legal sense involves an option to buy or sell an asset in the future.","This code preserves ordinal ranges and is safe to use this in smart objects that contain ordinals."]},{"l":"Smart Contract","p":["You can build a swap as a static function that takes two arguments and exchanges their owners."]},{"l":"Usage"},{"l":"Minting the NFTs","p":["Alice and Bob mint NFTs using the computer.new function."]},{"l":"Building the Swap Transaction","p":["Alice can create a swap transaction as shown below. Such a transaction has two inputs and two outputs. The inputs spend the NFTs to be swapped. The outputs are the NFTs after the swap with their owners exchanged.","The encode function signs all inputs that can be signed with the private key of the object on which the function is called. In this case, this is the input that spends revision a._rev."]},{"l":"Checking the Transaction","p":["When Bob receives the transaction, he can decode it and inspect the state that would emerge on chain if he were to sign and broadcast the transaction."]},{"l":"Executing the Swap","p":["If Bob is happy with the transaction, he can execute the swap by signing and broadcasting the transaction."]},{"l":"Full Example","p":["The code snippet below shows how to create two nfts and swap them using the smart contract above."]},{"l":"Code","p":["Have a look at the code on Github for details."]}],[{"l":"Sale","p":["We explain how to sell a smart object to an unknown buyer atomically. Whereas both objects are known in advance in a swap, the output containing the payment that Buyer will use in the sale is unknown when Seller is building the swap transaction. Seller builds a partial transaction consisting of only one input for the asset and one output for the payment to be received. Buyer can later add an input for the payment and an output for the asset after the sale.","These examples use several advanced features (sighash types, mocking, and controlling the order of inputs and outputs, ordinal safe programming) that are not sufficiently documented elsewhere. If you would like to use these features we suggest to ask about their safe use here.","This code is not safe to use with ordinals. A slightly more complicated version that works for ordinals is described here."]},{"l":"Smart Contract","p":["Seller builds a partial transaction containing an input spending the asset and an output for receiving the payment. The sighash type SIGHASH_SINGLE | SIGHASH_ANYONECANPAY allows Seller to sign only the first input and output.","Buyer wants to obtain the smart object in the first input so Buyer is incentivized to build the transaction according to the protocol. If he broadcasts a transaction that is invalid in the Bitcoin Computer protocol, Buyer destroys the smart object but still pays the Seller.","We call this transaction described above the \"crossover\" transaction because the asset passes from the first input to the second output and the payment passes from the second input to the first output. In order to build it with the Bitcoin Computer, one needs to take into account that the order of inputs is determined by the order of objects in the environment and the order of outputs is determined by the order of objects in the value returned from the expression.","Seller uses an environment { nft: ..., payment: ... }, indicating that the first input will spend nft and the second input will spend payment. As the exec function returns an array [payment, nft] the first output represents the payment and the second output represent the nft. This is exactly the \"crossover\" transaction described above."]},{"l":"Usage"},{"l":"Mocking the Payment Object","p":["The challenge in creating the sales transaction arises from the fact that the output containing the payment is not yet created at the time of building the transaction. To handle such scenarios the Bitcoin Computer provides a feature called mocking. A mock is a class that has the properties _id, _rev, _root, _amount, and _owners, and sets them to strings of the form mock-transaction-id:output-number. A mock does not have to extend from Contract. Each mocked object must have a distinct transaction id and output number.","The following code shows the class to create the payment mock as well as Seller creating a new instance with the standard Javascript new keyword."]},{"l":"Building the Sales Transaction","p":["Seller can create and sign the partial sale transaction using the code below.","The expression contains the Sale class and an expression that calls the static exec function.","The next two lines contain the instructions for the mocking system. Seller can use the mock object that was created earlier as shown below. The revision of the mock is passed in as the payment revision to the environment; and an object is passed to the mocks key that maps the name payment to the mock object. If an object is mocked up, the Bitcoin Computer will build a transaction assuming that the output spent is associated with the value provided by the mock. Later buyer will update the input that spends the revision of the payment mock with the revision and output number of an actual payment.","To enable Buyer to modify Seller's transaction later, Seller signs the first input with the sighash type SIGHASH_SINGLE | SIGHASH_ANYONECANPAY. This means that Seller's signature remains valid even when arbitrary inputs and outputs are added to the transaction as long as the input and the output that Seller has signed have the same index. This guarantees that any transaction that contains the input that spends Sellers NFT will also contain the output that pays Seller. This guarantees that Seller gets paid. Intuitively speaking, the Seller is stating: \"you can spend the output containing the NFT as long as you include the output that pays me the correct amount\".","Finally, Seller set's funding to false so that Buyer covers the transaction fees.","Seller can publish the sales transaction without any risk. An interested buyer can create a payment object and complete and broadcast the sale transaction to purchase the nft. This is described in the next section."]},{"l":"Buying the NFT","p":["First, Buyer creates a smart object to pay for the nft.","Next, Buyer updates the second input of the transaction that currently points to the revision of the payment mock.","Then Buyer updates the second output to contain Buyer's public key. This ensures that Buyer will be new owner of the nft.","Finally Buyer funds, signs, and broadcasts to execute the sale."]},{"l":"Full Example","p":["The code below shows the whole process of minting an nft, listing it for sale, and a purchase. Working code can be found here"]},{"l":"Code","p":["You can find the code here."]}],[{"l":"Ordinal Sale","p":["The Sale smart contract is not safe to use with ordinals because the smart objects have different ordinal ranges before and after the call. To preserve the ordinal ranges the expression must not use the _amount keyword and must not return an object or an array containing an object.","Building a sale contract for ordinals is more complicated than for smart objects. A very clever construction was proposed here and later refined. Our smart contract below implements this exact idea.","This code preserves ordinal ranges and is safe to use this in smart objects that contain ordinals."]},{"l":"Smart Contract","p":["The exec function of the OrdSale class swaps the owners just like in the Sale class. However it then proceeds to double the amount of b1 and return [b1, t, p, b2].","When the exec function is evaluated, a transaction of the following form is built:","The amount of b1 after the call is the sum of the amounts of b1 and b2 before combined. The smart object b1 therefore absorbs the entire ordinals range of b2. The objects n and p do not change their amounts during the call, these objects preserve their ordinal ranges.","We now explain the whole process of minting an NFT, listing it for sale, and processing a purchase. We skip the step for minting as it was described above."]},{"l":"Usage"},{"l":"Building the Sales Transaction","p":["In order to build the sale transaction, Seller first needs to create the objects b1, b2, and p:","Next Seller can build the sales transaction by executing the following code:","Conceptually this is very similar to the use of encode above. Note however, that Seller signs the third input output pair this time. This is because the NFT is spent by the third input and the payment that Seller wants to obtain is in the third output."]},{"l":"Buying the Ordinal NFT","p":["This process is similar to the case of a smart object sale above. See the example blow."]},{"l":"Full Example"},{"l":"Code","p":["You can find the code here."]}],[{"l":"Lib","p":["The Bitcoin Computer Library (available on Github and Npm) provides all the functionality needed to write smart contracts with the Bitcoin Computer.","To interface with the blockchain, the Bitcoin Computer Lib connects to a Bitcoin Computer node. By default the Bitcoin Computer Lib connects to a node in regtest node that we provide. You can find more information about configuration options in the section constructor."]},{"l":"Api"},{"l":"Basic","p":["You can build almost all smart contracts with following methods.","Method","Description","constructor","Creates an instance of class Computer","new","Creates a smart object from a smart contract","query","Finds the latest revisions of smart object","sync","Computes the state of a smart object from a given revision"]},{"l":"Advanced","p":["To build advanced applications like swaps have a look at the following.","Method","Description","encode","Encodes a Javascript expression into a Bitcoin transaction","encodeNew","Encodes a constructor call into a Bitcoin transaction","encodeCall","Encodes a function call into a Bitcoin transaction","decode","Parses a Bitcoin transaction and returns Javascript expression","faucet","Fund a computer object on Regtest"]},{"l":"Modules","p":["You can save transaction fees by using our ES6 module system.","Method","Description","deploy","Deploys an ES6 module on the blockchain","load","Loads an ES6 module from the blockchain"]},{"l":"Wallet","p":["Access Bitcoin's RPC interface","broadcast","Broadcasts a Bitcoin transaction","Confirmed, unconfirmed and total balance in sats","Description","getAddress","getBalance","getChain","getMnemonic","getNetwork","getPassphrase","getPrivateKey","getPublicKey","getUtxos","Method","Returns a BIP39 mnemonic sentence","Returns an array of unspent transaction outputs","Returns the Bitcoin address of the computer wallet","Returns the blockchain","Returns the network","Returns the passphrase","Returns the private key","Returns the public key","rpcCall","send","Sends satoshis to an address","sign","Signs a Bitcoin transaction","The wallet functionality within a Computer instance can be accessed using the following."]}],[{"l":"broadcast","p":["The broadcast function broadcasts a Bitcoin transaction to the Bitcoin mining network."]},{"l":"Type"},{"l":"Syntax"},{"l":"Parameters","p":["Parameter","Description","tx","A Bitcoin transaction object."]},{"l":"Return value","p":["If broadcast is successful, it returns an string encoding the transaction id. Otherwise, an error is thrown."]},{"l":"Examples"}],[{"l":"constructor","p":["The constructor of the Computer class creates an instance. It's functionality is described in this API documentation."]},{"l":"Type"},{"l":"Syntax"},{"l":"Parameters"},{"l":"config","p":["2","30000 on LTC and 3000 on BTC","A configuration object","addressType","BIP32 passphrase","BIP32 path","BIP39 mnemonic phrase","chain","Default Value","Description","Dust relay fee","dustRelayFee","Fee in satoshi per byte","https://rltc.node.bitcoincomputer.io","Key","LTC","m/44'/0'/0'","mnemonic","moduleStorageType","network","p2pkh","passphrase","path","Random phrase","regtest","satPerByte","Store ES6 modules on Taproot or multisig scripts","taproot","Target blockchain. Values can be 'LTC' or 'BTC'","Target network. Values in 'testnet', 'regtest' or 'mainnet'","The address script type. Values in 'p2pkh', 'p2wpkh', 'p2tr'","The empty string","url","Url of a Bitcoin Computer Node"]},{"l":"Return Value","p":["An instance of the Computer class"]},{"l":"Examples"}],[{"l":"decode","p":["The decode function parses a Bitcoin transaction to determine if it is a Bitcoin Computer transaction. If so it returns an expression exp, a blockchain environment env, and a module specifier mod. The function decode is the inverse of encode when the latter is called with exp, env, and mod."]},{"l":"Type"},{"l":"Syntax"},{"l":"Parameters","p":["Parameter","Description","tx","A Bitcoin transaction object."]},{"l":"Return value","p":["It returns a Bitcoin transaction and an object of type Effect.","The object of type Effect captures the changes induced by evaluating the expression: It contains the result of the evaluation (property res) and the side effects of the evaluation (property env). The object of type Effect can be used to determine if the evaluation had the desired effect. If it did, the transaction can be broadcast to commit the update to the blockchain. If the transaction is not broadcast, the state on the blockchain does not change. The transaction can be broadcast at an arbitrarily long delay after calling encode. If during the time between calling encode and broadcasting the transaction the blockchain undergoes any updates that could affect the evaluation, the miners will reject the transaction. However, if the transaction is accepted by the miners, it is guaranteed to have the effect indicated by object of type Effect.","If fund is required, and the wallet has insufficient funds, an error is thrown. If sign is required, the default behavior is to sign all inputs. The encode function will make a best effort to sign all inputs, but will not throw any error if the signature cannot be added due to hash mismatch. This is useful in the case of partially signed transactions, where a user can encode an expression, sign with the user private key and send the generated partially signed transaction to another user. Then, the receiver can sign the remaining inputs."]},{"l":"Examples"}],[{"l":"deploy","p":["The deploy function stores an ES6 module on the blockchain and returns an identifier for that module. This identifier can be passed into the functions computer.new, computer.encode, computer.encodeNew, and computer.encodeCall to make the exports of the module available there.","The advantage of deploying your code is that it can save transaction fees: A large piece of code can be deployed once and then used to create or update many smart objects.","Please note that modules are not encrypted, even if objects that use them have the _readers property set.","There are two different modes to store a module on the blockchain: taproot or multisig mode. The default mode is taproot. The mode can be changed by passing the option moduleStorageType into the constructor of the Computer class. In Taproot mode, the module is stored in a Taproot script. This is cheeper and it enables you to store larger Javascript programs in a module. The multisig mode stores the module in multisig scripts. This is more expensive but compatible with chains that do not support Taproot."]},{"l":"Type"},{"l":"Syntax"},{"l":"Parameters","p":["Parameter","Description","module","A string encoding an ES6 module."]},{"l":"Return value","p":["A string encoding the location where the module is stored. The format is <transaction id>:<output number>."]},{"l":"Examples","p":["Previously this function was called export but this name is deprecated since version 0.16.0."]}],[{"l":"encode","p":["The encode function builds a Bitcoin transaction from a Javascript expression according to the Bitcoin Computer protocol. In addition to the transaction, this function also returns the value of the expression.","If the expression contains free variables (for example the variable x in the expression x.f()) a \"blockchain environment\" must be passed. A blockchain environment is a JSON object that maps variable names to the latest revisions of smart objects.","A module specifier can be provided in order to make the exports of that module are available to the evaluation.","Other options can customize the funding and signing process.","The state update effected by a Bitcoin Computer transaction is completely predictable:","If the transaction is included in a block the new state will be exactly the state returned from the effect function.","If the transaction is not included the state is not updated."]},{"l":"Type"},{"l":"Syntax"},{"l":"Parameters"},{"l":"opts","p":["[]","{}","1=SIGHASH_ALL","A Blockchain environment, maps free variables to latest revisions","A Javascript expression","A module specifier","A pair <name, object>. The object is an instance of a mocked class (A class that does not extends from Contract but has the keywords _id, _root, _amount,_owners)","An object with the basic configuration parameters to encode the expression in a transaction.","boolean","Default Value","Description","env","exclude","exp","fund","If set to a string a custom input script can be provided. If undefined a signature script is generated","If set to an number the corresponding input is signed. If undefined all inputs are signed.","include","inputIndex","inputScript","Key","mocks","mod","Module specifiers and UTXOs are encoded as strings of the form <transaction id>:<output number>","number","Record<string, any>","Record<string, string>","sighashType","sign","string","string[]","The sighash type","true","Type","undefined","UTXOs to exclude when funding","UTXOs to include when funding","Whether the transaction should be funded","Whether to sign the transaction"]},{"l":"Return value","p":["It returns an object { tx, effect } where tx is a Bitcoin transaction and effect is an object with keys res and env.","The transaction tx is an object from the NakamotoJS library - a BitcoinJS clone that supports LTC, BTC, PEPE and DOGE, and has some extra features that make is easier to build advanced applications like exchanges.","The res object contains the result of the evaluation.","The env object has the same keys as the blockchain environment. However, whereas the values of the blockchain environment are revision strings, the values of env and the smart object at these revisions after evaluating the expression."]},{"l":"Examples"}],[{"l":"encodeCall","p":["Encodes a function call. This function is syntactic sugar for encode."]},{"l":"Type"},{"l":"Syntax"},{"l":"Parameters"},{"l":"params","p":["A module specifier","An object with the configuration parameters to encode the expression in a transaction.","args","Description","InstanceType<T>","Key","mod","Module specifiers are encoded as strings of the form <transaction id>:<output number>","Parameters<InstanceType<T>[K]>","property","string","target","The arguments to the function call","The name of the function being called","The smart object on which to call the function","Type"]},{"l":"Return value","p":["It returns an object { tx, effect } where tx is a Bitcoin transaction and effect is an object with keys res and env. For more details see the description of the return type of encode."]},{"l":"Examples"}],[{"l":"encodeNew","p":["Encodes a constructor call. This function is syntactic sugar for encode."]},{"l":"Type"},{"l":"Syntax"},{"l":"Parameters"},{"l":"params","p":["An object with the configuration parameters to encode the expression in a transaction.","Key","Type","Description","constructor","T extends new (...args: any) => any","A Javascript class that extends from Contract","args","ConstructorParameters<T>","Arguments to the constructor of the class","mod","string","A module specifier","Module specifiers are encoded as strings of the form <transaction id>:<output number>"]},{"l":"Return value","p":["It returns an object { tx, effect } where tx is a Bitcoin transaction and effect is an object with keys res and env. For more details see the description of the return type of encode."]},{"l":"Examples"}],[{"l":"faucet","p":["The faucet function funds a computer object. It is only available when the computer object is connected to a node in regtest mode. The faucet function creates a utxo to fund the address. The utxo is created with the amount of satoshis specified in the first parameter. The address to be funded can be specified in the second parameter. If the address is not specified, the address of the computer object is used. The transaction is broadcasted to the network, and a block is mined immediately to confirm the transaction."]},{"l":"Type"},{"l":"Syntax"},{"l":"Parameters","p":["Parameter","Description","amount","An amount of Satoshi","address","An string encoded address to be funded"]},{"l":"Return value","p":["The utxo created to fund the address."]},{"l":"Examples"}],[{"l":"fund","p":["Funds a Bitcoin transaction."]},{"l":"Type"},{"l":"Syntax"},{"l":"Parameters","p":["Parameter","Description","tx","A Bitcoin transaction object."]},{"l":"opts","p":["An optional object can be passed as parameter to include or exclude certain UTXOs. When using include, the transaction will be funded with the UTXOs specified as the first inputs.","Key","Type","Description","Default Value","include","string[]","UTXOs to include","[]","exclude","UTXOs to exclude"]},{"l":"Return value","p":["If the wallet does not have sufficient funds, an error is thrown."]},{"l":"Examples"}],[{"l":"getAddress","p":["Returns a string encoding Bitcoin address. Will return an address according to the type set in the Computer constructor."]},{"l":"Type"},{"l":"Syntax"},{"l":"Return value","p":["Returns a string encoded Bitcoin address."]}],[{"l":"getBalance","p":["Returns an object with the current balance in Satoshi, the confirmed balance in Satoshi (at least 1 confirmation), and the unconfirmed balance in Satoshi."]},{"l":"Type"},{"l":"Syntax"},{"l":"Return value","p":["Returns the current balance in Satoshi."]}],[{"l":"getChain","p":["Returns the chain."]},{"l":"Type"},{"l":"Syntax"},{"l":"Return value","p":["Returns a string encoding the chain."]}],[{"l":"getMnemonic","p":["Returns a string encoding a BIP39 mnemonic sentence."]},{"l":"Type"},{"l":"Syntax"},{"l":"Return value","p":["The mnemonic."]}],[{"l":"getNetwork","p":["Returns the network."]},{"l":"Type"},{"l":"Syntax"},{"l":"Return value","p":["Returns a string encoding the network."]}],[{"l":"getPassphrase","p":["Returns the BIP39 passphrase."]},{"l":"Type"},{"l":"Syntax"},{"l":"Return value","p":["Returns the BIP39 passphrase."]}],[{"l":"getPrivateKey","p":["Returns a string encoded private key."]},{"l":"Type"},{"l":"Syntax"},{"l":"Return value","p":["Returns a string encoded private key."]}],[{"l":"getPublicKey","p":["Returns a string encoding a public key."]},{"l":"Type"},{"l":"Syntax"},{"l":"Return value","p":["Returns a string encoding a public key."]}],[{"l":"getUtxos","p":["Returns an array of unspent transaction outputs (UTXOs). Each UTXO is encoded as a string of the form <transaction id>:<output number>"]},{"l":"Syntax"},{"l":"Type"},{"l":"Return value","p":["Returns an array of unspent transaction outputs (UTXOs)."]}],[{"l":"load","p":["Imports a ES6 module from a module specifier encoded as a string <transaction id>:<output number>."]},{"l":"Type"},{"l":"Syntax"},{"l":"Parameters","p":["Parameter","Description","rev","A string encoding a module specifier."]},{"l":"Return value","p":["A ES6 module."]},{"l":"Examples"}],[{"l":"new","p":["Creates a new smart object. The parameters are a smart contract (a Javascript class inheriting from Contract), a list of arguments for the constructor of the class and an optional module specifier. The arguments of the constructor can be of basic data type or smart objects. The new function builds a transaction that records the creation of a new smart object, signs it and broadcasts it. Smart objects can be updated by calling their functions, see here."]},{"l":"Type","p":["Here a MetaData is the type"]},{"l":"Syntax"},{"l":"Parameters","p":["Parameter","Description","constructor","A named Javascript class that extends from Contract.","args","Arguments to the constructor of the class.","mod","A module specifier, i.e., the revision string of a deployed module (see deploy)."]},{"l":"Return value","p":["Returns an instance of the class T. The class T should extend from Contract. The returned object has extra properties _id, _rev, _root, _owners, _amount and possibly _url, _readers."]},{"l":"Examples"}],[{"l":"next","p":["Documentation coming soon."]}],[{"l":"prev","p":["Documentation coming soon."]}],[{"l":"query","p":["Returns the latest revisions of smart objects. Conditions can be passed in to determine the smart objects. When multiple conditions are passed in, the latest revisions of the smart objects that satisfy all conditions are returned."]},{"l":"Type"},{"l":"Syntax"},{"l":"Parameters"},{"l":"params","p":["'ASC' | 'DEC'","An object with the query parameters.","Description","ids","Key","limit","mod","number","offset","order","Order results in ascending or descending order","publicKey","Return latest revision of smart objects with ids in order","Return latest revisions of smart objects owned by a public key","Return only limited number of revisions","Return results starting from offset","Return the latest revision of smart objects created with this module specifier","string","string[]","Type"]},{"l":"Return value","p":["Given the query parameters, returns an array of strings encoding the latest revisions of smart objects that matches the specified conditions."]},{"l":"Examples"}],[{"l":"rpcCall","p":["Calls a Bitcoin RPC method with the given parameters."]},{"l":"Type"},{"l":"Syntax"},{"l":"Parameters","p":["Parameter","Description","method","An string encoding the name of the rpc function to be called.","params","An string with the argument list of the rpc function call to be called, separated by spaces."]},{"l":"Return value","p":["A JSON object with the result of the rpc method call."]},{"l":"Examples"}],[{"l":"send","p":["Sends a payment."]},{"l":"Type"},{"l":"Syntax"},{"l":"Parameters","p":["Parameter","Description","amount","A number representing the amount of satoshis to be sent.","address","An string encoding the receiver address."]},{"l":"Return value","p":["If successful, it returns the id of the transaction broadcast."]},{"l":"Examples"}],[{"l":"sign","p":["Signs a Bitcoin transaction. Options can be passed in that determine which inputs to sign, the sigHash type to use, and which script to use."]},{"l":"Type"},{"l":"Syntax"},{"l":"Parameters","p":["A Bitcoin transaction, possibly partially signed.","A buffer encoding the signature","A valid sighash type number","An object with specific parameters to use when signing.","Buffer","Description","inputIndex","inputScript","Key","number","opts","Parameter","sighashType","The input index to be signed","The opts object can have the following properties:","tx","Type"]},{"l":"Return value","p":["By default, the sign function will make a best effort to sign all inputs, but will not throw an error if the signature cannot be added due to hash mismatch.","This is useful in the case of partially signed transactions, where a user can encode an expression, sign with the user private key and send the generated partially signed transaction to another user. Then, the receiver can sign other inputs."]},{"l":"Examples"}],[{"l":"sync","p":["Returns smart objects given a location on the blockchain. The location can either be a revision (a string of the for <transaction id>:<output number>) or a transaction id."]},{"l":"Type"},{"l":"Syntax"},{"l":"Parameters","p":["Parameter","Description","location","An string encoding a revision or a transaction id."]},{"l":"Return value","p":["If the function is called with a revision, it returns the smart object stored at the provided revision. Note that the revision must not be a latest revision. In that case a historical state of the revision is returned.","If the function is called with a transaction id, it returns an object of type { res: Json; env: Json }. The value of res is the result of evaluating the expression inscribed into the transaction. The env object has the same keys as the blockchain environment of the transaction, the values of env are the smart objects at these revisions after evaluating the expression.","If the parameter is not a valid revision or transaction id, an error is thrown."]},{"l":"Examples"},{"l":"Sync to a Revision","p":["Synchronizing to the revision returns a smart object."]},{"l":"Sync to a transaction id","p":["Synchronizing to a transaction id returns all smart objects on that transaction."]}],[{"l":"Node"},{"l":"Prerequisites","p":["You need to have git, node.js and docker installed."]},{"l":"Installation"},{"l":"Usage"},{"l":"Start the Node","p":["To start your node at http://localhost:1031 run the commands below. The node is ready once the log activity subsides. On regtest this will take a few minutes, on mainnet and testnet it can take days or even weeks, depending on your hardware.","The node will create the docker volumes in the packages/node/chain-setup/** directory of the selected chain and network. This folder contains the blockchain data and the database. The postgres database is used to efficiently store the complete blockchain data, for fast access and indexing."]},{"l":"Run the Tests","p":["You can run the integration tests with the command below.","On Litecoin regtest, the halving period is set to infinity. This makes it possible to run a large number of tests without having to restart the node."]},{"l":"Fund the Wallet","p":["In regtest mode, you can fund a wallet with the following commands."]},{"l":"Stop the Node","p":["You can stop the node with the command below. When you restart the process, it will resume from the last block processed."]},{"l":"Reset the Node","p":["The command below will reset the database, delete all blockchain data, and stop all docker containers."]},{"l":"Configuration","p":["You can configure several options by editing the .env file."]},{"l":"Client Side Library","p":["The Bitcoin Computer Library can connect to a Bitcoin Computer Node to provides access to its functionality.","If you do not specify a url property it will default to the url below. The node at that url runs Litecoin on regtest network mode and uses the latest version of the Bitcoin Computer Node software."]},{"l":"Api","p":["The Bitcoin Computer Node exposes an API that can be used to interact with the node. The variables CHAIN and NETWORK are used to define the chain and network that the node is running on."]},{"l":"Wallet","p":["Method","Description","balance","Get the balance of a wallet.","list-txs","List sent and received transactions for a given address.","sent-outputs","List sent outputs of a wallet.","received-outputs","List received outputs of a wallet.","utxos","List unspent outputs of a wallet."]},{"l":"Transactions","p":["Method","Description","ancestors","Get the ancestors of a transaction.","bulk","Get raw transactions for a list of transaction ids.","json","Get a transaction in json format.","post","Post a transaction to the Bitcoin network."]},{"l":"Blockchain","p":["Method","Description","height","Get the height of an specific block.","mine","Mine an specific number of blocks to a random address.","rpc","Call a Bitcoin RPC method."]},{"l":"Regtest Faucet","p":["Method","Description","faucet","Get coins from the faucet.","faucetScript","Get coins from the faucet using a script."]},{"l":"Query revisions","p":["Method","Description","next","Get the next revision of a given revision.","prev","Get the previous revision of a given revision.","non-standard-utxos","Query revisions by module specifier, public key, limit, order, offset and list of transaction ids.","revs","Get the revisions of a list of transactions.","revToId","Given a revision, get the id of the smart contract."]},{"l":"OffChain","p":["Method","Description","id","Get the data stored in the offchain storage.","store","Stores the hex of the data in the offchain storage."]},{"l":"Versioning","p":["If you run your own node, make sure to use the same versions of Lib and Node."]}],[{"l":"rpc"},{"i":"v1chainnetworkrpc","l":"/v1/CHAIN/NETWORK/rpc","p":["Call a Bitcoin RPC method."]}],[{"l":"id"},{"i":"v1storeid","l":"/v1/store/:id","p":["Get the data stored in the offchain storage."]}],[{"l":"store"},{"i":"v1store","l":"/v1/store","p":["Stores the hex of the data in the offchain storage."]}],[{"l":"next"},{"i":"v1chainnetworknextrev","l":"/v1/CHAIN/NETWORK/next/:rev","p":["Get the next revision of a given revision."]}],[{"l":"non-standard-utxos"},{"i":"v1chainnetworknon-standard-utxos","l":"/v1/CHAIN/NETWORK/non-standard-utxos","p":["Query revisions by module specifier, public key, limit, order, offset and list of transaction ids."]}],[{"l":"prev"},{"i":"v1chainnetworkprevrev","l":"/v1/CHAIN/NETWORK/prev/:rev","p":["Get the previous revision of a given revision."]}],[{"l":"revs"},{"i":"v1chainnetworkrevs","l":"/v1/CHAIN/NETWORK/revs","p":["Get the revisions of a list of transactions."]}],[{"l":"revToId"},{"i":"v1chainnetworkrevrevtoid","l":"/v1/CHAIN/NETWORK/rev/:revToId","p":["Given a revision, returns the id of the smart contract."]}],[{"l":"faucet"},{"i":"v1chainnetworkfaucet","l":"/v1/CHAIN/NETWORK/faucet","p":["Send coins to an address."]}],[{"l":"faucetScript"},{"i":"v1chainnetworkfaucetscript","l":"v1/CHAIN/NETWORK/faucetScript","p":["Send coins to a script."]}],[{"l":"ancestors"},{"i":"v1chainnetworktxtxidancestors","l":"/v1/CHAIN/NETWORK/tx/:txId/ancestors","p":["Returns an array with the transaction IDs of the ancestors of a given transaction. An ancestor is a transaction that is an input to the given transaction."]}],[{"l":"bulk"},{"i":"v1chainnetworktxbulk","l":"/v1/CHAIN/NETWORK/tx/bulk","p":["Returns the raw transaction hexes for a given list of transaction IDs."]}],[{"l":"json"},{"i":"v1chainnetworktxtxidjson","l":"/v1/CHAIN/NETWORK/tx/:txId/json","p":["Returns the JSON representation of a given transaction."]}],[{"l":"post"},{"i":"v1chainnetworktxpost","l":"/v1/CHAIN/NETWORK/tx/post","p":["Posts a raw transaction to the network and returns its transaction ID."]}],[{"l":"balance"},{"i":"v1chainnetworkaddressaddressbalance","l":"/v1/CHAIN/NETWORK/address/:address/balance","p":["Returns the confirmed, unconfirmed and total balance for a given address."]}],[{"l":"list-txs"},{"i":"v1chainnetworkwalletaddresslist-txs","l":"/v1/CHAIN/NETWORK/wallet/:address/list-txs","p":["Returns the sent and received transactions for a given address."]}],[{"l":"received-outputs"},{"i":"v1chainnetworkwalletaddressreceived-outputs","l":"/v1/CHAIN/NETWORK/wallet/:address/received-outputs","p":["Returns the outputs that were received by a given address."]}],[{"l":"sent-outputs"},{"i":"v1chainnetworkwalletaddresssent-outputs","l":"/v1/CHAIN/NETWORK/wallet/:address/sent-outputs","p":["Returns the outputs that were sent from a given address."]}],[{"l":"utxos"},{"i":"v1chainnetworkwalletaddressutxos","l":"/v1/CHAIN/NETWORK/wallet/:address/utxos","p":["Returns the UTXOs for a given address."]}],[{"l":"Comparison","p":["We explain how smart contract systems for Bitcoin work in simple terms. We then compare the Bitcoin Computer to other systems according to the following properties:","Trustlessness. We call a system trustless if no trusted third party is required for its operation. Trustlessness is the main point of the entire crypto endeavour as Satoshi pointed out in the second sentence of the Bitcoin white paper: \"the main benefits are lost if a trusted third party is still required\".","Expressiveness. A system is expressive if it can express all computable smart contracts, formally if it is Turing Complete. Assets created in such general purpose protocols can be freely composed and moved between applications.","Efficiency. A system is efficient if it is possible to compute some smart contract data without having to parse all transactions in the blockchain. This is important for two reasons: the obvious one is that it is faster to compute some values. The other is that it is possible to compute values in parallel.","This writeup is based on a presentation we gave at the Litecoin Summit in 2024. You can find the slides here and a video recording here."]},{"l":"Results","p":["-","Bitcoin","Bitcoin Computer","Channels","Efficient","Ethereum","Expressive","Interoperable","No","Order based","Rollup","Sidechain","The table below captures the results of our comparison. Each result is explained in detail in the following sections.","Trustless","UTXO based","Yes"]},{"l":"Blockchains","p":["For context we briefly discuss to what extent Bitcoin and Ethereum have the three properties we are interested in."]},{"l":"Bitcoin","p":["Bitcoin is a trustless peer-to-peer currency. We will assume familiarity with the basic working of Bitcoin and focus on the three properties from above.","Bitcoin is assumed to be trustless as long as a majority of the hash power is honest. However it is not expressive as it only supports one application: a currency. It is also not efficient as one needs to validate all transactions and check the proof of work of every block in order to determine if the amount in an output is unspent and the transaction containing the output is valid."]},{"l":"Ethereum","p":["Ethereum is the first blockchain to popularize general purpose smart contracts. It assumed to be trustless as longs as a majority of the staked cryptocurrency is owned by honest validators. In addition it is expressive due to its native smart contract support. However, it is not efficient: to determine the storage of one address, a full node needs to synchronize with the entire blockchain, validating all transactions and computing all smart contract invocations."]},{"l":"State Channels and Networks","p":["State channels, originally designed to reduce fees, have recently found applications in smart contract systems. They allow two parties to conduct transactions off-chain with only the final agreed-upon state recorded on the blockchain. Two parties can send payments back and forth an unlimited number of times at a constant cost. However the fee reduction is less pronounced for unidirectional payments.","While state channels work well between two users, they do not scale to a large number of users, because creating channels between all users quickly becomes uneconomical. To address this shortcoming, channel networks have been developed. These use smart contracts called Hashed-Timelock-Contracts (HTLCs) to create chains of channels that securely forward payments, ensuring that intermediate nodes cannot steal funds. This enables efficient hub-and-spoke architectures where a central hub forwards payments between users. One downside is the existence of a central point of failure in the form of the hub; another is that users need to be online to receive payments securely."]},{"l":"Examples","p":["The Lightning Network extends the hub-and-spoke model to a decentralized network of payment channels. The key challenge is to solve the routing problem: to send a payment between two users, a path of channels must be determined where each channel has sufficient liquidity to forward the payment. To determine such a path, users must have up to date knowledge of the balances of all channels. If a user's knowledge of channel balances is outdated, the payment can fail.","Watchtowers allow users to accept payments whilst offline. These are third party services that monitor end users' channels for suspicious activity and react accordingly. The downside is that this introduces a trusted third party. More info","The ARK protocol is a layer-two solution designed for off-chain Bitcoin transactions, aiming to provide a low-cost, setup-free payment system. ARK relies on trusted intermediaries called ARK Service Providers (ASPs) to manage shared UTXOs. In ARK, transactions are conducted using virtual UTXOs (VTXOs), which are off-chain transaction outputs that can be converted into on-chain UTXOs when needed. Payments within ARK are coordinated by the ASPs through periodic \"rounds,\" where users exchange their VTXOs for new ones off-chain. Additionally, ARK offers \"out-of-round\" payments for faster, direct transactions between parties. More info","The RGB protocol enables smart contracts. All meta data is stored offline, which lowers availability guarantees. RGB uses transaction outputs as \"single-use seals\" that ensure that only the owner can modify the contract state. RGB uses specially-designed virtual machine called AluVM, which is is nearly computationally universal, but with a bounded by number of operation steps, similar to in Ethereum-like systems. RGB has support for for enhanced privacy via a modified form of confidential transactions. RGB can operate over regular Bitcoin transactions and over the lightning network. More info","The Bitcoin Computer currently does not support channels networks. However we mention it here as an integration could be built in principal. The Bitcoin Computer will be further discussed here."]},{"l":"Evaluation","p":["Trustlessness. State channels and networks are trustless as long as users are online. When users are not online they need to trust watchtowers to keep user funds safe. Smart contract systems that rely on channel networks inherit these properties.","Expressiveness. Most channel networks are geared towards payments, therefor they cannot express smart contracts. However some smart contract protocols can integrate with state channels, in which case all smart contracts of the respective protocol can be expressed.","Efficiency. Our definition of efficiency only makes sense for smart contract systems, so this property does not apply to payment networks."]},{"l":"Interoperable Blockchains","p":["An interoperable blockchain is a separate blockchain that connects to Bitcoin in various ways. In most cases smart contracts of the interoperable blockchain can read and write transaction from and to Bitcoin. In some cases, Bitcoin is used in the consensus of the interoperable blockchain."]},{"i":"examples-1","l":"Examples","p":["Stacks enables smart contracts that use Bitcoin as an asset in a trust-minimized way. It has its own native asset called STX. The Stacks blockchain relies on STX and BTC for its consensus mechanism called Proof of Transfer (PoX). Stacks miners bid by spending BTC, and their probability of mining the next block on the STX chain is proportional to the amount bid. This amount is paid to STX holders that lock up or \"stack\" their STX. As a consequence the price ratio between BTC and STX is continually recorded and available on-chain. Stacks's smart contract language is a non-Turing complete language called Clarity. More info","Todo. More info"]},{"i":"evaluation-1","l":"Evaluation","p":["Trustlessness. Interoperable blockchains are as trustless as the blockchain that is connected to Bitcoin.","Expressiveness. Typically, all smart contract systems can be expressed.","Efficiency. Interoperable blockchains that support smart contracts are typically based on the account model like Ethereum and are therefore not efficient."]},{"l":"Sidechains","p":["A sidechain is a separate blockchain linked to Bitcoin through a two-way peg.","A user sends their Bitcoin to a dedicated address controlled by the group of users that maintain the peg. These users then create the corresponding value of tokens on the sidechain. Those tokens can be used to access the functionality of the sidechain. Later, the sidechain user can transfer tokens back to the maintainers the peg, who will hopefully send the corresponding amount of tokens back to the sidechain user.","Two-way pegs can be centralized, federation-based, or SPV-based. In centralized two-way pegs a trusted third party controls the Bitcoin in the peg and is responsible for locking and unlocking the Bitcoin. In a federated peg, the locked Bitcoins are at the custody of a group of users called the federation. A common implementation is to use a multisignature address, in which a quorum of participants is required to spend the funds. Simplified Payment Verification (SPV) makes it possible to verify the inclusion of a transaction in a blockchain without verifying the entire blockchain. A SPV two-way peg scheme could work as follows: The locked Bitcoin are stored in an output that can only be spent if an SPV proof is provided that a corresponding number of tokens have been burnt on the sidechain."]},{"i":"examples-2","l":"Examples","p":["Liquid Network is a federated sidechain, relying on the concept of strong federation. A strong federation consists of two independent entities: block signers and watchmen. Block signers maintain the consensus and advance the sidechain, while watchmen realize the cross-chain transactions by signing transactions on the mainchain using a multisignature scheme.","The members of the federation maintain the consensus of the sidechain by signing blocks in a round-robin fashion. The federation consists of large exchanges, financial institutions, and Bitcoin-focused companies but their identities are not public. Users trust that at least two-thirds of the federation is acting honestly to ensure security. Watchmen sign each block transferred between the mainchain and the sidechain on the mainchain using a multisignature scheme.","The sidechain Liquid is based on the Bitcoin codebase, however it has a 10x higher throughput due its block time of just one minute. Liquid supports the creation of on chain assets as well as enhanced privacy through confidential transactions. More info.","Rootstock (RSK) is a smart contract platform with a native token called Smart Bitcoin (RBTC) that is pegged 1:1 with Bitcoin (BTC) and is used to pay for gas when executing smart contracts on the RSK network. RSK is merge-mined with Bitcoin, meaning that RSK miners also mine Bitcoin but not vice versa.","RSK relies on a combination of a federated two-way peg and an SPV (Simplified Payment Verification) scheme. Users can send Bitcoin to the peg and they are issued RBTC on the RSK sidechain. Each transfer between the sidechain and the main chain requires a multi-signature by the RSK federation to complete the transferring process. Federation members use hardware security modules to protect their private keys and enforce transaction validation. More info"]},{"i":"evaluation-2","l":"Evaluation","p":["Both centralized and federation based sidechains have the disadvantage of introducing trusted third parties, arguably defeating the purpose of a blockchain solution. SPV based solutions have the advantage of being trustless, however users have to wait for lengthy confirmation periods. The second problem is that the consensus mechanism of the sidechain is typically less secure than Bitcoin's, making it the weakest link in the system and prone to attacks.","Trustlessness. Only for pure SPV based solutions. Expressiveness. If the sidechain uses the account model. Efficiency. No as the sidechain typically uses the account model."]},{"l":"Rollups","p":["A rollup is similar to a sidechain but (a) the federation is replaced by a smart contract and (b) transaction data is stored on the main chain instead of a separate blockchain. The rollup can have its own transaction format independent from the main chain and we will refer to these transactions as L2 transactions.","To use a rollup, a user deposits funds to the rollup smart contract on the main chain. These funds can then be used in L2 transactions. To use the rollup, a user sends a L2 transaction to a designated user called aggregator. Periodically, the aggregator selects a batch of L2 transactions, creates a main chain transaction and publishes it. This main chain transaction contains the L2 transactions in compressed form and the hash of the new state. The rollup’s smart contract on the main chain assures the aggregator posted the hash of the correct new state. There are different ways that this check occurs, optimistically or using zero knowledge proofs, as discussed below. When users wish to redeem their deposit, they transact with the rollup’s smart contract on the main chain and receive funds equal to the amount of their balance on the L2."]},{"l":"Optimistic Rollups","p":["In an optimistic rollup the aggregator posts the compressed L2 transactions and the hash of the new state to the main chain without any verification. A group of users called verifiers check that the new state matches the instructions in the L2 transactions. Verifiers can then publish a \"fraud proof\", claiming that the aggregator posted an incorrect hash.","To discourage aggregators and verifiers from acting maliciously, both the aggregator and verifier need to stake a bond. If the verifier can provide a valid fraud proof, the verifier earns half of the aggregator’s bond while the other half is burned (this is to prevent a scenario where a malicious aggregator tries to front-run an honest validator by publishing another fraud proof). If the fraud proof is invalid, the verifier gets fined."]},{"l":"Zero-knowledge Rollups","p":["While optimistic rollups use fraud proofs, zero-knowledge (ZK) rollups, and validity rollups more generally, use validity proofs. Instead of allowing the aggregator to publish a transaction and then question it, in ZK rollups, the aggregator must prove that the state hash is the correct using a validity proof.","Similarly to optimistic rollups, an aggregator (sometimes called sequencer) evaluates L2 transactions and published compressed transaction data and the new state hash to the main chain. However they add a ZK proof that is evaluated by a smart contract on the main chain. The smart contract ensures that only correct executions are recorded on the main chain. In contrast to optimistic rollups, ZK rollups do not require second layer verifiers and there is no dispute resolution. This means transactions achieve finality rapidly; there is no extended period of time where verifiers can trigger a dispute phase.","The two most commonly used ZK proofs used for rollups are called SNARKs and STARKs. SNARKs are computationally efficient: the time needed to verify a SNARK grows slower than the time of the computation itself. However, they require a trusted setup. STARKs require no trusted setup, but require much more time for proof generation and verification."]},{"i":"examples-3","l":"Examples","p":["BitVM is an optimistic rollup. Its primary purpose is facilitating trust minimized bridges between Bitcoin and other chains.","A federation of 1000 members engage in a trusted setup and users trust that at least 1 participant is honest, otherwise the federation can steal all funds. Peg-ins can be censored by any federation member as a peg in requires the collaboration of all federation members. In addition all federation members need to pre-sign 100 peg-out transactions each (100.000 transactions in total), therefore peg-ins only occur every 6 months.","There are 100 operators and users trust that at least one online operator is honest, otherwise the user can be prevented from pegging out. Operators must be able to front the money for a peg out for two weeks, so only well capitalized institutions can be operators. Withdraws can take months to give validators the chance to go through the challenge process. Any user can be a validator.","The transactions that are broadcast in the BitVM protocol","To \"peg in\", a user called Bob sends 100 Bitcoin to a n-of-n multisig address controlled by the federation. In exchange, the federation will issue Bob tokens on the destination blockchain. When Bob want's to \"peg out\", Bob signals his wish to the federation by burning tokens on the destination blockchain. Operators can front the 100 Bitcoin to Bob in a \"Peg Out\" transaction. The operator then broadcasts the \"kick-off\" transaction. If all goes well, and there is no dispute, the federation will broadcast the \"Take 1\" transaction that spends 100 Bitcoin to the operator.","In the case of a dispute, any validator will broadcast the \"Challenge\" transaction. Once this transaction is broadcast, the \"Take 1\" transaction cannot be spend anymore, as both transaction spend the same output (this is called a connector output). Once the \"Challenge\" transaction is broadcast the operator will broadcast the \"Assert\" transaction that breaks down the high level statement that the operator originally made, into smaller, easily disprovable statements. If any of these lower level statements are incorrect, any verifier can broadcast a \"Disprove\" transaction that points to the false statement by the operator. If no validator broadcasts a Disprove transaction, the operator can broadcast a \"Take 2\" transaction to regain control of the original 100 Bitcoin. More info here and here.","Todo. More info"]},{"i":"evaluation-3","l":"Evaluation","p":["Rollups rely on smart contracts on the main chain, therefore it is easier to make them trustless and practical on chains with strong native smart contract support like Ethereum. By understanding the properties of rollups on Ethereum, we can understand how rollups on Bitcoin can work in the best case.","On Ethereum rollups generally introduce trusted third parties, central points of failures, and lockup periods.","As building a validity proof requires heavy computations ZK rollups’ L2 fees are higher than optimistic rollups. Additionally, ZK rollup main chain transaction fees are higher as the validity proof needs to be validated on the main chain for every batch.","On the other hand, optimistic rollups have a period where verifiers have an opportunity to publish a fraud proof. Thus users need to wait (usually a week on Ethereum, on Bitcoin it will likely be longer) until their deposits can be withdrawn. In ZK-rollups, deposits could be withdrawn immediately, however in many cases users have to wait for 24h due to safety concerns. In most cases there is only one aggregator and a very small number of validators and users trust that they do not collude.","Trustlessness. In optimistic rollups users trust that one honest validator is online at all times. STARKs are trustless, SNARKS are not.","Expressiveness. Depends on the expressiveness of the L2.","Efficiency. Depends on the efficiency of the L2."]},{"l":"Complexity of SNARKs and STARKs","p":["The Big-O notation is used in Computer Science to describe the upper bound of the runtime of an algorithm in terms of the size of its input. An algorithm is said to run in time O(f(n)) if for sufficiently large input sizes n, the algorithm's runtime will not exceed c * f(n) steps.","Prover Complexity refers to the computational complexity associated with generating a proof for a given computation. Verifier Complexity refers to the computational complexity associated with verifying the correctness of a proof for a given computation. The table below is obtained from here","Type","Trustless","Prover Complexity","Verifier Complexity","SNARKs","No","O(n \\cdot \\text{log}(n))","O(1)","STARKs","Yes","O(n \\cdot \\text{log}(n)^c)","O(\\text{log}(n)^c)","Verifier complexity for SNARKs is O(1) meaning that the time to verify a computation can be take longer for small inputs but is faster (even constant) for large enough inputs. Verifier complexity for STARKs is O(\\text{log}(n)^c) meaning that it can take much longer to verify a short computation but for very large computations verification is faster than computation."]},{"l":"Meta Protocols","p":["A user of a meta protocol that wants to write smart contract data adds meta data to a transaction and sends it to the Bitcoin miners. Software that is specific to the protocol parses the meta data and computed smart contract data (like the number of tokens owned by a user) from it.","There are two basic types of meta protocols called block-order based and UTXO based. These two types result form two basic ways of viewing a UTXO based blockchains: as a list of transactions and as a graph of transactions."]},{"l":"Block-order based","p":["The software for a block-order based protocol reads all transactions in the main chain in block-order to find transactions with meta data specific for that protocol. It will then interpret that sequence of meta data values as instructions and build up a data structure of smart contract data. The smart contract data will for example store which user owns which tokens."]},{"l":"Formal Description","p":["We denote the set of transactions by T. We denote by V the set of smart contract data values where \\{\\} \\in V denotes the empty value. We denote the set of sequences of values in a set X by X^*.","A block-order based meta protocol P consists of a function f: V \\times T \\rightarrow V. Let t_1 \\ldots t_n \\in T^* be the sequence of meta data values for P in the main chain in the order of their occurrence. Then P computes the smart contract data value f( \\ldots f(f(\\{\\}, t_1), t_2) \\ldots , t_n)."]},{"i":"example-brc20","l":"Example: BRC20","p":["Example trace in the BRC20 protocol","The BRC20 protocol is a protocol for fungible tokens.","The image on the right shows an example execution of the BRC20 protocol. The left column shows the meta data values and the column on the right shows the value that is computed after parsing each respective meta data value. The smart contract data value is initialized to the empty element \\{\\}. The first meta data value { op: deploy, ... } specifies the deployment of a fungible token called \"lite\" with a maximum supply of 1000. Once the BRC20 software parses this meta data value it updates its computed value to { lite: { max : 1000 }} as shown on the right. The next transaction contains a mining instruction and the software will update it's internal value accordingly as shown on the right. The bottom row shows a transaction shows a transfer transaction and the computed value that reflects that ownerB received one token from ownerA. The ownership of the assets is determined by the ownership of the outputs that contain the meta data. See here for more details."]},{"i":"evaluation-4","l":"Evaluation","p":["Trustlessness. Yes.","Expressiveness. No, the existing block-order based protocols that we are aware of are single purpose only.","Efficiency. No, block order based protocols need to parse all transactions to compute a single value.","There are two other issues issues: Block-order based protocols cannot be real time as there is no indication in which order the transactions will occur on the mempool before a block is mined. Miners are incentivized to include transactions in an order that is advantageous to them. This is a common problem in Ethereum called \"miner extracted value\" (MEV)."]},{"l":"UTXO based","p":["Whereas block order based systems compute one global value from all transactions, UTXO based protocols compute a value for each output that is relevant to that protocol. The value computed for an output can usually depend on the meta data on that transaction and the valued computed for the inputs spent."]},{"l":"Formal Description","p":["Let O be the set of outputs. A UTXO based protocol P is a function P: O \\rightarrow V that map outputs to smart contract data values.","We will say that a protocol P is well designed if P(o) can be computed from the meta data on the transaction containing o and the values of the outputs spent by t. That is, there is a function f_P: O \\times V^* \\rightarrow V such that P(o) = f_P(o, P(o_1) \\ldots P(o_n)) where o_1 \\ldots o_n are the outputs spent by the transaction containing o.","We can see that all well designed UTXO based protocols are efficient: You can compute the value of an output by parsing \"only\" the transactions that are reachable form the transaction containing the output via the of the spending relation, potentially using multiple hops. This is still a large number of transactions in general, but for some values for example those on the outputs of a coinbase transaction can be computed from one transaction."]},{"i":"example-ordinals","l":"Example: Ordinals","p":["The ordinals protocol is a protocol for non-fungible token. It associates an integer with every satoshi and a list of integers with each output. The length of the list of integers is equal to the number of satoshis stored in the block. It does not require any meta data.","The Ordinals protocol","The ordinals algorithm computes the block rewards r_1, r_2, \\ldots for every block in a chain. It then labels the output of the coinbase transaction of block i with the numbers ranging from r_0 + \\ldots + r_{i-1} to r_0 + \\ldots + r_i where r_0 = 0. To label the outputs of a transaction with inputs, the algorithm first determined the ordinal ranges of the outputs being spent and concatenates them. This array is used to label the outputs as follows: for each output, the algorithm will remove as many numbers from the array as the output has satoshis and assign that list of numbers to the output. The array will be sufficiently long as the number of satoshis spent by a transaction transaction must always be at least the number of satoshis in the output. This presentation is slightly simplified as it does not take fees into account, for details see here.","We can see an example in the picture. The top transaction is the coinbase transaction of the first block. As the output of this transaction contains 5 Billion satoshis (= 50 Bitcoin) this output is labelled with the numbers 1, 2, \\ldots 5.000.000.000. The transaction below spends that output and contains two outputs with 20 and 30 Bitcoin. The first of these outputs is labelled with the numbers 1, 2, \\ldots 2.000.000.000 and the second with 2.000.000.001 \\ldots 5.000.000.000. You can find more information here.","Trustlessness. Yes. Expressiveness. No. Efficiency. Yes."]},{"i":"example-runes","l":"Example: Runes","p":["The Runes protocol","The runes protocol is a protocol for fungible tokens. Its smart contract data values are key value pairs where keys are token ids and its values are numbers. The meta data values are an efficient encoding of nested json objects.","There are distinct kinds of meta data values: \"etchings\" are used to deploy tokens, they can specify for example how many times a token is mined through the cap key and the number of tokens created in each mint via a key called amount. Minting instruction specify a token id (encoded as block-number.offset). \"Edicts\" transfer the tokens spent by the inputs into the outputs. A transfer transaction contains a list of edicts, each of which transfers the token id to transfer, the amount, and the output number. The meta-data is encoded into an array of integers which is stored in the op-return.","The picture shows an etching that deploys a new fungible token called \"lite\" that can be minted 10 times, creating 100 tokens on every mint. This transaction is assumed to be the 4th transaction in block 123. The second transaction show mints 100 tokens, the third transaction transfers the minted tokens into two outputs with one and 99 tokens each. You can find more information in the ordinals docs.","Trustlessness. Yes. Expressiveness. No. Efficiency. Yes."]},{"i":"example-bitcoin-computer","l":"Example: Bitcoin Computer","p":["The Bitcoin Computer protocol","This Bitcoin Computer is a general purpose meta protocol, meaning that it can express all computable smart contracts. The smart contract data values are arbitrarily nested Javascript objects. The meta data values contain mostly Javascript expressions.","There are two types of transactions: \"modules\" contain Javascript (ES6) modules. All other transactions contain a Javascript expression, a \"blockchain environment\" that associated (free) variables in the expressions with input numbers, and an optional \"module specifier\" containing a transaction id. In order to compute the value of an output, the Bitcoin Computer software","imports the module from the transaction referred to","computes the values for the outputs being spent and then substitutes these values for the free variables in the expressions as designated by the blockchain environment","evaluate the expression with the substitution applied in the scope of the module","The picture shows the deployment, minting, and sending a non fungible token and a non fungible token. For more details see the rest of the documentation.","Trustlessness. Yes. Expressiveness. Yes. Efficiency. Yes."]},{"l":"Sources","p":["[1] SoK: Applications of Sketches and Rollups in Blockchain Networks, Arad Kotzer, Daniel Gandelman and Ori Rottenstreich; Technion, Florida State University[2] Blockchain Scaling Using Rollups: A Comprehensive Survey, Louis Tremblay Thibault, Tom Sarry, and Abdelhakim Senhaji Hafid; Montreal[3] SoK: unraveling Bitcoin smart contracts, Nicola Atzei, Massimo Bartoletti, Tiziana Cimoli, Stefano Lande, Roberto Zunino; Cagliari, Trento[4] Beyond Bitcoin: A Review Study on the Diverse Future of Cryptocurrency, Mohammed Faez Hasan, University of Kerbala[5] BitML: A Calculus for Bitcoin Smart Contracts, Massimo Bartoletti, Roberto Zunino; Cagliari, Trento[6] An Overview of Smart Contract and Use cases in Blockchain Technology, Bhabendu Kumar Mohanta, Soumyashree S Panda, Debasish Jena; IIIT Bhubaneswar[7] Layer 2 Blockchain Scaling: a Survey, Cosimo Sguanci, Roberto Spatafora, Andrea Mario Vergani; Polytechnico Milano[8] A Rollup Comparison Framework, Jan Gorzny, Martin Derka; Zircuit[9] SoK: Decentralized Finance (DeFi)[10] SoK: Communication Across Distributed Ledgers[11] Colored Coins whitepaper, Yoni Assia, Vitalik Buterin, liorhakiLior, Meni Rosenfeld, Rotem Lev[12] Exploring Blockchains Interoperability: A Systematic Survey[13] bitcoinlayers.org[14] bitcoinrollups.io[15] Hiro Blog[16] Validity Rollups validity_rollups_on_bitcoin.md"]}],[{"l":"Legal Notice","p":["Sanctioned Users are Prohibited. You may not access or use software developed and published by us if you are (i) a resident of any country with which transactions or dealings are prohibited by governmental sanctions imposed by the U.S., the United Nations, the European Union, the United Kingdom, or any other applicable jurisdiction (collectively, “Sanctions Regimes”); (ii) a person, entity or government prohibited under an applicable Sanctions Regime (“Sanctioned Person”), including the Office of Foreign Assets Control, Specially Designated Nationals and Blocked Persons List; or (iii) prohibited from accessing or using the Software pursuant to the laws, rules, and regulations in the jurisdiction in which you reside or otherwise access and use the Software.","Users Must Comply with Applicable Law. You may only access or use the Software in compliance with laws, rules, and regulations in the jurisdiction in which you reside or otherwise access and use the Software, including, as applicable, Sanctions Regimes, anti-money laundering laws and regulations, and securities laws and regulations.","BCDB Does Not Endorse or Promote User Software Activity. We are publishing certain portions of the Software, on an open-source basis, to demonstrate the utility of the Bitcoin Computer. As this Software is open-source, it may be modified and deployed for a wide range of uses that we may not have intended. We do not endorse or promote, and expressly disclaim liability for, any non-BCDB use or modification of the Software."]}]]