[[{"l":"Bitcoin Computer"},{"l":"A Turing-Complete Metaprotocol for UTXO-Based Blockchains","p":["The Bitcoin Computer is a protocol for building applications that are as secure and decentralized as Bitcoin is. You can build games, tokens, exchanges and more without relying on a sidechain, an extra token, or a trusted third party.","Free Computation- Smart contracts are executed on the client. Execution costs are fixed and independent of the number of computational steps.","Multicoin. Deploy on Bitcoin, Litecoin, Dogecoin, and Pepecoin (Bitcoin Cash coming soon) using the same code.","JavaScript & Typescript- Build decentralized applications that integrate seamlessly into web applications using your favorite tools and execute on high performance JavaScript engines.","Simple- Deploy a smart contract by inscribing a JavaScript class, create an on-chain object by inscribing a constructor call and update an on-chain object by inscribing a function call.","Expressive- All computable updates can be expressed and on-chain objects can be freely combined, enabling complex applications like decentralized exchanges or multi-asset games.","Efficient- The system is perfectly sharded, so users only need to compute values of on-chain objects they are interested in.","Fast- Built-in optimizations eliminate redundant computation and communication, ensuring high-performance out of the box.","History- Every historical state is recoverable and each update is stored in a timestamped, digitally signed transaction.","Data Ownership- On-chain objects are stored in UTXOs, meaning only the UTXO owner can update their state. Data ownership is as secure as cryptocurrency ownership.","Compatible- Compatible with existing Bitcoin protocols. You can build apps for Ordinals and Runes, or use BitVM to enforce complex data ownership rules.","Privacy- Public by default, built-in support for encryption and off-chain storage enables CCPA- and GDPR-compliant applications.","The Bitcoin Computer is developed by BCDB Inc. Join our community on Telegram or on X."]}],[{"l":"Start"},{"l":"Use in the Browser","p":["Create the file below and open it in a browser. It show *, then 0 and finally 1."]},{"i":"use-in-nodejs","l":"Use in Node.js","p":["You need to have node.js installed. First download and install the Bitcoin Computer library from npm:","Then create a file index.mjs.","Execute the smart contract.","The expected output is:"]},{"l":"Run a Node","p":["In the examples above you are using a Bitcoin Computer Node that we provide at rltc.node.bitcoincomputer.io configured to Litecoin Regtest. You can use this node for free but it is rate limited. For serious development we recommend to clone the monorepo so you can run your own, unlimited, node. To run a node we recommend to clone the monorepo with all Bitcoin Computer related materials."]},{"l":"Clone and Install"},{"l":"Start the node","p":["To start your node at http://localhost:1031 run the commands below. The node is ready once the log activity subsides. On regtest this will take a few minutes, on mainnet and testnet it can take hours or even days, depending on your hardware and network connection."]},{"l":"Run the Tests","p":["Once the node is up an running, open a separate terminal window and navigate the monorepo folder. You can run the following commands. The commands will be executed in each package. You can also navigate the a package and run the same scripts there."]},{"l":"Configure Client Side Library","p":["To run the examples above with your own node, change the line that creates to Computer instance as below."]},{"l":"Start A Project","p":["We provide two templates, vite-template for client side projects and node-template for server side projects. Alternatively have a look at our example apps (e.g. our wallet, blockchain explorer, or nft app) to see if any of them are a good starting point for your project."]},{"l":"Getting Help","p":["Telegram","Twitter"]}],[{"l":"Tutorial","p":["In this tutorial we explain how to build a decentralized chat. We will start with a comically simple version of a one person chat, but we will work our way up to a chat platform where users can build a community and sell it trustlessly through a smart contract."]},{"l":"A Smart Contract","p":["The JavaScript program below is a smart contract for a one-person chat.","We recommend to ignore the syntax for initializing messages in the constructor for now. If you are interested in the details you can find them here."]},{"l":"The Client-Side Wallet","p":["The Computer class is a client-side JavaScript wallet that manages a Bitcoin private-public key pair. It can create normal Bitcoin transactions but also ones that contain metadata according to the Bitcoin Computer protocol. This allows for the creation, updating, and retrieval of on-chain objects.","You can pass a BIP39 mnemonic into the constructor to create a specific private-public key pair, or leave the mnemonic parameter undefined to generate a random wallet. More configuration options are described here."]},{"l":"Creating On-Chain Objects","p":["The computer.new function broadcasts a transaction inscribed with a JavaScript expression consisting of a class and a constructor call. For example, the call","broadcasts a transaction inscribed with the expression below.","The Bitcoin Computer protocol interprets such a transaction as creating an on-chain object of type Chat at the first output of the transaction.","The object chat returned from the computer.new call is similar to the object returned from the call new Chat('hello'). However it has additional properties _id, _rev, _root, _owners and _amount:","The properties _id, _rev, _root are set to strings of the form id:num where id is the id of the transaction broadcast by the computer.new call and num is an output number.","The _owners property is set to an array containing public keys.","The _amount property specifies an amount in satoshis.","We refer to chat as an on-chain object.","Note that the transaction that created chat does not contain an encoding of the object itself. It only contains code that evaluates to its state."]},{"l":"Updating On-Chain Objects","p":["When a function is called on an on-chain object, a transaction is broadcast that is inscribed with a JavaScript expression encoding the function call and an environment determining the undefined variables in the expressions. For example, the call","broadcasts a transaction tx that is inscribed with the data below.","The transaction's first input spends the output in which the previous revision of the chat object was stored.","Note that it is not possible to compute a value from the expression chat.post('world') alone because the variable chat is not defined. To make the expression determined the transaction's inscription contains an environment env that associates the variable name chat with its first input.","To compute the value of the chat after the post function is called and the transaction tx is broadcast, the Bitcoin Computer protocol first computes the value stored at the output spent by the first input of tx. This value is then substituted for the name chat in the expression chat.post('world'). Now the expression is completely determined and can be evaluated. The new value for chat is associated with the first output of tx. In our example, this value is","The property _rev has been updated and now refers to the first output of tx. The properties _id, _root, _owners, _amount have not changed. The meaning of these special properties is as follows:","_id is the output in which the on-chain object was first created. As this output never changes the _id property never changes","_rev is the output where the current revision of the object is stored. Therefore, initially, the revision is equal to the id, then the revision is changed every time the object is updated.","_root is never updated. As it is not relevant to the chat example we refer the interested reader to this section.","_owners is set to the public key of the data owner. More on that below.","amount is set to the amount of satoshi of the output in which an on-chain object is stored. More here.","The properties _id, _rev, and _root are read only and an attempt to assign to them throws an error. The properties _owners and _amount can be assigned in a smart contract to determine the transaction that is built.","The state of the on-chain objects is never stored in the blockchain, just the JavaScript expression that creates it. This makes it possible to store data compressed to its Kolmogorov complexity which is optimal."]},{"l":"Reading On-Chain Objects","p":["The computer.sync function computes the state of an on-chain object given its revision. For example, if the function is called with an the id of an on-chain object, it returns the initial state of the object","If computer.sync is called with latest revision it returns the current state."]},{"l":"Finding On-Chain Objects","p":["The computer.query function returns an array of strings containing the latest revisions of on-chain objects. For example, it can return the latest revision of an object given its id:","A basic pattern in applications is to identify a on-chain object by its id, to look up the object's latest revision using computer.query, and then to compute its latest state using computer.sync. For example, in our chat app the url could contain a chat's id and the latest state of the chat could be computed as shown below.","computer.query can also return all revisions of on-chain objects owned by a public key. This could be useful for creating a user page for the chat application.","It is also possible to navigate the revision history of a on-chain object using computer.next and computer.prev:","Note that the code above only works because there are only two revisions of the chat in our example, otherwise computer.next or computer.prev would have to be called multiple times."]},{"l":"Data Ownership","p":["We are finally ready to elevate our one-person chat to a three-person chat! We will explain how to allow an unlimited number of users further below.","The owner of an on-chain object is the user that can spend the output that stores it, just like the owner of the satoshi in a output is the user that can spend it.","The owners can be set by assigning the _owners property. If this property is set to an array of public keys, the output script is a 1-of-n bare multisig script, meaning that any owner can update the object. If it is undefined the owner default to the public key of the computer object that created the on-chain object.","In the chat example, the initial owner is the public key of the computer object on which computer.new function was called. Only that user can post to the chat. We can add a function invite to update the owners array to allow other users to post.","While a user can never change an on-chain object that they do not own, the owner has complete control. This includes the ability to destroy their own objects by spending their outputs with a transaction that does not conform to the Bitcoin Computer protocol. In this case the value of the object will be an Error value.","This is reminiscent of the real world where people have the right to destroy their own property but not the right to destroy somebody else's property."]},{"l":"Encryption","p":["By default, the state of an on-chain object is public in the sense that any user can compute its state by using computer.sync. However, read access can be restricted by setting an objects _readers property to an array of public keys. If _readers is assigned, the meta-data on the transaction is encrypted using a combination of AES and ECIES so that only the specified readers have read access.","For example, to ensure that only people invited to the chat can read the messages, you can update our example code as follows:","As all updates to an on-chain object are recorded in immutable transactions it is not possible to restrict access to a revision once it is granted. It is also not possible to grant read access to a revision without granting read access to its entire history as the entire history is needed to compute the value of a revision. It is however possible to revoke read access from some point forward or to restrict access to all revisions all together.","When on-chain objects are encrypted the flow of cryptocurrency is not obfuscated."]},{"l":"Off-Chain Storage","p":["It is possible to store the metadata of a transaction off-chain in the database of a Bitcoin Computer Node. In this case a hash of the metadata and a url where the metadata can be retrieved is stored on chain, while the metadata itself is stored on the server. To use this feature, set a property _url of an on-chain object to the URL of a Bitcoin Computer Node.","For example, if users want to send images to the chat that are too large to store on-chain, they can use the off-chain solution:"]},{"l":"Cryptocurrency","p":["Recall that an on-chain object is stored in an output and that the owners of the object are the users that can spend the output. Thus the owners of an object are always the owners of the satoshi in the output that stores the object. We therefore say that the satoshi are stored in the on-chain object.","The amount of satoshi in the output of an on-chain object can be configured by setting the _amount property to a number. If this property is undefined, the object will store an a minimal (non-dust) amount.","If the value of the _amount property is increased, the additional satoshi must be provided by the wallet of the computer object that executes the call. In the case of a constructor call with computer.new that is that computer object. In the case of a function call it is the computer object that created the on-chain object.","If the value of the _amount property is decreased, the difference in satoshi is credited to the associated computer object's wallet.","For example, if a user Alice wants to send 21000 satoshis to a user Bob, then Alice can create an on-chain object of the following Payment class.","When the payment on-chain object is created, the wallet inside the computerA object funds the 21000 satoshi that are stored in the payment object. Bob can withdraw the satoshi by calling the cashOut function."]},{"l":"Expressions","p":["A JavaScript expression exp,","an environment env that maps names to output specifiers,","and a module specifier mod.","It returns a transaction but does not broadcast it. Therefore calling the encode function does not alter the state of any on-chain object. In addition to the transaction the function returns an object effect that represents the state that will emerge on-chain if the transaction is broadcast.","The code below is equivalent to calling await computer.new(Chat, ['hello']). In fact the computer.new function is just syntactic sugar for using the encode function.","The computer.encode function takes three arguments:","The effect object has two sub-objects: res contains the value returned from the expression and env contains the side-effect, specifically the new values of the names in the environment.","The effect object returned from the encode function provides absolute certainty about a transaction's impact before broadcasting. If the transaction is included, the state updates exactly as reflected in the effect object, independent of other users' transactions; otherwise, the state remains unchanged.","The encode function allows fine grained control over the transaction being built via an options object as a second argument that can specify","The syntax for on-chain objects introduced above provides a high-level abstraction over the Bitcoin Computer protocol. However we also provide low-level access to the protocol via the computer.encode() function. This gives more control over the transaction being built, enabling advanced applications like DEXes.","whether to fund the transaction","whether to include or exclude specific UTXOs when funding","whether to mock objects to do not exist yet on-chain (see more below)","whether to sign the transaction","which inputs to sign","which sighash type to use when signing"]},{"l":"Module System","p":["The computer.deploy function stores a JavaScript modules on the blockchain. It returns a string representing the output where the module is stored. Modules can refer to one another using the familiar import syntax. In the example below moduleB refers to moduleA via specifierA. Module specifiers can be passed into computer.encode and computer.new functions.","Modules can be loaded from the blockchain using computer.load."]},{"l":"Bitcoin Script Support","p":["In addition to setting the _owners property to an array of strings as described above, it is possible to set _owners to a string encoding a Bitcoin Script ASM. In this case the output created for that on-chain object will use a pay-to-script-hash (p2sh) output with that script.","In order to spend an output with a p2sh script, one needs to alter the transaction returned from encode. The example below shows how to build a transaction with an inputs script OP_3.","A Bitcoin Script could be used to allow more than three users to post to a chat. The idea is to use a Taproot script that has one spending path for each user. Taproot scripts have a large number of spending paths, so a large number of users could be supported. When this kind of Taproot chat is updated, only the spending path for the posting user needs to be revealed, meaning that the cost to post is constant and independent of the number of users in the chat."]},{"l":"Mocking","p":["Recall that an on-chain object is an object that is associated with the output of a transaction that is built according to the Bitcoin Computer protocol. We will call such an object an off-chain object if the transaction has not been broadcasted yet.","It is sometimes necessary to update off-chain objects. For example, if smart contracts are used in payment channels or networks. Or, if an object is sold to an unknown buyer: in this case the object that the buyer will use is not known when seller build the transaction (see here).","Mocking is a technique for updating off-chain objects. The mocks property of the encode function can be set to a mapping from variable names to mocked objects. Here, a mocked object is an object that has _id, _rev and _root set to strings mock-${hex}:${num} where hex is a string of 64 hexadecimal characters and num is a number. In addition a revision needs to be specified for the mocked variable name in the env array (if the revision in env does not match the revision of the mocked object for the same variable name the revision in env takes precedence). When the transaction is built, it is assumed that the value stored at the revision specified in env evaluates to the value in the mocks for the same variable name.","The Bitcoin Computer library exports a class Mock that makes it easy to create mocked objects. The example below shows how a mocked object can be used. Note that in the example, the object a is created after the transaction that spends it. Thus the revision of a is not known when tx is built. Once a is created on-chain and its revision becomes known, the code below updated the input of tx to spend the revision of a."]},{"l":"Building the Chat Platform","p":["We now sketch how a chat platform could be built where moderators can create a community and then sell it over the internet.","Every community would be represented through multiple on-chain objects that are similar to the Chat object. In order to guarantee a fast load time, each of these objects contains a constant-size chunk of messages (have a look at this section to understand the build-in optimizations). When the current chunk object is full, a new object that would refer to the previous chunk would be created. When the chat app is loaded it syncs to the the latest chunk. If the user scrolls to the first message of the chunk, the user could click a button to load the previous chunk.","In order to support an unlimited number of users, the technique sketched at the end of this section can be used. However the kinds of scripts described there have a 1-of-n ownership structure which can lead to abuse (for example, any member of the chat could destroy the current chunk object). This could be mitigated by maintaining an additional \"moderators\" object for every community. Moderators could spin up a new chunk in the case of abuse and point to the message before the chat was destroyed. Moderators could also have other privileges like kicking out users and deleting messages from the UI. The moderatos object could have an n-of-m ownership structure. To sell a community one can sell the moderators object. This can be accomplished by using the technique described here.","If you would like to build such an app please reach out, we would be delighted to try to help you."]}],[{"l":"How it Works","p":["The Bitcoin Computer protocol associates JavaScript values with the outputs of Bitcoin transactions that contain JavaScript expressions."]},{"l":"Storing Values","p":["To compute the value associated with an output, the expression is first evaluated. If the expression evaluates to a basic type, this value is associated with the first output. If the value is nested and contains multiple sub-objects, each sub-object is associated with a separate output.","This simple mechanism makes it possible to store arbitrarily complex JavaScript values in the outputs of a transaction using an highly efficient encoding: Instead of storing a value, an expression is stored that computes the value. This is much more efficient. In fact, it makes it possible to store a value at its optimal compression (see the Kologromov Complexity)."]},{"l":"Example","p":["Consider a transaction that contains the JavasScript expression '0'.repeat(100000). In this case the first output of the transaction is associated with a string of 100,000 zeroes.","Note that this encodes a 100,000 character string in just 18 characters"]},{"l":"Updating Values","p":["Expressions can contain undefined variables. For example, the variable x is undefined in the expression x+4. It is not possible to evaluate an expression with an undefined variable. For example, an JavaScript interpreter will throw a ReferenceError when trying to evaluate x+4.","In the Bitcoin Computer protocol, expressions with undefined variables are used to encode data updates. To determine a value for the undefined variables, the undefined variables in an expression must be associated with inputs of the transaction. The protocol will then compute the values associated with the outputs spent. These values are the substituted (aka plugged into) the respective undefined variables. This yields an expression where all variables are defined that can be evaluated. The value returned from this evaluation is associated with the outputs as explained in the previous section."]},{"i":"example-1","l":"Example","p":["Consider the transactions on the left. The first is labelled with 1+2. This expression contains no undefined variables and evaluates to 3, therefore the output of the first transaction is associated with the value 3.","The expression x+4 on the second transaction contains the undefined variable x. The input of this transaction is associated with this undefined variable. To compute the value associated with the output of the second transaction, the Bitcoin Computer protocol first computed the value of the output spent, which is 3. This value is then substituted for x in the expression x+4. This yields the expression 3+4 which evaluates to 7. This is the value associated with the output of the second transaction."]},{"l":"The Interface","p":["We call a string of the form id:num where id is a transaction if and num is an output number a revision. The following two functions provide access to the protocol through two main functions:","sync maps a revision to a value.","encode maps an expression and a blockchain environment to a transaction."]},{"l":"Provenance","p":["If the value returned from sync contains an object, it has extra properties _id, _rev, _root that specify its location on the blockchain and its provenance.","The identity of an object, denoted obj._id, is a unique identifier that remains unchanged throughout the object's lifecycle. It is set to the transaction and output that the object was associated to when it was first created.","The revision of an object, denoted obj._rev, encodes an object's current location on the blockchain.","The root of an object, denoted obj._root, records whether obj was created in a function call of another object, and if so which object that was."]},{"l":"Keyword Properties","p":["Smart contracts can contain the keyword properties _owners, _amount, _url and _readers that determine how the transaction is built. Specifically","The _owners property of a smart object determines the output script of the output that is associated with it. If it is set to an array of strings that encode public keys, then the output script will be a 1-of-n multisig script with these public keys. If it is set to a string that encodes a Bitcoin Script ASM, then that will be the script of the output.","The _amount property can be set to a number and determined the amount of satoshi of the output associated with a smart object. If this property is undefined the output will contain a minimal, non-dust amount of satoshis.","The _url property can be set to the url of a Bitcoin Computer node. If set the metadata that would otherwise be stored in the transaction is stored on that node. The metadata will consist only of a url where the data can be obtained.","The _readers property can be set to encrypt the meta data. It can be set to an array of strings encoding public keys. In this case the metadata on the transaction will be encrypted such that only the specified users can decrypt the data and read the object."]}],[{"l":"Smart Contract Language","p":["Writing smart contracts is all about imposing constraints of future values. These constraints can be local or global. An example of a local constraint is a non-fungible token: These are objects that can change their owners but the data itself typically cannot be changed. A non-fungible token is an example of a class with a non-local constraint: the number of tokens must remain constant across all objects emerging from the same mint.","In order to make it possible to write smart contracts in JavaScript, the Bitcoin Computer library exports a class Contract that enforces that whenever a class extends from it, its properties can only be assigned through function calls. This is reminiscent to the behavior of Solidity and makes it possible to write smart contracts in JavaScript.","We call an expression a smart contract if it returns a value that contains only sub-objects whose classes that extend from Contract. The function encode throws an error if it called with an expression that is not a smart contract. Likewise, the function sync throws an error if it is called with a transaction whose expression is not a smart contract.","To describe the behavior of Contract more precisely, let obj be an object of a class that extends from Contract. Then an error is thrown if either","a property of obj is assigned outside of a method of obj,","a property _id, _rev, and _root is assigned, or","this is assigned to in the constructor of C.","To initialize objects without violating rule 3. an initialization object can be passed into super in a constructor:","This has the same effect as assigning to this in a normal JavaScript program"]}],[{"l":"Optimizations","p":["The Bitcoin Computer has built in optimizations that lead to 100x lower latency, 50x faster initial load time, and 100,000,000x faster subsequent load times. The following sections explain how they work."]},{"l":"Server-Sent Events","p":["The computer.subscribe function enables real-time updates via Server-Sent Events (SSEs). The function takes an on-chain ID and a callback function as arguments. The callback is triggered whenever a method is called on the on-chain object with the specified ID. By using this function, both load and latency can be significantly reduced.","Without SSEs, a chat application might query the server every 10 seconds. In the worst case, this would result in a message being delivered with a latency of up to 10 seconds. With SSEs, this latency is reduced to just 100ms, representing a 100x decrease.","Memory Level","Access Time","Size","RAM","~ 100 ns","~ 10 GB","SSD","~ 100 µs","~ 100 GB","Network","~ 100 ms","Unbounded"]},{"l":"Client-Side Caching","p":["On-chain objects are cached in memory whenever they are computed. This means they can be retrieved from memory instead of being recomputed when loaded for the second time and beyond.","The cache automatically manages memory consumption and removes elements when necessary. To measure memory usage for the entire app (not just the cache), we use process.memoryUsage in Node.js and performance.measureUserAgentSpecificMemory in the browser. For browsers that do not support this API (less than 25% of the user base), we currently disable the cache. In the future, we plan to allow application developers to configure and manage the cache manually, ensuring support for all browsers.","The performance impact of in-memory caching is hard to overstate. For example, consider a chat with 100 messages. Without caching, 100 transactions would need to be downloaded in separate network requests, and 100 JavaScript expressions would need to be evaluated. The network latency alone could take around 10 seconds. With the cache, the latest state of the chat can be accessed in just 100 nanoseconds— 100 million times faster. The savings are even greater when factoring in the time spent evaluating the JavaScript expressions.","Notably, the time for accessing an element in the cache is independent of the size of its history and the complexity of the computations needed. Additionally, there’s a guarantee that each transaction is downloaded and each JavaScript expression is evaluated only once, even if the application isn’t optimized carefully.","Have a look here for how to configure applications to make use of client side caching."]},{"l":"Network Request Batching","p":["While client-side caching optimizes time for the second (and subsequent) load(s), network request batching optimizes the first load.","Without batching, each transaction in the history of an on-chain object was downloaded in a separate network request. With batching, we download the IDs of all relevant transactions in a single request. Then, we remove the IDs of transactions whose objects are already in the cache. A second network request downloads the minimal set of transactions required to compute the desired on-chain object. The client then extracts the JavaScript expressions from the transaction hexes, computes the value of the object, and stores it in the cache.","What’s remarkable is that the node can determine the relevant transaction IDs for computing a value without having to evaluate the JavaScript expressions. The fact that the server does not have to evaluate the smart contracts is one of the main reasons why the Bitcoin Computer is so cost-effective, so preserving this property was crucial.","To illustrate the impact of this optimization, consider again a decentralized chat with 100 messages. Without batching, this requires 100 network requests, taking approximately 10 seconds. With batching, the client first downloads the IDs of the transactions that contain messages for this chat in one network request. It then uses the client-side cache to determine which transactions are new since the chat was last loaded and cached. Only the \"new\" transactions are downloaded in a second network request. This reduces the access time to approximately 200 ms, even on the first load—an improvement of 50x.","With only minor exceptions, the value of an on-chain object can now be computed with two network requests, even if it depends on a large number of transactions. Additionally, every transaction is only downloaded once."]}],[{"l":"Transaction Format","p":["Documentation coming soon."]}],[{"l":"Development","p":["Documentation coming soon."]}],[{"l":"Lib","p":["The Bitcoin Computer Library has the exports below.","Class","Description","Computer","Read and write smart contracts","Transaction","Parse Bitcoin Computer transactions","Contract","Extend from this class to create smart contracts","Mock","Mock on-chain objects"]}],[{"l":"Computer","p":["The Computer class has the methods listed below."]},{"l":"Basic","p":["You can build almost all smart contracts with these.","Method","Description","constructor","Creates an instance of class Computer","new","Creates a smart object from a smart contract","query","Finds the latest revisions of smart object","sync","Computes the state of a smart object from a given revision"]},{"l":"Modules","p":["Deploy JavaScript modules to avoid redundant storage smart contract storage on chain and reduce transaction fees.","Method","Description","deploy","Deploys a JavaScript module on the blockchain","load","Loads a JavaScript module from the blockchain"]},{"l":"Advanced","p":["For advanced applications that require control over how the transaction is signed, the UTXOs to be spent, custom scripts, or collaborative transaction building.","Method","Description","encode","Encodes a JavaScript expression into a Bitcoin transaction","encodeNew","Encodes a constructor call into a Bitcoin transaction","encodeCall","Encodes a function call into a Bitcoin transaction","decode","Parses a Bitcoin transaction and returns JavaScript expression","faucet","Fund a computer object on Regtest"]},{"l":"Wallet","p":["Access Bitcoin's RPC interface","Access the client side wallet.","broadcast","Broadcasts a Bitcoin transaction","Confirmed, unconfirmed and total balance in sats","Description","getAddress","getBalance","getChain","getMnemonic","getNetwork","getPassphrase","getPrivateKey","getPublicKey","getUtxos","Method","Returns a BIP39 mnemonic sentence","Returns an array of unspent transaction outputs","Returns the Bitcoin address of the computer wallet","Returns the blockchain","Returns the network","Returns the passphrase","Returns the private key","Returns the public key","rpcCall","send","Sends satoshis to an address","sign","Signs a Bitcoin transaction"]}],[{"l":"broadcast","p":["Broadcasts a Bitcoin transaction."]},{"l":"Type"},{"l":"Parameters"},{"l":"tx","p":["A NamamotoJS transaction object."]},{"l":"Return Value","p":["If the broadcast is successful, it returns the transaction id. Otherwise, an error is thrown."]},{"l":"Examples"}],[{"l":"constructor","p":["Creates an instance of the Computer class."]},{"l":"Type"},{"l":"Parameters"},{"l":"config","p":["''","2","30000 on LTC and 3000 on BTC","A configuration object with the properties listed below. All properties are optional.","Address type","addressType","BIP32 passphrase","BIP32 path","BIP39 mnemonic phrase","chain","Default","Description","Dust relay fee","dustRelayFee","Fee in satoshi per byte","https://rltc.node.bitcoincomputer.io","Key","LTC","m/44'/0'/0'","mnemonic","moduleStorageType","network","p2pkh","passphrase","path","Random phrase","regtest","satPerByte","Store JavaScript modules on Taproot or multisig scripts","taproot","Target blockchain","Target network","url","Url of a Bitcoin Computer Node"]},{"l":"Return Value","p":["An instance of the Computer class"]},{"l":"Examples"}],[{"l":"decode","p":["Parses a Bitcoin transaction and returns its metadata if it is a Bitcoin Computer transaction."]},{"l":"Type"},{"l":"Parameters"},{"l":"tx","p":["A NakamotoJS transaction."]},{"l":"Return Value","p":["An object containing the following properties:","Parameter","Description","exp","The JavaScript expression of the transaction","env","A mapping from variable names to revisions","mod","A module specifier"]},{"l":"Description","p":["The function decode is the inverse of encode when the latter is called with exp, env, and mod."]},{"l":"Example"}],[{"l":"deploy","p":["Stores a Javascript module on the blockchain."]},{"l":"Type"},{"l":"Parameters"},{"l":"module","p":["A string encoding a JavaScript module."]},{"l":"Return Value","p":["A string of the form transaction-id:output number encoding the location where the module is stored."]},{"l":"Description","p":["* Bitcoin Computer support coming soon","18 kB","4 MB","BCH*","BTC","Coin","Default","DOGE*","LTC","Max Module Size","Module Storage Types","multisig","multisig- A module is stored in one transaction with several outputs that contain a bare multisig script each. These outputs are currently un-spendable, in a future update we will make them spendable. The maximum module size is about 18 kB, larger modules must be split into chunks of less than 18 kB and recombined in another module.","No","PEPE","Segwit Discount","Taproot","taproot multisig","taproot- A module is stored two transactions, one commits to the hash of the data ona taproot output script and the second one spends that output and contains the entire module in its input. These modules can be close 400 kB or even close to 4 MB if you know a miner that will include them. In addition module storage is 4x cheaper due to the Segwit discount.","The deploy function stores a JavaScript module on the blockchain and returns a module specifier that identifier that module. This specifier can be passed into computer.new, computer.encode, computer.encodeNew, and computer.encodeCall as an optional parameter. In this case, the names exported from the module are available in the evaluation of these functions.","The protocol supports two module storage types","The rational of deploying modules is that it can save transaction fees: A module can be deployed once and then used to create or update many smart objects. This is unlike on-chain objects whose value can only be used once.","To select the module storage type pass either multisig or taproot into the property moduleStorageType of the Computer constructor. If moduleStorageType is not specified it will use taproot if available and multisig otherwise.","Yes"]},{"l":"Examples","p":["The first example shows how to deploy a module with module storage type multisig.","On BTC and LTC it is possible to deploy larger modules for lower fees by using taproot.","The next example shows how modules can depends on one another","The last example shows how a string of arbitrary length can be stored using the module system. The idea is to partition a long string into constant size chunks, deploy each chunk in a separate module, and then deploy one additional module that recombined the modules for the chunks and exports their concatenation.","In the example the \"recombining\" module is as follows:"]}],[{"l":"encode","p":["Creates a transaction according to the Bitcoin Computer protocol."]},{"l":"Type"},{"l":"Parameters"},{"l":"opts","p":["-","[]","{}","A Blockchain environment mapping variables names to revisions.","A JavaScript expression.","A pair <name, object>. The object is an instance of a mocked class (A class that does not extends from Contract but has the keywords _id, _root, _amount,_owners)","A string of the form id:num specifying the location of a module.","An object with a specification to build a transaction according to the Bitcoin Computer protocol.","Default","Description","env","exclude","exp","fund","If set to a string a custom input script can be provided. If undefined a signature script is generated.","If set to an number only the corresponding input is signed. If undefined all inputs are signed.","include","inputIndex","inputScript","Key","mocks","mod","SIGHASH_ALL","sighashType","sign","The signature hash type.","true","undefined","UTXOs to exclude when funding.","UTXOs to include when funding.","Whether the transaction should be funded.","Whether to sign the transaction."]},{"l":"Return Value","p":["It returns an object { tx, effect } where tx is a NakamotJS transaction and effect is an object with keys res and env. The res object contains the result of the evaluation. The env object has the same keys as the blockchain environment. However, whereas the values of the blockchain environment are revision strings, the values of env and the smart object at these revisions after evaluating the expression."]},{"l":"Description","p":["The encode function builds a Bitcoin transaction from a JavaScript expression. It returns a transaction and an object effect containing the result of the evaluation in a property res. If the expression contains undefined variables a blockchain environment env must be passed into encode. A blockchain environment maps the named of the undefined variable to UTXOs containing on-chain objects. A module specifier can be provided in order to make the exports of that module are available to the evaluation. Other options can customize the funding and signing process. It is also to pass in an object specifying mocked objects.","It is important to note that encode does not broadcast the transaction. Nonetheless the effect object reflects the on-chain state that will emerge once the transaction is broadcast.","The state update effected by a Bitcoin Computer transaction is completely predictable:","If the transaction is included in a block the new state will be exactly the state returned from the effect function.","If the transaction is not included the state is not updated."]},{"l":"Examples","p":["The first example shows how to store a basic type","The second example shows how to encode a constructor and a function call."]}],[{"l":"encodeCall","p":["Creates a transaction from a function call."]},{"l":"Type"},{"l":"Parameters"},{"l":"params","p":["A module specifier","An object with the configuration parameters to encode the expression in a transaction.","args","Description","InstanceType<T>","Key","mod","Module specifiers are encoded as strings of the form <transaction id>:<output number>","Parameters<InstanceType<T>[K]>","property","string","target","The arguments to the function call","The name of the function being called","The smart object on which to call the function","Type"]},{"l":"Return Value","p":["See encode."]},{"l":"Description","p":["See encode."]},{"l":"Examples"}],[{"l":"encodeNew","p":["Creates a transaction from a constructor call."]},{"l":"Type"},{"l":"Parameters"},{"l":"params","p":["Key","Description","constructor","A JavaScript class that extends from Contract.","args","Arguments to the constructor of the class.","mod","A string of the form id:num specifying the location of a module."]},{"l":"Return Value","p":["See encode."]},{"l":"Description","p":["See encode."]},{"l":"Examples"}],[{"l":"faucet","p":["Funds an address on regtest for testing."]},{"l":"Type"},{"l":"Parameters"},{"l":"amount","p":["An amount of Satoshi, indicates the amount that should be credited"]},{"l":"address","p":["If set, indicated the address to be funded. If undefined the wallet of the current Computer object will be funded."]},{"l":"Return Value","p":["The utxo containing the funds."]},{"l":"Description","p":["Funds a Computer object on regtest. A second parameter can provide an address to fund, otherwise the calling object is funded. If the object is not configured to regtest an error is thrown."]},{"l":"Examples","p":["The first example shows how to fund the current Computer object.","The second example shows how another object can be funded.","The last example shows that an error is thrown if the Computer object is not configured to regtest."]}],[{"l":"fund","p":["Funds a Bitcoin transaction."]},{"l":"Type"},{"l":"Parameters"},{"l":"tx","p":["A NakamotoJS transaction object or a Bitcoin Computer Transaction object (that the object from Bitcoin Computer extends the object from NakamotoJS)."]},{"l":"opts","p":["An optional object can be passed as parameter to include or exclude certain UTXOs. When using include, the transaction will be funded with the UTXOs specified as the first inputs.","Key","Description","Default Value","include","UTXOs to include","[]","exclude","UTXOs to exclude","UTXOs are encoded as transaction-id:output-number."]},{"l":"Return Value","p":["If the wallet does not have sufficient funds, an error is thrown."]},{"l":"Examples","p":["The first example shows how to use fund with a NakamotoJS transaction.","The next example shows how to use fund with a Bitcoin Computer transaction."]}],[{"l":"getAddress","p":["Returns the Bitcoin address."]},{"l":"Type"},{"l":"Return Value","p":["A string encoded Bitcoin address."]},{"l":"Syntax"},{"l":"Examples","p":["By default the address is pay-to-pubkey-hash (p2pkh).","You can configure the Computer object to use pay-to-witness-pubkey-hash (p2wpkh) by setting the addressType in the constructor.","You can also use pay-to-taproot (p2tr)."]}],[{"l":"getBalance","p":["Returns the balance in satoshi."]},{"l":"Type"},{"l":"Return Value","p":["The current balance in Satoshi."]},{"l":"Description","p":["Returns the confirmed balance in Satoshi, the unconfirmed balance, and the total balance in satoshi."]},{"l":"Example"}],[{"l":"getChain","p":["Returns the chain."]},{"l":"Type","p":["* BCH and DOGE support coming soon"]},{"l":"Return Value","p":["Returns a string encoding the chain."]},{"l":"Example"}],[{"l":"getMnemonic","p":["Returns the mnemonic"]},{"l":"Type"},{"l":"Return Value","p":["A string encoding a BIP39 mnemonic."]},{"l":"Description","p":["You can set the mnemonic in the constructor of the Computer class. The mnemonic needs to have at least 12 words, otherwise an error is thrown. If the mnemonic property is left undefined a random mnemonic will be generated using the generateMnemonic of the bip39 library."]},{"l":"Example"}],[{"l":"getNetwork","p":["Returns the network."]},{"l":"Type"},{"l":"Return Value","p":["Returns a string encoding the network."]},{"l":"Example"}],[{"l":"getPassphrase","p":["Returns the passphrase."]},{"l":"Type"},{"l":"Return Value","p":["The passphrase."]},{"l":"Description","p":["The passphrase can be set in the Computer constructor. It defaults to an empty string."]},{"l":"Examples","p":["The passphrase defaults to the empty string","You can set a passphrase by passing it into the constructor."]}],[{"l":"getPrivateKey","p":["Returns a string encoded private key."]},{"l":"Type"},{"l":"Return Value","p":["Returns a string encoded BIP32 private key."]},{"l":"Example"}],[{"l":"getPublicKey","p":["Returns a string encoding a public key."]},{"l":"Type"},{"l":"Return Value","p":["A string encoding BIP32 public key."]},{"l":"Example"}],[{"l":"getUtxos","p":["Returns UTXOs that do not contains on-chain objects."]},{"l":"Type"},{"l":"Parameters"},{"l":"address","p":["The address for which to return the UTXOs. If undefined, the UTXOs for the calling object are returned."]},{"l":"Return Value","p":["Returns all unspent transaction outputs (UTXOs) of the address in question. The UTXOs are formatted as strings of the form transaction-id:output-number"]},{"l":"Description","p":["The UTXOs returned are guaranteed to not contain any on-chain objects. This makes it possible to ensure to not spend on-chain objects by mistake."]},{"l":"Examples","p":["The first example shows that getUtxos returns all UTXOs that do not contains on-chain objects.","The second example shows that getUtxos does not return UTXOs that contain on-chain objects."]}],[{"l":"getVersion","p":["Returns the current version."]},{"l":"Type"},{"l":"Return Value","p":["The current version"]},{"l":"Example"}],[{"l":"load","p":["Loads a module from the blockchain."]},{"l":"Type"},{"l":"Parameters"},{"l":"rev","p":["A module specifier encoded as a string of the form transaction-id:output-number."]},{"l":"Return Value","p":["A JavaScript module."]},{"l":"Example"}],[{"l":"new","p":["Creates an on-chain object."]},{"l":"Type"},{"l":"Parameters"},{"l":"constructor","p":["A named JavaScript class T."]},{"l":"args","p":["Arguments to the constructor of the class T."]},{"l":"mod","p":["Optionally, a string of the for transaction-id:output-number that references a module."]},{"l":"Return Value","p":["If T or one of its sub-objects does not extend from Contract an error is thrown. Otherwise it returns an on-chain object of class T. The objectk has all the properties specified in T and in addition the properties _id, _rev, _root, _owners, and _amount. If the constructor defined properties _url or _readers they must have the types as indicated above."]},{"l":"Description","p":["The new function can create on-chain objects. The creation of a smart object is recorded in a transaction on the blockchain (see here for more details on how it works). Once an on-chain object is created its properties can only be updated through function calls. Every time a function is called, a transaction is broadcast that records the function call on the blockchain. For this reason it is necessary to await on all function calls on an on-chain object. Multiple users can sync to the same smart object to get consensus over its state.","On-chain objects can be freely combines: you can pass an on-chain object as a parameter into a constructor or function call."]},{"l":"Examples","p":["The example shows how an on-chain object is created and updated."]}],[{"l":"next","p":["Returns the next revision of a given revision if it exists."]},{"l":"Type"},{"l":"Parameters"},{"l":"rev","p":["A revision encoded as a string of the form transaction-id:output-number."]},{"l":"Return Value","p":["The next revision or undefined."]},{"l":"Description","p":["Given the revision of an on-chain object, the function returns the next revision of the same on-chain object. If no such revision exists because the revision passed in is a latest revision, undefined is returned."]},{"l":"Example"}],[{"l":"prev","p":["Returns the previous revision of a given revision if it exists."]},{"l":"Type"},{"l":"Parameters"},{"l":"rev","p":["A revision encoded as a string of the form transaction-id:output-number."]},{"l":"Return Value","p":["The previous revision or undefined."]},{"l":"Description","p":["Given the revision of an on-chain object, the function returns the previous revision of the same on-chain object. If no such revision exists because the revision passed in is the revision where the on-chain object was created, undefined is returned."]},{"l":"Example"}],[{"l":"query","p":["Returns the latest revisions of on-chain objects."]},{"l":"Type"},{"l":"Parameters"},{"l":"args","p":["An object with the query parameters.","Key","Description","publicKey","Return latest revisions of on-chain objects owned by a public key","ids","Return latest revision of on-chain objects with ids in order","mod","Return the latest revision of on-chain objects created with this module specifier","limit","Limit the number of revisions returned","offset","Return results starting from offset","order","Order results in ascending or descending order"]},{"l":"Return Value","p":["Given the query parameters, returns an array of strings encoding the latest revisions of on-chain objects that matches the specified conditions."]},{"l":"Description","p":["The args object specifies the on-chain objects of which to return the latest revisions. One can either query by public key to obtain the latests revisions of objects currently owned by that public key","Conditions can be passed in to determine the on-chain objects. When multiple conditions are passed in, the latest revisions of the on-chain objects that satisfy all conditions are returned."]},{"l":"Example"}],[{"l":"rpcCall","p":["Calls a Bitcoin RPC method with the given parameters."]},{"l":"Type"},{"l":"Parameters"},{"l":"method","p":["An string encoding the name of the rpc function to be called."]},{"l":"params","p":["An string with the argument list of the rpc function call to be called, separated by spaces."]},{"l":"Return Value","p":["A JSON object with the result of the rpc method call."]},{"l":"Examples","p":["getBlockchainInfo returns information about the status of the blockchain.","getRawTransaction returns information about the transaction.","getTxOut returns information about an output.","generateToAddress mines a block to a specific address (only available on regtest)."]}],[{"l":"send","p":["Sends a payment."]},{"l":"Type"},{"l":"Parameters"},{"l":"amount","p":["A number representing the amount of satoshis to be sent."]},{"l":"address","p":["An string encoding the receiver address."]},{"l":"Return Value","p":["If successful, it returns the id of the transaction broadcast."]},{"l":"Example"}],[{"l":"sign","p":["Signs a Bitcoin transaction."]},{"l":"Type"},{"l":"Parameters"},{"l":"tx","p":["A Bitcoin transaction, possibly partially signed."]},{"l":"opts","p":["The opts object can have the following properties:","Key","Type","Description","inputIndex","number","The input index to be signed","sighashType","A valid sighash type number","inputScript","Buffer","A buffer encoding the signature"]},{"l":"Return Value","p":["The function returns void."]},{"l":"Description","p":["By default, the sign function will make a best effort to sign all inputs, but will not throw an error if the signature cannot be added due to hash mismatch.","This is useful in the case of partially signed transactions, where a user can encode an expression, sign with the user private key and send the generated partially signed transaction to another user. Then, the receiver can sign other inputs."]},{"l":"Examples"}],[{"l":"subscribe","p":["Calls a callback when an on-chain object is updated."]},{"l":"Type"},{"l":"Parameters"},{"l":"id","p":["The id of an on-chain object."]},{"l":"onMessage","p":["The function to call when the object is updated. The callback has two parameters, the new revision of the object and the hex of the transaction encoding the update."]},{"l":"onError","p":["The function to call when an error is thrown."]},{"l":"Return Value","p":["A function to close the connection to the server."]},{"l":"Description","p":["The function enables real-time updates via Server-Sent Events (SSEs). The function takes an on-chain ID and a callback function as arguments. The callback is triggered whenever a method is called on the on-chain object with the specified ID."]},{"l":"Example"}],[{"l":"sync","p":["Returns smart objects given a location on the blockchain."]},{"l":"Type"},{"l":"Parameters"},{"l":"location","p":["The location can either be","a revision encoded as transaction-id:output-number","a transaction id"]},{"l":"Return Value","p":["If the argument is a revision the return value is the on-chain object with the specified revision.","If the argument is a transaction id, the return value is an object { res, env } where","res is the result of evaluating the expression on the transaction with the given id and","env is an object that has the same keys as the blockchain environment of the transaction, but the values are on-chain objects after the expression is evaluated.","If the parameter is not a valid revision or transaction id, an error is thrown."]},{"l":"Description","p":["If the function is called with a revision, it returns the smart object stored at the provided revision. Note that the revision must not be a latest revision. In that case a historical state of the revision is returned.","If the function is called with a transaction id, it returns an object of type { res: Json; env: Json }. The value of res is the result of evaluating the expression inscribed into the transaction. The env object has the same keys as the blockchain environment of the transaction, the values of env are the smart objects at these revisions after evaluating the expression."]},{"l":"Example"}],[{"l":"Contract","p":["The Contract class allows you to create objects whose properties can only be updated through its methods. This enables the development of smart contracts in JavaScript. For details, please see here.","If a class C extends from Contract and if c is an instance of C then an error is thrown if","a property of c is created, updated or deleted outside of a method of c","a property _id, _rev or _root of c is created, updated, or deleted.","In order to provide the two guarantees above we also need to forbid assigning to this inside of constructors. Instead, an object can be passed into super to initialize an object."]},{"l":"Examples"},{"l":"Updating Properties Outside of Methods"},{"i":"updating-_id-_rev-or-_root","l":"Updating _id, _rev or _root"},{"l":"Using the Initialization Object"}],[{"l":"Mock","p":["Mocking is a technique for spending objects that are associated with Bitcoin Computer transactions that have not been broadcast yet. This is required for advanced applications like swaps and for using smart contracts over payment channels (see here for more information).","A mocked object is an object that has _id, _rev and _root set to strings of the form mock-${hex}:${num} where hex is a string of 64 hexadecimal characters and num is a number. The Bitcoin Computer library exports a class Mock to make it easy to create a mock."]},{"l":"Example"}],[{"l":"Transaction","p":["The Transaction class exported from @bitcoin-computer/lib extends the Transaction class exported from @bitcoin-computer/nakamotojs and therefore has all of its properties and methods (see here).","In addition it has methods and properties related to the Bitcoin Computer protocol, as well as convenience methods for developing Bitcoin-based applications."]},{"l":"Properties"},{"l":"inRevs","p":["Returns the revisions of on-chain objects spent by the transaction."]},{"l":"outRevs","p":["Returns the revisions of on-chain objects created by the transaction."]},{"l":"Methods"},{"l":"fromTxId","p":["Returns a Transaction object from a transaction id."]},{"l":"onChainMetaData","p":["Returns a Transaction object from a transaction buffer."]},{"l":"Example"}],[{"l":"Node"},{"l":"Prerequisites","p":["You need to have git, node.js and docker installed."]},{"l":"Installation"},{"l":"Usage"},{"l":"Start the Node","p":["To start your node at http://localhost:1031 run the commands below. The node is ready once the log activity subsides. On regtest this will take a few minutes, on mainnet and testnet it can take days or even weeks, depending on your hardware.","The node will create the docker volumes in the packages/node/chain-setup/** directory of the selected chain and network. This folder contains the blockchain data and the database. The postgres database is used to efficiently store the complete blockchain data, for fast access and indexing."]},{"l":"Run the Tests","p":["You can run the integration tests with the command below.","On Litecoin regtest, the halving period is set to infinity. This makes it possible to run a large number of tests without having to restart the node."]},{"l":"Fund the Wallet","p":["In regtest mode, you can fund a wallet with the following commands."]},{"l":"Stop the Node","p":["You can stop the node with the command below. When you restart the process, it will resume from the last block processed."]},{"l":"Reset the Node","p":["The command below will reset the database, delete all blockchain data, and stop all docker containers."]},{"l":"Configuration","p":["You can configure several options by editing the .env file."]},{"l":"Client Side Library","p":["The Bitcoin Computer Library can connect to a Bitcoin Computer Node to provides access to its functionality.","If you do not specify a url property it will default to the url below. The node at that url runs Litecoin on regtest network mode and uses the latest version of the Bitcoin Computer Node software."]},{"l":"Api","p":["The Bitcoin Computer Node exposes an API that can be used to interact with the node. The variables CHAIN and NETWORK are used to define the chain and network that the node is running on."]},{"l":"Wallet","p":["Method","Description","balance","Get the balance of a wallet.","list-txs","List sent and received transactions for a given address.","sent-outputs","List sent outputs of a wallet.","received-outputs","List received outputs of a wallet.","utxos","List unspent outputs of a wallet."]},{"l":"Transactions","p":["Method","Description","ancestors","Get the ancestors of a transaction.","bulk","Get raw transactions for a list of transaction ids.","json","Get a transaction in json format.","post","Post a transaction to the Bitcoin network."]},{"l":"Blockchain","p":["Method","Description","height","Get the height of an specific block.","mine","Mine an specific number of blocks to a random address.","rpc","Call a Bitcoin RPC method."]},{"l":"Regtest Faucet","p":["Method","Description","faucet","Get coins from the faucet.","faucetScript","Get coins from the faucet using a script."]},{"l":"Query revisions","p":["Method","Description","next","Get the next revision of a given revision.","prev","Get the previous revision of a given revision.","non-standard-utxos","Query revisions by module specifier, public key, limit, order, offset and list of transaction ids.","revs","Get the revisions of a list of transactions.","revToId","Given a revision, get the id of the smart contract."]},{"l":"OffChain","p":["Method","Description","id","Get the data stored in the offchain storage.","store","Stores the hex of the data in the offchain storage."]},{"l":"Versioning","p":["If you run your own node, make sure to use the same versions of Lib and Node."]}],[{"l":"ancestors","p":["Returns an array of transaction ids for all transaction that the on-chain object at the given transaction if depends on."]},{"l":"Description","p":["An on-chain object o depends on a transaction tx if tx is a Bitcoin Computer transaction labelled with an expression exp and exp needs to be evaluated in order to compute the the value of o. The endpoint returns all ids of such transactions."]},{"l":"Endpoint","p":["/v1/CHAIN/NETWORK/tx/:txId/ancestors"]},{"l":"Example"},{"l":"Request"},{"l":"Response"}],[{"l":"balance","p":["Returns the balance of a given address."]},{"l":"Description","p":["Returns the confirmed, unconfirmed and total balance."]},{"l":"Endpoint","p":["/v1/CHAIN/NETWORK/address/:address/balance"]},{"l":"Example"},{"l":"Request"},{"l":"Response"}],[{"l":"bulk","p":["Returns the raw transaction hexes for a given list of transaction ids."]},{"l":"Endpoint","p":["/v1/CHAIN/NETWORK/tx/bulk"]},{"l":"Example"},{"l":"Request"},{"l":"Response"}],[{"l":"id","p":["Get the data stored in the off-chain storage."]},{"l":"Endpoint","p":["/v1/store/:id"]},{"l":"Example"},{"l":"Request"},{"l":"Response"}],[{"l":"json","p":["Returns the JSON representation of a given transaction."]},{"l":"Endpoint","p":["/v1/CHAIN/NETWORK/tx/:txId/json"]},{"l":"Example"},{"l":"Request"},{"l":"Response"}],[{"l":"list-txs","p":["Returns the sent and received transactions for a given address."]},{"l":"Endpoint","p":["/v1/CHAIN/NETWORK/wallet/:address/list-txs"]},{"l":"Example"},{"l":"Request"},{"l":"Response"}],[{"l":"next","p":["Get the next revision of a given revision."]},{"l":"Endpoint","p":["/v1/CHAIN/NETWORK/next/:rev"]},{"l":"Example"},{"l":"Request"},{"l":"Response"}],[{"l":"non-standard-utxos","p":["Query revisions by module specifier, public key, limit, order, offset and list of transaction ids."]},{"l":"Endpoint","p":["/v1/CHAIN/NETWORK/non-standard-utxos"]},{"l":"Example"},{"l":"Requests"},{"l":"Response"}],[{"l":"post","p":["Posts a raw transaction to the network and returns its transaction ID."]},{"l":"Endpoint","p":["/v1/CHAIN/NETWORK/tx/post"]},{"l":"Example"},{"l":"Request"},{"l":"Response"}],[{"l":"prev","p":["Get the previous revision of a given revision."]},{"l":"Endpoint","p":["/v1/CHAIN/NETWORK/prev/:rev"]},{"l":"Example"},{"l":"Request"},{"l":"Response"}],[{"l":"received-outputs","p":["Returns the outputs that were received by a given address."]},{"l":"Endpoint","p":["/v1/CHAIN/NETWORK/wallet/:address/received-outputs"]},{"l":"Example"},{"l":"Request"},{"l":"Response"}],[{"l":"revs","p":["Get the revisions of a list of transactions."]},{"l":"Endpoint","p":["/v1/CHAIN/NETWORK/revs"]},{"l":"Exampls"},{"l":"Request"},{"l":"Response"}],[{"l":"revToId","p":["Given a revision, returns the id of the smart contract."]},{"l":"Endpoint","p":["/v1/CHAIN/NETWORK/rev/:revToId"]},{"l":"Example"},{"l":"Request"},{"l":"Response"}],[{"l":"rpc","p":["Call a Bitcoin RPC method."]},{"l":"Endpoint","p":["/v1/CHAIN/NETWORK/rpc"]},{"l":"Example"},{"l":"Request"},{"l":"Response"}],[{"l":"sent-outputs","p":["Returns the outputs that were sent from a given address."]},{"l":"Endpooint","p":["/v1/CHAIN/NETWORK/wallet/:address/sent-outputs"]},{"l":"Example"},{"l":"Request"},{"l":"Response"}],[{"l":"store","p":["Stores the hex of the data in the offchain storage."]},{"l":"Endpoint","p":["/v1/store"]},{"l":"Example"},{"l":"Request"}],[{"l":"utxos","p":["Returns the UTXOs for a given address."]},{"l":"Endpoint","p":["/v1/CHAIN/NETWORK/wallet/:address/utxos"]},{"l":"Example"},{"l":"Request"},{"l":"Response"}],[{"l":"NakamotoJS","p":["NakamotoJS is available on Github here.","Documentation coming soon"]}],[{"l":"Apps","p":["The following are examples of open source applications builded with the Bitcoin Computer. They are all published under MIT licence so you can clone, copy, modify, contribute or use them as a starting point for you project."]},{"l":"Wallet","p":["Non custodial, open source wallet for Bitcoin and Litecoin. You can send cryptocurrency to a friend and see your balance, and the transactions sent and received.","wallet.bitcoincomputer.io"]},{"l":"Explorer","p":["Bitcoin Computer Explorer. You can explore all objects created, or log in to update your smart objects using the UI. Use the playground to create any smart contract you can imagine!","explorer.bitcoincomputer.io"]},{"l":"Non Fungible Token","p":["You can mint an NFT and trustless list it for sale. You also can see your own NFTs or buy any NFT listed.","nft.bitcoincomputer.io"]}],[{"l":"Examples","p":["Method","Description","Non Fungible Token (NFT)","A non fungible token similar to ERC721","Fungible Token","A fungible token similar to ERC20","Encrypted Chat","An encrypted chat","Swap","Trustlessly exchange two smart object","Sale","Trustlessly sell a smart object to an unknown buyer","Ordinal Sale","Trustlessly sell an ordinal to an unknown buyer"]}],[{"l":"Non Fungible Token"},{"l":"Smart Contract","p":["A smart contract for an NFT is a class with two properties and one function to update the _owners property."]},{"l":"Usage","p":["To create an on-chain object of class NFT, you can use the new function of the Computer class. The faucet function funds the sender object on regtest. The sender.new function mints a new NFT and the transfer function send the NFT to another user.","The transaction that is broadcast when sender.new is called contains the expression below."]},{"l":"The Module System","p":["If many NFTs are created, it is wasteful to store the same JavaScript class in the blockchain multiple times. In this case, it is possible to use the module system to store the smart contract one time and refer to it multiple times.","In this case, each transaction encoding the minting of an NFT contains the module specifier (a transaction id and an output number) and the following expression."]},{"l":"Code","p":["You can find a slightly more elaborate implementation here."]}],[{"l":"Fungible Token"},{"l":"Smart Contract","p":["A fungible token is stored and transferred in a similar way to how satoshis are stored and transferred in Bitcoin. Its current state is stored in a set of UTXOs. When tokens are transferred a utxo is spent and two new UTXOs are created: one containing the amount sent and one containing the change.","The transfer function checks if the current on-chain object contains a sufficient number of tokens and throws an error if not. If sufficient, the supply of the current on-chain object is reduced by the amount to be sent. A new on-chain object, owned by the recipient and containing the sent amount, is created and returned."]},{"l":"Usage","p":["The usage is as in the case of a non-fungible token."]},{"l":"Code","p":["You can find the code here."]}],[{"l":"Chat"},{"l":"Smart Contract","p":["The smart contract below creates a chat that can be initialized with an array of participants. All messages are encrypted so that only the members can read the messages. It is not possible to add a new participant, but any current participant can remove another participant from the chat."]},{"l":"Usage","p":["A new chat can be created using the new function. Note that Bob can initially post to the chat and read it's state as Bob's public key was added by Alice to the _owners array and to the _readers array upon creation of the chat.","Later, Alice called the remove function removing Bob's public key from these arrays. After this point Bob cannot read or write anymore."]},{"l":"Code","p":["You can find the code here."]}],[{"l":"Token Swap","p":["In this section we explain how to exchange to on-chain objects atomically. This means that either both assets change their owner or none of them.","A token swap is similar to an atomic swap, the difference being that atomic swaps usually refer to the exchange of cryptocurrency on two different chains, whereas token swaps exchange tokens on the same chain.","We note that the definition of a token swap differs wildly from the legal definition of a swap. While a token swap is the immediate exchange of two on-chain objects, a swap in the legal sense involves an option to buy or sell an asset in the future.","This code preserves ordinal ranges and is safe to use this in smart objects that contain ordinals."]},{"l":"Smart Contract","p":["You can build a swap as a static function that takes two arguments and exchanges their owners."]},{"l":"Usage"},{"l":"Minting the NFTs","p":["Alice and Bob mint NFTs using the computer.new function."]},{"l":"Building the Swap Transaction","p":["Alice can create a swap transaction as shown below. Such a transaction has two inputs and two outputs. The inputs spend the NFTs to be swapped. The outputs are the NFTs after the swap with their owners exchanged.","The encode function signs all inputs that can be signed with the private key of the object on which the function is called. In this case, this is the input that spends revision a._rev."]},{"l":"Checking the Transaction","p":["When Bob receives the transaction, he can decode it and inspect the state that would emerge on chain if he were to sign and broadcast the transaction."]},{"l":"Executing the Swap","p":["If Bob is happy with the transaction, he can execute the swap by signing and broadcasting the transaction."]},{"l":"Full Example","p":["The code snippet below shows how to create two nfts and swap them using the smart contract above."]},{"l":"Code","p":["Have a look at the code on Github for details."]}],[{"l":"Sale","p":["We explain how to sell a smart object to an unknown buyer atomically. Whereas both objects are known in advance in a swap, the output containing the payment that Buyer will use in the sale is unknown when Seller is building the swap transaction. Seller builds a partial transaction consisting of only one input for the asset and one output for the payment to be received. Buyer can later add an input for the payment and an output for the asset after the sale.","These examples use several advanced features (sighash types, mocking, and controlling the order of inputs and outputs, ordinal safe programming) that are not sufficiently documented elsewhere. If you would like to use these features we suggest to ask about their safe use here.","This code is not safe to use with ordinals. A slightly more complicated version that works for ordinals is described here."]},{"l":"Smart Contract","p":["Seller builds a partial transaction containing an input spending the asset and an output for receiving the payment. The sighash type SIGHASH_SINGLE | SIGHASH_ANYONECANPAY allows Seller to sign only the first input and output.","Buyer wants to obtain the smart object in the first input so Buyer is incentivized to build the transaction according to the protocol. If he broadcasts a transaction that is invalid in the Bitcoin Computer protocol, Buyer destroys the smart object but still pays the Seller.","We call this transaction described above the \"crossover\" transaction because the asset passes from the first input to the second output and the payment passes from the second input to the first output. In order to build it with the Bitcoin Computer, one needs to take into account that the order of inputs is determined by the order of objects in the environment and the order of outputs is determined by the order of objects in the value returned from the expression.","Seller uses an environment { nft: ..., payment: ... }, indicating that the first input will spend nft and the second input will spend payment. As the exec function returns an array [payment, nft] the first output represents the payment and the second output represent the nft. This is exactly the \"crossover\" transaction described above."]},{"l":"Usage"},{"l":"Mocking the Payment Object","p":["The challenge in creating the sales transaction arises from the fact that the output containing the payment is not yet created at the time of building the transaction. To handle such scenarios the Bitcoin Computer provides a feature called mocking. A mock is a class that has the properties _id, _rev, _root, _amount, and _owners, and sets them to strings of the form mock-transaction-id:output-number. A mock does not have to extend from Contract. Each mocked object must have a distinct transaction id and output number.","The following code shows the class to create the payment mock as well as Seller creating a new instance with the standard JavaScript new keyword."]},{"l":"Building the Sales Transaction","p":["Seller can create and sign the partial sale transaction using the code below.","The expression contains the Sale class and an expression that calls the static exec function.","The next two lines contain the instructions for the mocking system. Seller can use the mock object that was created earlier as shown below. The revision of the mock is passed in as the payment revision to the environment; and an object is passed to the mocks key that maps the name payment to the mock object. If an object is mocked up, the Bitcoin Computer will build a transaction assuming that the output spent is associated with the value provided by the mock. Later buyer will update the input that spends the revision of the payment mock with the revision and output number of an actual payment.","To enable Buyer to modify Seller's transaction later, Seller signs the first input with the sighash type SIGHASH_SINGLE | SIGHASH_ANYONECANPAY. This means that Seller's signature remains valid even when arbitrary inputs and outputs are added to the transaction as long as the input and the output that Seller has signed have the same index. This guarantees that any transaction that contains the input that spends Sellers NFT will also contain the output that pays Seller. This guarantees that Seller gets paid. Intuitively speaking, the Seller is stating: \"you can spend the output containing the NFT as long as you include the output that pays me the correct amount\".","Finally, Seller set's funding to false so that Buyer covers the transaction fees.","Seller can publish the sales transaction without any risk. An interested buyer can create a payment object and complete and broadcast the sale transaction to purchase the nft. This is described in the next section."]},{"l":"Buying the NFT","p":["First, Buyer creates a smart object to pay for the nft.","Next, Buyer updates the second input of the transaction that currently points to the revision of the payment mock.","Then Buyer updates the second output to contain Buyer's public key. This ensures that Buyer will be new owner of the nft.","Finally Buyer funds, signs, and broadcasts to execute the sale."]},{"l":"Full Example","p":["The code below shows the whole process of minting an nft, listing it for sale, and a purchase. Working code can be found here"]},{"l":"Code","p":["You can find the code here."]}],[{"l":"Ordinal Sale","p":["The Sale smart contract is not safe to use with ordinals because the smart objects have different ordinal ranges before and after the call. To preserve the ordinal ranges the expression must not use the _amount keyword and must not return an object or an array containing an object.","Building a sale contract for ordinals is more complicated than for smart objects. A very clever construction was proposed here and later refined. Our smart contract below implements this exact idea.","This code preserves ordinal ranges and is safe to use this in smart objects that contain ordinals."]},{"l":"Smart Contract","p":["The exec function of the OrdSale class swaps the owners just like in the Sale class. However it then proceeds to double the amount of b1 and return [b1, t, p, b2].","When the exec function is evaluated, a transaction of the following form is built:","The amount of b1 after the call is the sum of the amounts of b1 and b2 before combined. The smart object b1 therefore absorbs the entire ordinals range of b2. The objects n and p do not change their amounts during the call, these objects preserve their ordinal ranges.","We now explain the whole process of minting an NFT, listing it for sale, and processing a purchase. We skip the step for minting as it was described above."]},{"l":"Usage"},{"l":"Building the Sales Transaction","p":["In order to build the sale transaction, Seller first needs to create the objects b1, b2, and p:","Next Seller can build the sales transaction by executing the following code:","Conceptually this is very similar to the use of encode above. Note however, that Seller signs the third input output pair this time. This is because the NFT is spent by the third input and the payment that Seller wants to obtain is in the third output."]},{"l":"Buying the Ordinal NFT","p":["This process is similar to the case of a smart object sale above. See the example blow."]},{"l":"Full Example"},{"l":"Code","p":["You can find the code here."]}],[{"l":"Comparison","p":["We explain how smart contract systems for Bitcoin work in simple terms. We then compare the Bitcoin Computer to other systems according to the following properties:","Trustlessness. We call a system trustless if no trusted third party is required for its operation. Trustlessness is the main point of the entire crypto endeavour as Satoshi pointed out in the second sentence of the Bitcoin white paper: \"the main benefits are lost if a trusted third party is still required\".","Expressiveness. A system is expressive if it can express all computable smart contracts, formally if it is Turing Complete. Assets created in such general purpose protocols can be freely composed and moved between applications.","Efficiency. A system is efficient if it is possible to compute some smart contract data without having to parse all transactions in the blockchain. This is important for two reasons: the obvious one is that it is faster to compute some values. The other is that it is possible to compute values in parallel.","This writeup is based on a presentation we gave at the Litecoin Summit in 2024. You can find the slides here and a video recording here."]},{"l":"Results","p":["-","Bitcoin","Bitcoin Computer","Channels","Efficient","Ethereum","Expressive","Interoperable","No","Order based","Rollup","Sidechain","The table below captures the results of our comparison. Each result is explained in detail in the following sections.","Trustless","UTXO based","Yes"]},{"l":"Blockchains","p":["For context we briefly discuss to what extent Bitcoin and Ethereum have the three properties we are interested in."]},{"l":"Bitcoin","p":["Bitcoin is a trustless peer-to-peer currency. We will assume familiarity with the basic working of Bitcoin and focus on the three properties from above.","Bitcoin is assumed to be trustless as long as a majority of the hash power is honest. However it is not expressive as it only supports one application: a currency. It is also not efficient as one needs to validate all transactions and check the proof of work of every block in order to determine if the amount in an output is unspent and the transaction containing the output is valid."]},{"l":"Ethereum","p":["Ethereum is the first blockchain to popularize general purpose smart contracts. It assumed to be trustless as longs as a majority of the staked cryptocurrency is owned by honest validators. In addition it is expressive due to its native smart contract support. However, it is not efficient: to determine the storage of one address, a full node needs to synchronize with the entire blockchain, validating all transactions and computing all smart contract invocations."]},{"l":"State Channels and Networks","p":["State channels, originally designed to reduce fees, have recently found applications in smart contract systems. They allow two parties to conduct transactions off-chain with only the final agreed-upon state recorded on the blockchain. Two parties can send payments back and forth an unlimited number of times at a constant cost. However the fee reduction is less pronounced for unidirectional payments.","While state channels work well between two users, they do not scale to a large number of users, because creating channels between all users quickly becomes uneconomical. To address this shortcoming, channel networks have been developed. These use smart contracts called Hashed-Timelock-Contracts (HTLCs) to create chains of channels that securely forward payments, ensuring that intermediate nodes cannot steal funds. This enables efficient hub-and-spoke architectures where a central hub forwards payments between users. One downside is the existence of a central point of failure in the form of the hub; another is that users need to be online to receive payments securely."]},{"l":"Examples","p":["The Lightning Network extends the hub-and-spoke model to a decentralized network of payment channels. The key challenge is to solve the routing problem: to send a payment between two users, a path of channels must be determined where each channel has sufficient liquidity to forward the payment. To determine such a path, users must have up to date knowledge of the balances of all channels. If a user's knowledge of channel balances is outdated, the payment can fail.","Watchtowers allow users to accept payments whilst offline. These are third party services that monitor end users' channels for suspicious activity and react accordingly. The downside is that this introduces a trusted third party. More info","The ARK protocol is a layer-two solution designed for off-chain Bitcoin transactions, aiming to provide a low-cost, setup-free payment system. ARK relies on trusted intermediaries called ARK Service Providers (ASPs) to manage shared UTXOs. In ARK, transactions are conducted using virtual UTXOs (VTXOs), which are off-chain transaction outputs that can be converted into on-chain UTXOs when needed. Payments within ARK are coordinated by the ASPs through periodic \"rounds,\" where users exchange their VTXOs for new ones off-chain. Additionally, ARK offers \"out-of-round\" payments for faster, direct transactions between parties. More info","The RGB protocol enables smart contracts. All meta data is stored offline, which lowers availability guarantees. RGB uses transaction outputs as \"single-use seals\" that ensure that only the owner can modify the contract state. RGB uses specially-designed virtual machine called AluVM, which is is nearly computationally universal, but with a bounded by number of operation steps, similar to in Ethereum-like systems. RGB has support for for enhanced privacy via a modified form of confidential transactions. RGB can operate over regular Bitcoin transactions and over the lightning network. More info","The Bitcoin Computer currently does not support channels networks. However we mention it here as an integration could be built in principal. The Bitcoin Computer will be further discussed here."]},{"l":"Evaluation","p":["Trustlessness. State channels and networks are trustless as long as users are online. When users are not online they need to trust watchtowers to keep user funds safe. Smart contract systems that rely on channel networks inherit these properties.","Expressiveness. Most channel networks are geared towards payments, therefor they cannot express smart contracts. However some smart contract protocols can integrate with state channels, in which case all smart contracts of the respective protocol can be expressed.","Efficiency. Our definition of efficiency only makes sense for smart contract systems, so this property does not apply to payment networks."]},{"l":"Interoperable Blockchains","p":["An interoperable blockchain is a separate blockchain that connects to Bitcoin in various ways. In most cases smart contracts of the interoperable blockchain can read and write transaction from and to Bitcoin. In some cases, Bitcoin is used in the consensus of the interoperable blockchain."]},{"i":"examples-1","l":"Examples","p":["Stacks enables smart contracts that use Bitcoin as an asset in a trust-minimized way. It has its own native asset called STX. The Stacks blockchain relies on STX and BTC for its consensus mechanism called Proof of Transfer (PoX). Stacks miners bid by spending BTC, and their probability of mining the next block on the STX chain is proportional to the amount bid. This amount is paid to STX holders that lock up or \"stack\" their STX. As a consequence the price ratio between BTC and STX is continually recorded and available on-chain. Stacks's smart contract language is a non-Turing complete language called Clarity. More info","Todo. More info"]},{"i":"evaluation-1","l":"Evaluation","p":["Trustlessness. Interoperable blockchains are as trustless as the blockchain that is connected to Bitcoin.","Expressiveness. Typically, all smart contract systems can be expressed.","Efficiency. Interoperable blockchains that support smart contracts are typically based on the account model like Ethereum and are therefore not efficient."]},{"l":"Sidechains","p":["A sidechain is a separate blockchain linked to Bitcoin through a two-way peg.","A user sends their Bitcoin to a dedicated address controlled by the group of users that maintain the peg. These users then create the corresponding value of tokens on the sidechain. Those tokens can be used to access the functionality of the sidechain. Later, the sidechain user can transfer tokens back to the maintainers the peg, who will hopefully send the corresponding amount of tokens back to the sidechain user.","Two-way pegs can be centralized, federation-based, or SPV-based. In centralized two-way pegs a trusted third party controls the Bitcoin in the peg and is responsible for locking and unlocking the Bitcoin. In a federated peg, the locked Bitcoins are at the custody of a group of users called the federation. A common implementation is to use a multisignature address, in which a quorum of participants is required to spend the funds. Simplified Payment Verification (SPV) makes it possible to verify the inclusion of a transaction in a blockchain without verifying the entire blockchain. A SPV two-way peg scheme could work as follows: The locked Bitcoin are stored in an output that can only be spent if an SPV proof is provided that a corresponding number of tokens have been burnt on the sidechain."]},{"i":"examples-2","l":"Examples","p":["Liquid Network is a federated sidechain, relying on the concept of strong federation. A strong federation consists of two independent entities: block signers and watchmen. Block signers maintain the consensus and advance the sidechain, while watchmen realize the cross-chain transactions by signing transactions on the mainchain using a multisignature scheme.","The members of the federation maintain the consensus of the sidechain by signing blocks in a round-robin fashion. The federation consists of large exchanges, financial institutions, and Bitcoin-focused companies but their identities are not public. Users trust that at least two-thirds of the federation is acting honestly to ensure security. Watchmen sign each block transferred between the mainchain and the sidechain on the mainchain using a multisignature scheme.","The sidechain Liquid is based on the Bitcoin codebase, however it has a 10x higher throughput due its block time of just one minute. Liquid supports the creation of on chain assets as well as enhanced privacy through confidential transactions. More info.","Rootstock (RSK) is a smart contract platform with a native token called Smart Bitcoin (RBTC) that is pegged 1:1 with Bitcoin (BTC) and is used to pay for gas when executing smart contracts on the RSK network. RSK is merge-mined with Bitcoin, meaning that RSK miners also mine Bitcoin but not vice versa.","RSK relies on a combination of a federated two-way peg and an SPV (Simplified Payment Verification) scheme. Users can send Bitcoin to the peg and they are issued RBTC on the RSK sidechain. Each transfer between the sidechain and the main chain requires a multi-signature by the RSK federation to complete the transferring process. Federation members use hardware security modules to protect their private keys and enforce transaction validation. More info"]},{"i":"evaluation-2","l":"Evaluation","p":["Both centralized and federation based sidechains have the disadvantage of introducing trusted third parties, arguably defeating the purpose of a blockchain solution. SPV based solutions have the advantage of being trustless, however users have to wait for lengthy confirmation periods. The second problem is that the consensus mechanism of the sidechain is typically less secure than Bitcoin's, making it the weakest link in the system and prone to attacks.","Trustlessness. Only for pure SPV based solutions. Expressiveness. If the sidechain uses the account model. Efficiency. No as the sidechain typically uses the account model."]},{"l":"Rollups","p":["A rollup is similar to a sidechain but (a) the federation is replaced by a smart contract and (b) transaction data is stored on the main chain instead of a separate blockchain. The rollup can have its own transaction format independent from the main chain and we will refer to these transactions as L2 transactions.","To use a rollup, a user deposits funds to the rollup smart contract on the main chain. These funds can then be used in L2 transactions. To use the rollup, a user sends a L2 transaction to a designated user called aggregator. Periodically, the aggregator selects a batch of L2 transactions, creates a main chain transaction and publishes it. This main chain transaction contains the L2 transactions in compressed form and the hash of the new state. The rollup’s smart contract on the main chain assures the aggregator posted the hash of the correct new state. There are different ways that this check occurs, optimistically or using zero knowledge proofs, as discussed below. When users wish to redeem their deposit, they transact with the rollup’s smart contract on the main chain and receive funds equal to the amount of their balance on the L2."]},{"l":"Optimistic Rollups","p":["In an optimistic rollup the aggregator posts the compressed L2 transactions and the hash of the new state to the main chain without any verification. A group of users called verifiers check that the new state matches the instructions in the L2 transactions. Verifiers can then publish a \"fraud proof\", claiming that the aggregator posted an incorrect hash.","To discourage aggregators and verifiers from acting maliciously, both the aggregator and verifier need to stake a bond. If the verifier can provide a valid fraud proof, the verifier earns half of the aggregator’s bond while the other half is burned (this is to prevent a scenario where a malicious aggregator tries to front-run an honest validator by publishing another fraud proof). If the fraud proof is invalid, the verifier gets fined."]},{"l":"Zero-knowledge Rollups","p":["While optimistic rollups use fraud proofs, zero-knowledge (ZK) rollups, and validity rollups more generally, use validity proofs. Instead of allowing the aggregator to publish a transaction and then question it, in ZK rollups, the aggregator must prove that the state hash is the correct using a validity proof.","Similarly to optimistic rollups, an aggregator (sometimes called sequencer) evaluates L2 transactions and published compressed transaction data and the new state hash to the main chain. However they add a ZK proof that is evaluated by a smart contract on the main chain. The smart contract ensures that only correct executions are recorded on the main chain. In contrast to optimistic rollups, ZK rollups do not require second layer verifiers and there is no dispute resolution. This means transactions achieve finality rapidly; there is no extended period of time where verifiers can trigger a dispute phase.","The two most commonly used ZK proofs used for rollups are called SNARKs and STARKs. SNARKs are computationally efficient: the time needed to verify a SNARK grows slower than the time of the computation itself. However, they require a trusted setup. STARKs require no trusted setup, but require much more time for proof generation and verification."]},{"i":"examples-3","l":"Examples","p":["BitVM is an optimistic rollup. Its primary purpose is facilitating trust minimized bridges between Bitcoin and other chains.","A federation of 1000 members engage in a trusted setup and users trust that at least 1 participant is honest, otherwise the federation can steal all funds. Peg-ins can be censored by any federation member as a peg in requires the collaboration of all federation members. In addition all federation members need to pre-sign 100 peg-out transactions each (100.000 transactions in total), therefore peg-ins only occur every 6 months.","There are 100 operators and users trust that at least one online operator is honest, otherwise the user can be prevented from pegging out. Operators must be able to front the money for a peg out for two weeks, so only well capitalized institutions can be operators. Withdraws can take months to give validators the chance to go through the challenge process. Any user can be a validator.","The transactions that are broadcast in the BitVM protocol","To \"peg in\", a user called Bob sends 100 Bitcoin to a n-of-n multisig address controlled by the federation. In exchange, the federation will issue Bob tokens on the destination blockchain. When Bob want's to \"peg out\", Bob signals his wish to the federation by burning tokens on the destination blockchain. Operators can front the 100 Bitcoin to Bob in a \"Peg Out\" transaction. The operator then broadcasts the \"kick-off\" transaction. If all goes well, and there is no dispute, the federation will broadcast the \"Take 1\" transaction that spends 100 Bitcoin to the operator.","In the case of a dispute, any validator will broadcast the \"Challenge\" transaction. Once this transaction is broadcast, the \"Take 1\" transaction cannot be spend anymore, as both transaction spend the same output (this is called a connector output). Once the \"Challenge\" transaction is broadcast the operator will broadcast the \"Assert\" transaction that breaks down the high level statement that the operator originally made, into smaller, easily disprovable statements. If any of these lower level statements are incorrect, any verifier can broadcast a \"Disprove\" transaction that points to the false statement by the operator. If no validator broadcasts a Disprove transaction, the operator can broadcast a \"Take 2\" transaction to regain control of the original 100 Bitcoin. More info here and here.","Todo. More info"]},{"i":"evaluation-3","l":"Evaluation","p":["Rollups rely on smart contracts on the main chain, therefore it is easier to make them trustless and practical on chains with strong native smart contract support like Ethereum. By understanding the properties of rollups on Ethereum, we can understand how rollups on Bitcoin can work in the best case.","On Ethereum rollups generally introduce trusted third parties, central points of failures, and lockup periods.","As building a validity proof requires heavy computations ZK rollups’ L2 fees are higher than optimistic rollups. Additionally, ZK rollup main chain transaction fees are higher as the validity proof needs to be validated on the main chain for every batch.","On the other hand, optimistic rollups have a period where verifiers have an opportunity to publish a fraud proof. Thus users need to wait (usually a week on Ethereum, on Bitcoin it will likely be longer) until their deposits can be withdrawn. In ZK-rollups, deposits could be withdrawn immediately, however in many cases users have to wait for 24h due to safety concerns. In most cases there is only one aggregator and a very small number of validators and users trust that they do not collude."]},{"l":"Complexity of SNARKs and STARKs","p":["A user of a meta protocol that wants to write smart contract data adds meta data to a transaction and sends it to the Bitcoin miners. Software that is specific to the protocol parses the meta data and computed smart contract data (like the number of tokens owned by a user) from it.","Efficiency. Depends on the efficiency of the L2.","Expressiveness. Depends on the expressiveness of the L2.","No","O(\\text{log}(n)^c)","O(1)","O(n \\cdot \\text{log}(n))","O(n \\cdot \\text{log}(n)^c)","Prover Complexity","Prover Complexity refers to the computational complexity associated with generating a proof for a given computation. Verifier Complexity refers to the computational complexity associated with verifying the correctness of a proof for a given computation. The table below is obtained from here","SNARKs","STARKs","The Big-O notation is used in Computer Science to describe the upper bound of the runtime of an algorithm in terms of the size of its input. An algorithm is said to run in time O(f(n)) if for sufficiently large input sizes n, the algorithm's runtime will not exceed c * f(n) steps.","The software for a block-order based protocol reads all transactions in the main chain in block-order to find transactions with meta data specific for that protocol. It will then interpret that sequence of meta data values as instructions and build up a data structure of smart contract data. The smart contract data will for example store which user owns which tokens.","There are two basic types of meta protocols called block-order based and UTXO based. These two types result form two basic ways of viewing a UTXO based blockchains: as a list of transactions and as a graph of transactions.","Trustless","Trustlessness. In optimistic rollups users trust that one honest validator is online at all times. STARKs are trustless, SNARKS are not.","Type","Verifier Complexity","Yes"]},{"l":"Formal Description","p":["We denote the set of transactions by T. We denote by V the set of smart contract data values where \\{\\} \\in V denotes the empty value. We denote the set of sequences of values in a set X by X^*.","Example trace in the BRC20 protocol","The BRC20 protocol is a protocol for fungible tokens.","The image on the right shows an example execution of the BRC20 protocol. The left column shows the meta data values and the column on the right shows the value that is computed after parsing each respective meta data value. The smart contract data value is initialized to the empty element \\{\\}. The first meta data value { op: deploy, ... } specifies the deployment of a fungible token called \"lite\" with a maximum supply of 1000. Once the BRC20 software parses this meta data value it updates its computed value to { lite: { max : 1000 }} as shown on the right. The next transaction contains a mining instruction and the software will update it's internal value accordingly as shown on the right. The bottom row shows a transaction shows a transfer transaction and the computed value that reflects that ownerB received one token from ownerA. The ownership of the assets is determined by the ownership of the outputs that contain the meta data. See here for more details.","Trustlessness. Yes.","Expressiveness. No, the existing block-order based protocols that we are aware of are single purpose only.","Efficiency. No, block order based protocols need to parse all transactions to compute a single value.","There are two other issues issues: Block-order based protocols cannot be real time as there is no indication in which order the transactions will occur on the mempool before a block is mined. Miners are incentivized to include transactions in an order that is advantageous to them. This is a common problem in Ethereum called \"miner extracted value\" (MEV).","Whereas block order based systems compute one global value from all transactions, UTXO based protocols compute a value for each output that is relevant to that protocol. The value computed for an output can usually depend on the meta data on that transaction and the valued computed for the inputs spent."]},{"l":"Formal Description","p":["[1] SoK: Applications of Sketches and Rollups in Blockchain Networks, Arad Kotzer, Daniel Gandelman and Ori Rottenstreich; Technion, Florida State University[2] Blockchain Scaling Using Rollups: A Comprehensive Survey, Louis Tremblay Thibault, Tom Sarry, and Abdelhakim Senhaji Hafid; Montreal[3] SoK: unraveling Bitcoin smart contracts, Nicola Atzei, Massimo Bartoletti, Tiziana Cimoli, Stefano Lande, Roberto Zunino; Cagliari, Trento[4] Beyond Bitcoin: A Review Study on the Diverse Future of Cryptocurrency, Mohammed Faez Hasan, University of Kerbala[5] BitML: A Calculus for Bitcoin Smart Contracts, Massimo Bartoletti, Roberto Zunino; Cagliari, Trento[6] An Overview of Smart Contract and Use cases in Blockchain Technology, Bhabendu Kumar Mohanta, Soumyashree S Panda, Debasish Jena; IIIT Bhubaneswar[7] Layer 2 Blockchain Scaling: a Survey, Cosimo Sguanci, Roberto Spatafora, Andrea Mario Vergani; Polytechnico Milano[8] A Rollup Comparison Framework, Jan Gorzny, Martin Derka; Zircuit[9] SoK: Decentralized Finance (DeFi)[10] SoK: Communication Across Distributed Ledgers[11] Colored Coins whitepaper, Yoni Assia, Vitalik Buterin, liorhakiLior, Meni Rosenfeld, Rotem Lev[12] Exploring Blockchains Interoperability: A Systematic Survey[13] bitcoinlayers.org[14] bitcoinrollups.io[15] Hiro Blog[16] Validity Rollups validity_rollups_on_bitcoin.md","computes the values for the outputs being spent and then substitutes these values for the free variables in the expressions as designated by the blockchain environment","evaluate the expression with the substitution applied in the scope of the module","imports the module from the transaction referred to","Let O be the set of outputs. A UTXO based protocol P is a function P: O \\rightarrow V that map outputs to smart contract data values.","The Bitcoin Computer protocol","The ordinals algorithm computes the block rewards r_1, r_2, \\ldots for every block in a chain. It then labels the output of the coinbase transaction of block i with the numbers ranging from r_0 + \\ldots + r_{i-1} to r_0 + \\ldots + r_i where r_0 = 0. To label the outputs of a transaction with inputs, the algorithm first determined the ordinal ranges of the outputs being spent and concatenates them. This array is used to label the outputs as follows: for each output, the algorithm will remove as many numbers from the array as the output has satoshis and assign that list of numbers to the output. The array will be sufficiently long as the number of satoshis spent by a transaction transaction must always be at least the number of satoshis in the output. This presentation is slightly simplified as it does not take fees into account, for details see here.","The Ordinals protocol","The ordinals protocol is a protocol for non-fungible token. It associates an integer with every satoshi and a list of integers with each output. The length of the list of integers is equal to the number of satoshis stored in the block. It does not require any meta data.","The picture shows an etching that deploys a new fungible token called \"lite\" that can be minted 10 times, creating 100 tokens on every mint. This transaction is assumed to be the 4th transaction in block 123. The second transaction show mints 100 tokens, the third transaction transfers the minted tokens into two outputs with one and 99 tokens each. You can find more information in the ordinals docs.","The picture shows the deployment, minting, and sending a non fungible token and a non fungible token. For more details see the rest of the documentation.","The Runes protocol","The runes protocol is a protocol for fungible tokens. Its smart contract data values are key value pairs where keys are token ids and its values are numbers. The meta data values are an efficient encoding of nested json objects.","There are distinct kinds of meta data values: \"etchings\" are used to deploy tokens, they can specify for example how many times a token is mined through the cap key and the number of tokens created in each mint via a key called amount. Minting instruction specify a token id (encoded as block-number.offset). \"Edicts\" transfer the tokens spent by the inputs into the outputs. A transfer transaction contains a list of edicts, each of which transfers the token id to transfer, the amount, and the output number. The meta-data is encoded into an array of integers which is stored in the op-return.","There are two types of transactions: \"modules\" contain JavaScript (ES6) modules. All other transactions contain a JavaScript expression, a \"blockchain environment\" that associated (free) variables in the expressions with input numbers, and an optional \"module specifier\" containing a transaction id. In order to compute the value of an output, the Bitcoin Computer software","This Bitcoin Computer is a general purpose meta protocol, meaning that it can express all computable smart contracts. The smart contract data values are arbitrarily nested JavaScript objects. The meta data values contain mostly JavaScript expressions.","Trustlessness. Yes. Expressiveness. No. Efficiency. Yes.","Trustlessness. Yes. Expressiveness. Yes. Efficiency. Yes.","We can see an example in the picture. The top transaction is the coinbase transaction of the first block. As the output of this transaction contains 5 Billion satoshis (= 50 Bitcoin) this output is labelled with the numbers 1, 2, \\ldots 5.000.000.000. The transaction below spends that output and contains two outputs with 20 and 30 Bitcoin. The first of these outputs is labelled with the numbers 1, 2, \\ldots 2.000.000.000 and the second with 2.000.000.001 \\ldots 5.000.000.000. You can find more information here.","We will say that a protocol P is well designed if P(o) can be computed from the meta data on the transaction containing o and the values of the outputs spent by t. That is, there is a function f_P: O \\times V^* \\rightarrow V such that P(o) = f_P(o, P(o_1) \\ldots P(o_n)) where o_1 \\ldots o_n are the outputs spent by the transaction containing o."]}],[{"l":"Legal Notice","p":["Sanctioned Users are Prohibited. You may not access or use software developed and published by us if you are (i) a resident of any country with which transactions or dealings are prohibited by governmental sanctions imposed by the U.S., the United Nations, the European Union, the United Kingdom, or any other applicable jurisdiction (collectively, “Sanctions Regimes”); (ii) a person, entity or government prohibited under an applicable Sanctions Regime (“Sanctioned Person”), including the Office of Foreign Assets Control, Specially Designated Nationals and Blocked Persons List; or (iii) prohibited from accessing or using the Software pursuant to the laws, rules, and regulations in the jurisdiction in which you reside or otherwise access and use the Software.","Users Must Comply with Applicable Law. You may only access or use the Software in compliance with laws, rules, and regulations in the jurisdiction in which you reside or otherwise access and use the Software, including, as applicable, Sanctions Regimes, anti-money laundering laws and regulations, and securities laws and regulations.","BCDB Does Not Endorse or Promote User Software Activity. We are publishing certain portions of the Software, on an open-source basis, to demonstrate the utility of the Bitcoin Computer. As this Software is open-source, it may be modified and deployed for a wide range of uses that we may not have intended. We do not endorse or promote, and expressly disclaim liability for, any non-BCDB use or modification of the Software."]}]]