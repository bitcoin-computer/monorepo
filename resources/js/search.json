[[{"l":"Introduction","p":["The Bitcoin Computer (TBC) is a Turing-complete smart contract system for Bitcoin and Litecoin. You can build decentralized applications, such as tokens, exchanges, games, social networks, and more.","Free Computation. The most important feature of TBC is that the execution cost is independent of the computational complexity of the smart contract. For most other smart contract systems, the execution cost increases with each computational step. Instead, the cost on TBC is fixed for an unlimited number of computational steps.","JavaScript. Smart contracts are JavaScript or TypeScript classes. This makes it seamless to integrate smart contracts into web applications and makes development easy due to the existing JavaScript ecosystem.","How it works. You can inscribe a JavaScript class to deploy a smart contract. Then, you can inscribe a constructor call to create a smart object and a function call to update a smart object.","Data Ownership. Conceptually, a smart object is stored in a UTXO, and only the owner of the UTXO can update its state. This captures a natural notion of data ownership that is as secure as ownership of Bitcoin.","Historical States. As every update is recorded in a separate transaction, every historical state of a smart object can be recovered, together with information about who updated it and when.","Encryption and Off Chain Storage. By default, every user can read all states of all smart objects. However, TBC has support for end-to-end encryption and storing data off-chain built-in. These properties make it easy to build applications that comply with consumer protection laws such as CCPA and GDPR.","Pure Bitcoin. Finally, TBC relies only on Bitcoin. It does not require a side-chain or an extra token. This makes it possible to build applications that are as stable as Bitcoin.","Contact. TBC is being developed by BCDB Inc. If you have any questions, please let us know in our Telegram group, on Twitter, or by email at clemens@bitcoincomputer.io."]}],[{"l":"Start"},{"l":"Try it Out","p":["To try out the Bitcoin Computer we recommend to follow the instructions on NPM.","Bitcoin Computer Library"]},{"l":"Run a Node","p":["If you want to run an application on mainnet or regtest you can run your own node. Regtest is recommended for serious development as you can refund your application.","Bitcoin Computer Node"]},{"l":"Build an App","p":["To build your own app we recommend to clone our monorepo and start from one of the example applications.","Bitcoin Computer Monorepo"]}],[{"l":"Tutorial"},{"l":"Write a Smart Contract","p":["Smart contracts are Javascript or Typescript classes that extend from Contract. For example, a smart contract for a simple chat is","Note that it is not possible to assign to this in constructors. Instead you can initialize a smart object by passing an argument into super as shown above."]},{"l":"Create a Computer Object","p":["You need to create an instance of the Computer class in oder to deploy smart contracts and create smart objects.","You can pass in a BIP39 mnemonic to initialize the wallet in the computer object. To securely generate a random mnemonic leave the mnemonic key undefined. You can find more configuration options here."]},{"l":"Create a Smart Object","p":["The computer.new function creates a smart object from a smart contract.","The object chat that is returned has the properties defined in the class and five extra properties _id, _rev, _root, _owners and _amount.","The property _owners is an array of public keys that are able to spend that UTXO and the property _amount is the amount of satoshis in that UTXO. The meaning of the other properties are explained below.","The properties _id, _rev, _root reference a transaction that is broadcast when the expression await computer.new(Chat, ['hello']) is evaluated. This transaction encodes the expression","Another user can download this transaction and evaluate this expression to obtain a copy of the smart object. This can be done using the computer.sync function described in the next section."]},{"l":"Read a Smart Object","p":["The computer.sync function computes the state of smart object. For example, synchronizing to 667c...2357:0 will return an object with the same value as chat.","You can find more details about how this works here."]},{"l":"Update a Smart Object","p":["A Smart object can be updated by calling one of it's functions. Note that you have to await on all function calls to read the latest state.","When a function is called, a transaction is broadcast that inscribes the expression of the function call. In the example, the transaction with id de43...818a inscribes the expression","Note that the _rev property of the chat object has been updated to de43...818a:0. Every time a smart object is updated a new revision is created. The corresponding transaction id and output number is assigned to the _rev property. The _id property is never updated and is a unique identifier for each smart object. You can find more details about updating smart object here.","The computer.sync function maps revisions to historical states. It can be called with any historical revision. It will return the current state for the latest revision."]},{"l":"Find a Smart Object","p":["The computer.query function returns the latest revision of a smart objects. It can be called with many different kinds of arguments, for example object one or more ids:","A basic pattern for many applications is to identify a smart object by its id, look up the object's latest revision using computer.query, and then to compute its latest state using computer.sync. For example, imagine a chat app where the url would contain the id of a specific chat. The app could compute the latest state of the chat as follows:"]},{"l":"Data Ownership","p":["Every smart object can have up to three owners. Only an owner can update the object. The owners can be set by assigning string encoded public keys to the _owners property of a smart object. If the _owners property is not assigned in a smart contract it defaults to the public key of the computer object that created the smart object.","In the chat example the initial owner is the public key of the computer object on which computer.new function was called. Thus only a user with the private key for that public key will be able to post to the chat. We can add a function invite to update the owners array to allow more users to post."]},{"l":"Privacy","p":["By default, the state of all smart objects is public in the sense that any user can call the computer.sync function on an object's revision. However, you can restrict read access to an object by setting its _readers property to an array of public keys. If _readers is assigned, the meta-data on the transaction is encrypted using a combination of AES and ECIES. Only the specified readers can decrypt an encrypted object using the computer.sync function.","For example, if we want to ensure that only people invited to the chat can read the messages, we can update our example code as follows:","A user can (only) read the state of a smart object if they have read access to the current and all previous versions of the object. It is, therefore, not possible to revoke read access to a revision after it has been granted. However, it is possible to remove a user's ability to read the state of a smart object from a point in time forwards.","When smart objects are encrypted the flow of cryptocurrency is not obfuscated."]},{"l":"Off-Chain Storage","p":["Not all data needs to be stored on the blockchain. For example, personal information should never be stored on chain, not even encrypted.","When the property _url of a smart object is set to the URL of a Bitcoin Computer Node, the metadata of the current function call is stored on the specified Bitcoin Computer Node. The blockchain contains a hash of the meta data and a link to where it can be retrieved.","For example, if we want to allow users to send images that are too large to be stored on chain to the chat, we can make use of the off-chain solution:"]},{"l":"Cryptocurrency","p":["Each smart object can store an amount of cryptocurrency. By default a smart object stores a minimal (non-dust) amount. If the _amount property of a smart object is set to a number, the output storing that smart object will contain that number of satoshis. For example, consider the class Payment below.","If a user A wants to send 210000 satoshis to a user B, the user A can setup the payment as follows:","When the payment smart object is created, the wallet inside the computerA object funds the 210000 satoshi that are stored in the payment object. Once user B becomes aware of the payment, he can withdraw by syncing against the object and calling the cashOut function.","One more transaction is broadcast for which user B pays the fees. This transaction has two outputs: one that records that the cashOut function was called with 546 satoshi and another that spends the remaining satoshi to user B's address."]}],[{"l":"Examples","p":["We have several example applications in varying stages of development. To run an example have a look at the README.md file in the corresponding folder."]},{"l":"Applications","p":["Wallet- A non-custodial wallet","Blockchain Explorer- A block explorer with smart contract support","Chat- A p2p chat via Bitcoin and Litecoin","Fungible Token- An app for minting, sending, and storing fungible tokens","Non Fungible Token- An app for minting, sending, and storing non-fungible tokens"]},{"l":"Standard Contracts","p":["TBC20 contract- An implementation of the ERC20 Fungible Token Standard","TBC721 contract- An implementation of the ERC721 Non-Fungible Token Standard"]},{"l":"Templates","p":["Node.js Template- A template for starting a new server side app","React Template- A template for starting a new client side app"]}],[{"l":"How it Works","p":["We recommend to read the tutorial first.","The Bitcoin Computer is a Javascript runtime environment that uses Bitcoin as a persistence layer."]},{"l":"Storing Values","p":["When an expression is evaluated with the Bitcoin Computer, the expression is inscribed into a Bitcoin transaction. If the value of the expression has object type, this object is considered a \"smart object\" and an output of the transaction is considered the object's id. If the value has multiple sub-objects, each sub-object is assigned a separate output as its id.","To determine the value of a given smart object id, the Bitcoin Computer library will download the corresponding transaction and compute the value of the expression. As the mapping from sub-objects to outputs is deterministic and one-to-one, the software can determine which sub-object of the value is the smart object for the given id."]},{"l":"Updating Values","p":["In order to explain how updating values works we need the notions of \"free variable\", \"environment\", and \"closure\". Consider the Javascript expression:","It contains two variables, x and counter. The variable x is defined in the expression and one can determine that the value of x is 1. The variable counter is not defined so it is impossible to tell what the value of counter is. Such variables are called free variables. In order to evaluate an expression with free variables, a definition of the values of the free variables is required. This is what an environment does: it maps free variables to values. A closure is a pair consisting of an expression and an environment.","To evaluate an expression e containing free variables x_1\\ ...\\ x_n with the Bitcoin Computer, the user needs to provide a Bitcoin environment\\{ x_1: o_1\\ ...\\ x_n: o_n \\} that maps the free variables of e to outputs o_1\\ ...\\ o_n. The Bitcoin Computer will recursively determine the values v_1\\ ...\\ v_n of the outputs o_1\\ ...\\ o_n respectively. It then creates a closure consisting of the expression e and the environment \\{ x_1: v_1\\ ...\\ x_n: v_n \\} and evaluates this closure with a standard Javascript runtime.","All sub-objects of the value returned are designated one output of the transaction. We refer to both the outputs as well as the values they represent as revisions. Note that when a closure is evaluated, the values v_1\\ ...\\ v_n can change (for example if e is a function call f(x_1\\ ...\\ x_n) with side effects). Therefore a these transactions must have outputs that represent the new revisions for these values as well.","The Bitcoin Computer protocol requires that a transaction spends all outputs in the environment. A practical advantage is that this provides a space efficient way to store the environment: Only a list of variable names needs to be stored as meta data and the full environment can be reconstructed from the inputs. It also has two important consequences: It provides a notion of data ownership as it is necessary to be able to spend an output in order to update it's value. And it makes it possible to run the Bitcoin Computer as a light client as the inputs of a transaction contain pointers to the transactions that contain the expressions that need to be evaluated first."]},{"l":"Smart Contract Language","p":["The programming language used for the Bitcoin Computer has the exact same syntax as Javascript. However there is one important semantic difference:","All values returned from evaluating an expression that have object type must inherit from Contract.","The class Contract is exported from the library. It enforces the following properties, which we think turn Javascript into a viable smart contract language."]},{"l":"Assigning Properties Outside of Function Calls is Prohibited","p":["Assigning to a property outside of a function call throws an error.","This makes it possible to write classes that impose constraints on all future values of an object. Consider for example the class Even below. The condition guarantees that all instances of the class will always have an even value.","While this is not a very useful example for a constraint, all smart contracts are based on constraints to future values in a similar way."]},{"l":"Keyword Properties Control the Transaction Being Built","p":["The Contract class enforces certain types for the properties _id, _rev, _root, _amount, _owners, _readers, and _url:","The properties _id, _rev, and _root are read only and set by the runtime to relay information about which transaction created the object and where it is currently stored.","The value of the _id property is the output (encoded as <transaction id>:<output index>) that represented the object immediately after it was created.","The value of the _rev property is the output of the currently representing the object (that is, the object's revision).","The value of the _root property is assigned once when the object is created and is never modified subsequently. If the expression that creates the object is of the form new C(...) then its root is equal to its id. If the expression is of the form x.f(...) then the root of the new object is equal to the id of x. Otherwise the root is set to n/a. The root property is useful for building fungible tokens.","The properties _amount, _owners, _readers, and _url can be set by the smart contract developer to influence how the transaction is built.","If a property _amount is set it needs to be set to a number. It determines the amount of Satoshi stored in the output representing the current revision. If it is not set the revision will have a minimal (non-dust) amount of Satoshi.","If a property _owners is set it needs to be set to an array of strings [p_1\\ ...\\ p_n]. These determine the output script of the current revision. Specifically, the script for the current revision is a 1-of-n multisig script with the public keys p_1\\ ...\\ p_n. This guarantees that only a user that has a private key corresponding to one of the public keys can update the object. If the property is not set it defaults to the public key of the computer that created the object.","If a property _readers is set it needs to be set to an array of strings [p_1\\ ...\\ p_n]. If this property is set the meta data in the corresponding transaction is encrypted such that only users with corresponding private keys can decrypt the expression and compute the value of the smart object. If the _readers property is not set the meta data is not encrypted and any user can compute the value of the smart object.","If a property _url is set it needs to be set to the url of a Bitcoin Computer node. If it is set the expression is not stored in the transaction but on the node instead. The transaction only contains a hash of the expression and the location where the expression can be obtained from the node. This is convenient if the expression is large, for example because it contains a lot of data."]},{"l":"Assigning to this in Constructors is Prohibited","p":["This is not a property that we think this will make Javascript a better smart contract language, it is just a consequence how we enforce the properties above. In order to have useful constructors it is possible to pass an initialization object into the constructor:","This has the same effect as setting assigning to this in a normal Javascript program"]}],[{"l":"API","p":["This API describes the functionality of the Computer class, exported from @bitcoin-computer/lib."]},{"l":"Basic","p":["You can build almost all smart contracts with following methods.","Method","Description","constructor","Creates an instance of class Computer","new","Creates a smart object from a smart contract","query","Finds the latest revisions of smart object","sync","Computes the state of a smart object from a given revision"]},{"l":"Advanced","p":["To build advanced applications like swaps have a look at the following.","Method","Description","encode","Encodes a Javascript expression into a Bitcoin transaction","encodeNew","Encodes a constructor call into a Bitcoin transaction","encodeCall","Encodes a function call into a Bitcoin transaction","decode","Parses a Bitcoin transaction and returns Javascript expression in the case of a Bitcoin Computer transaction"]},{"l":"Modules","p":["You can save transaction fees by using our ES6 module system.","Method","Description","deploy","Deploys an ES6 module on the blockchain","load","Loads an ES6 module from the blockchain"]},{"l":"Wallet","p":["Access Bitcoin's RPC interface","broadcast","Broadcasts a Bitcoin transaction","Description","getAddress","getBalance","getChain","getMnemonic","getNetwork","getPassphrase","getPrivateKey","getPublicKey","getUtxos","Method","Returns a BIP39 mnemonic sentence","Returns an array of unspent transaction outputs","Returns the balance in satoshi","Returns the Bitcoin address of the computer wallet","Returns the blockchain","Returns the network","Returns the passphrase","Returns the private key","Returns the public key","rpcCall","send","Sends satoshis to an address","sign","Signs a Bitcoin transaction","The wallet functionality within a Computer instance can be accessed using the following."]}],[{"l":"broadcast","p":["The broadcast function broadcasts a Bitcoin transaction to the Bitcoin mining network."]},{"l":"Type"},{"l":"Syntax"},{"l":"Parameters"},{"l":"tx","p":["A Bitcoin transaction object."]},{"l":"Return value","p":["If broadcast is successful, it returns an string encoding the transaction id. Otherwise, an error is thrown."]},{"l":"Examples"}],[{"l":"constructor","p":["The constructor of the Computer class creates an instance. It's functionality is described in this API documentation."]},{"l":"Type"},{"l":"Syntax"},{"l":"Parameters"},{"l":"config","p":["2","30000 on LTC and 3000 on BTC","A configuration object","BIP32 passphrase","BIP32 path","BIP39 mnemonic phrase","chain","Default Value","Description","Dust relay fee","dustRelayFee","Fee in satoshi per byte","https://node.bitcoincomputer.io","Key","LTC","m/44'/0'/0'","mnemonic","network","passphrase","path","Random phrase","satPerByte","Target blockchain. Values can be 'LTC' or 'BTC'","Target network. Values in 'testnet', 'regtest' or 'mainnet'","testnet","The empty string","url","Url of a Bitcoin Computer Node"]},{"l":"Return Value","p":["An instance of the Computer class"]},{"l":"Examples"}],[{"l":"decode","p":["The decode function parses a Bitcoin transaction to determine if it is a Bitcoin Computer transaction. If so it returns an expression exp, a blockchain environment env, and a module specifier mod. The function decode is the inverse of encode when the latter is called with exp, env, and mod."]},{"l":"Type"},{"l":"Syntax"},{"l":"Parameters"},{"l":"tx","p":["A Bitcoin transaction object."]},{"l":"Return value","p":["It returns a Bitcoin transaction and an object of type Effect.","The object of type Effect captures the changes induced by evaluating the expression: It contains the result of the evaluation (property res) and the side effects of the evaluation (property env). The object of type Effect can be used to determine if the evaluation had the desired effect. If it did, the transaction can be broadcast to commit the update to the blockchain. If the transaction is not broadcast, the state on the blockchain does not change. The transaction can be broadcast at an arbitrarily long delay after calling encode. If during the time between calling encode and broadcasting the transaction the blockchain undergoes any updates that could affect the evaluation, the miners will reject the transaction. However, if the transaction is accepted by the miners, it is guaranteed to have the effect indicated by object of type Effect.","If fund is required, and the wallet has insufficient funds, an error is thrown. If sign is required, the default behavior is to sign all inputs. The encode function will make a best effort to sign all inputs, but will not throw any error if the signature cannot be added due to hash mismatch. This is useful in the case of partially signed transactions, where a user can encode an expression, sign with the user private key and send the generated partially signed transaction to another user. Then, the receiver can sign the remaining inputs."]},{"l":"Examples"}],[{"l":"deploy","p":["The deploy function stores an ES6 module on the blockchain and returns an identifier for that module. This identifier can be passed into the functions computer.new, computer.encode, computer.encodeNew, and computer.encodeCall to make the exports of the module available there.","The advantage of deploying your code is that it can save transaction fees: A large piece of code can be deployed once and then used to create or update many smart objects.","Please note that modules are not encrypted, even if objects that use them have the _readers property set."]},{"l":"Type"},{"l":"Syntax"},{"l":"Parameters"},{"l":"module","p":["A string encoding an ES6 module."]},{"l":"Return value","p":["A string encoding the location where the module is stored. The format is <transaction id>:<output number>."]},{"l":"Examples","p":["Previously this function was called export but this name is deprecated since version 0.16.0."]}],[{"l":"encode","p":["The encode function builds a Bitcoin transaction from a Javascript expression according to the Bitcoin Computer protocol. In addition to the transaction, this function also returns the value of the expression.","If the expression contains free variables (for example the variable x in the expression x.f()) a \"blockchain environment\" must be passed. A blockchain environment is a JSON object that maps variable names to the latest revisions of smart objects.","A module specifier can be provided in order to make the exports of that module are available to the evaluation.","Other options can customize the funding and signing process.","The state update effected by a Bitcoin Computer transaction is completely predictable:","If the transaction is included in a block the new state will be exactly the state returned from the effect function.","If the transaction is not included the state is not updated."]},{"l":"Type"},{"l":"Syntax"},{"l":"Parameters"},{"l":"opts","p":["[]","{}","1=SIGHASH_ALL","A Blockchain environment, maps free variables to latest revisions","A Javascript expression","A module specifier","An object with the basic configuration parameters to encode the expression in a transaction.","boolean","Default Value","Description","env","exclude","exp","fund","If set to a string a custom input script can be provided. If undefined a signature script is generated","If set to an number the corresponding input is signed. If undefined all inputs are signed.","include","index","inputScript","Key","mod","Module specifiers and UTXOs are encoded as strings of the form <transaction id>:<output number>","number","Record<string, string>","sighashType","sign","string","string[]","The sighash type","true","Type","undefined","UTXOs to exclude when funding","UTXOs to include when funding","Whether the transaction should be funded","Whether to sign the transaction"]},{"l":"Return value","p":["It returns an object { tx, effect } where tx is a Bitcoin transaction and effect is an object with keys res and env.","The transaction tx is an object from the NakamotoJS library - a BitcoinJS clone that supports LTC and BTC and has some extra features that make is easier to build advanced applications like exchanges.","The res object contains the result of the evaluation.","The env object has the same keys as the blockchain environment. However, whereas the values of the blockchain environment are revision strings, the values of env and the smart object at these revisions after evaluating the expression."]},{"l":"Examples"}],[{"l":"encodeCall","p":["Encodes a function call. This function is syntactic sugar for encode."]},{"l":"Type"},{"l":"Syntax"},{"l":"Parameters"},{"l":"params","p":["A module specifier","An object with the configuration parameters to encode the expression in a transaction.","args","Description","InstanceType<T>","Key","mod","Module specifiers are encoded as strings of the form <transaction id>:<output number>","Parameters<InstanceType<T>[K]>","property","string","target","The arguments to the function call","The name of the function being called","The smart object on which to call the function","Type"]},{"l":"Return value","p":["It returns an object { tx, effect } where tx is a Bitcoin transaction and effect is an object with keys res and env. For more details see the description of the return type of encode."]},{"l":"Examples"}],[{"l":"encodeNew","p":["Encodes a constructor call. This function is syntactic sugar for encode."]},{"l":"Type"},{"l":"Syntax"},{"l":"Parameters"},{"l":"params","p":["An object with the configuration parameters to encode the expression in a transaction.","Key","Type","Description","constructor","T extends new (...args: any) => any","A Javascript class that extends from Contract","args","ConstructorParameters<T>","Arguments to the constructor of the class","mod","string","A module specifier","Module specifiers are encoded as strings of the form <transaction id>:<output number>"]},{"l":"Return value","p":["It returns an object { tx, effect } where tx is a Bitcoin transaction and effect is an object with keys res and env. For more details see the description of the return type of encode."]},{"l":"Examples"}],[{"l":"fund","p":["Funds a Bitcoin transaction."]},{"l":"Type"},{"l":"Syntax"},{"l":"Parameters"},{"l":"tx","p":["A Bitcoin transaction object from the NakamotoJS library."]},{"l":"opts","p":["An optional object can be passed as parameter to include or exclude certain UTXOs. When using include, the transaction will be funded with the UTXOs specified as the first inputs.","Key","Type","Description","Default Value","include","string[]","UTXOs to include","[]","exclude","UTXOs to exclude"]},{"l":"Return value","p":["If the wallet does not have sufficient funds, an error is thrown."]},{"l":"Examples"}],[{"l":"getAddress","p":["Returns a string encoding Bitcoin address."]},{"l":"Type"},{"l":"Syntax"},{"l":"Return value","p":["Returns a string encoded Bitcoin address."]}],[{"l":"getBalance","p":["Returns the current balance in satoshi."]},{"l":"Type"},{"l":"Syntax"},{"l":"Return value","p":["Returns the current balance in Satoshi."]}],[{"l":"getChain","p":["Returns the chain."]},{"l":"Type"},{"l":"Syntax"},{"l":"Return value","p":["Returns a string encoding the chain."]}],[{"l":"getMnemonic","p":["Returns a string encoding a BIP39 mnemonic sentence."]},{"l":"Type"},{"l":"Syntax"},{"l":"Return value","p":["The mnemonic."]}],[{"l":"getNetwork","p":["Returns the network."]},{"l":"Type"},{"l":"Syntax"},{"l":"Return value","p":["Returns a string encoding the network."]}],[{"l":"getPassphrase","p":["Returns the BIP39 passphrase."]},{"l":"Type"},{"l":"Syntax"},{"l":"Return value","p":["Returns the BIP39 passphrase."]}],[{"l":"getPrivateKey","p":["Returns a string encoded private key."]},{"l":"Type"},{"l":"Syntax"},{"l":"Return value","p":["Returns a string encoded private key."]}],[{"l":"getPublicKey","p":["Returns a string encoding a public key."]},{"l":"Type"},{"l":"Syntax"},{"l":"Return value","p":["Returns a string encoding a public key."]}],[{"l":"getUtxos","p":["Returns an array of unspent transaction outputs (UTXOs). Each UTXO is encoded as a string of the form <transaction id>:<output number>"]},{"l":"Syntax"},{"l":"Type"},{"l":"Return value","p":["Returns an array of unspent transaction outputs (UTXOs)."]}],[{"l":"load","p":["Imports a ES6 module from a module specifier encoded as a string <transaction id>:<output number>."]},{"l":"Type"},{"l":"Syntax"},{"l":"Parameters"},{"l":"rev","p":["A string encoding a module specifier."]},{"l":"Return value","p":["A ES6 module."]},{"l":"Examples"}],[{"l":"new","p":["Creates a new smart object. The parameters are a smart contract (a Javascript class inheriting from Contract), a list of arguments for the constructor of the class and an optional module specifier. The arguments of the constructor can be of basic data type or smart objects. The new function builds a transaction that records the creation of a new smart object, signs it and broadcasts it. Smart objects can be updated by calling their functions, see here."]},{"l":"Type","p":["Here a MetaData is the type"]},{"l":"Syntax"},{"l":"Parameters"},{"l":"constructor","p":["A named Javascript class that extends from Contract."]},{"l":"args","p":["Arguments to the constructor of the class."]},{"l":"mod","p":["A module specifier, i.e., the revision string of a deployed module (see deploy)."]},{"l":"Return value","p":["Returns an instance of the class T. The class T should extend from Contract. The returned object has extra properties _id, _rev, _root, _owners, _amount and possibly _url, _readers."]},{"l":"Examples"}],[{"l":"query","p":["Returns the latest revisions of smart objects. Conditions can be passed in to determine the smart objects. When multiple conditions are passed in, the latest revisions of the smart objects that satisfy all conditions are returned."]},{"l":"Type"},{"l":"Syntax"},{"l":"Parameters"},{"l":"params","p":["'ASC' | 'DEC'","{ class: T, args?: ConstructorParameters<T> }","An object with the query parameters.","contract","Description","ids","Key","limit","mod","number","offset","order","Order results in ascending or descending order","publicKey","Return latest revision of smart objects with ids in order","Return latest revisions of smart objects from a class","Return latest revisions of smart objects owned by a public key","Return only limited number of revisions","Return results starting from offset","Return the latest revision of smart objects created with this module specifier","string","string[]","Type"]},{"l":"Return value","p":["Given the query parameters, returns an array of strings encoding the latest revisions of smart objects that matches the specified conditions."]},{"l":"Examples"}],[{"l":"rpcCall","p":["Calls a Bitcoin RPC method with the given parameters."]},{"l":"Type"},{"l":"Syntax"},{"l":"Parameters"},{"l":"method","p":["An string encoding the name of the rpc function to be called."]},{"l":"params","p":["An string with the argument list of the rpc function call to be called, separated by spaces."]},{"l":"Return value","p":["A JSON object with the result of the rpc method call."]},{"l":"Examples"}],[{"l":"send","p":["Sends a payment."]},{"l":"Type"},{"l":"Syntax"},{"l":"Parameters"},{"l":"amount","p":["A number representing the amount of satoshis to be sent."]},{"l":"address","p":["An string encoding the receiver address."]},{"l":"Return value","p":["If successful, it returns the id of the transaction broadcast."]},{"l":"Examples"}],[{"l":"sign","p":["Signs a Bitcoin transaction. Options can be passed in that determine which inputs to sign, the sigHash type to use, and which script to use."]},{"l":"Type"},{"l":"Syntax"},{"l":"Parameters"},{"l":"tx","p":["A Bitcoin transaction, possibly partially signed."]},{"l":"opts","p":["An object with specific parameters to use when signing","Key","Type","Description","inputIndex","number","The input index to be signed","sighashType","A valid sighash type number","inputScript","Buffer","A buffer encoding the signature"]},{"l":"Return value","p":["By default, the sign function will make a best effort to sign all inputs, but will not throw an error if the signature cannot be added due to hash mismatch.","This is useful in the case of partially signed transactions, where a user can encode an expression, sign with the user private key and send the generated partially signed transaction to another user. Then, the receiver can sign other inputs."]},{"l":"Examples"}],[{"l":"sync","p":["Returns smart objects given a location on the blockchain. The location can either be a revision (a string of the for <transaction id>:<output number>) or a transaction id."]},{"l":"Type"},{"l":"Syntax"},{"l":"Parameters"},{"l":"location","p":["An string encoding a revision or a transaction id."]},{"l":"Return value","p":["If the function is called with a revision, it returns the smart object stored at the provided revision. Note that the revision must not be a latest revision. In that case a historical state of the revision is returned.","If the function is called with a transaction id, it returns an object of type { res: Json; env: Json }. The value of res is the result of evaluating the expression inscribed into the transaction. The env object has the same keys as the blockchain environment of the transaction, the values of env are the smart objects at these revisions after evaluating the expression.","If the parameter is not a valid revision or transaction id, an error is thrown."]},{"l":"Examples"},{"l":"Sync to a Revision","p":["Synchronizing to the revision returns a smart object."]},{"l":"Sync to a transaction id","p":["Synchronizing to a transaction id returns all smart objects on that transaction."]}]]