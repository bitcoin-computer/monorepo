[[{"i":"#","p":["This is a custom description for this page"]},{"l":"Bitcoin Computer","p":["A smart contract system for UTXO-based blockchains. Key features include:","Clients validate instead of trusting the operator","Transaction fee are low and independent of time and space complexity","Smart contract are written in Javascript or Typescript","Access to all historical states","Built-in privacy through encryption","Efficient block space usage with off-chain storage","ES6 module system based on inscriptions","No side-chain","No extra token","Support for Litecoin with support for Bitcoin and Dogecoin coming soon.","You can build decentralized applications, such as tokens, exchanges, games, social networks, and more."]},{"l":"Get Started","p":["Bitcoin Computer"]},{"l":"Examples","p":["To run an example have a look at the README.md file in the corresponding folder."]},{"l":"Applications","p":["Wallet: A minimal non-custodial wallet","Chat: A p2p chat application where messages are communicated over the blockchain","Fungible Token: An application for minting, sending, and storing fungible tokens","Non Fungible Token: An application for minting, sending, and storing non-fungible tokens (NFTs)"]},{"l":"Standard Smart Contracts","p":["BRC20 contract: A implementation of the ERC20 Fungible Token Standard","BRC721 contract: A implementation of the ERC721 Non-Fungible Token Standard"]},{"l":"Templates","p":["Bitcoin Computer Node.js Template: A template for starting a new Bitcoin Computer application with node.js","Bitcoin Computer React Template: A template for starting a new Bitcoin Computer application with Create React App"]},{"l":"Core Library","p":["The core smart contract library is based on two packages:","Bitcoin Computer Lib A non-custodial web wallet for reading and writing smart contracts","Bitcoin Computer Node Server side infrastructure for providing trustless access to smart contracts"]},{"l":"Price","p":["It is free to develop and test a Bitcoin Computer application on testnet and regtest.","On Mainnet the fees for using the Bitcoin Computer are on average the same as the transaction fees charged by miners fees. For example, if the miner transaction fee is one cent, then you pay two cent in total: one cent to the miners, and one cent to support the development of the Bitcoin Computer."]},{"l":"Development Status","p":["We have completed two internal audits and addressed any discovered issues. Currently, there are no known security vulnerabilities, however, it is possible that unknown vulnerabilities may exist. We plan to conduct one more thorough internal security audit prior to recommending the usage of the Bitcoin Computer in production environments."]},{"l":"Getting Help","p":["If you have any questions, please let us know in our Telegram group, on Twitter, or by email clemens@bitcoincomputer.io."]},{"l":"License","p":["Bitcoin Computer Lib and Bitcoin Computer Node are licensed under the Creative Commons Attribution-NoDerivs 3.0 Unported License. All other packages in this monorepo are licensed under the MIT License. See the individual packages for more information."]}],[{"l":"Start"},{"l":"Quick Start","p":["To try out the Bitcoin Computer please follow the instructions on NPM.","Bitcoin Computer Library","You will be connected to a Bitcoin Computer Node on testnet that we run so you don't have to deal with setting it up."]},{"l":"Run a Node","p":["If you want to run an application on mainnet or regtest (recommended for serious development) you can run your own node.","Bitcoin Computer Node"]},{"l":"Build an Application","p":["The easiest way to get started is to clone our monorepo and start from one of the example applications (look for the package called Wallet for example).","Bitcoin Computer Monorepo"]}],[{"l":"Tutorial"},{"l":"Write a Smart Contract","p":["Smart contracts are Javascript classes that extend from Contract. For example, a smart contract for a simple chat is","It is currently not possible to assign to this in constructors. Instead you can initialize a smart object by passing an argument into super as shown above."]},{"l":"Create a Wallet","p":["To create a wallet call the constructor of the Computer class.","You can pass in a BIP39 mnemonic to initialize the wallet. To securely generate a random mnemonic leave the mnemonic key undefined. You can find more configuration options here."]},{"l":"Create a Smart Object","p":["The computer.new function creates a smart object from a smart contract.","When this call is executed, a transaction is broadcast that contains both the source code of Chat as well as the expression new Chat('hello'). The object chat that is returned has the properties defined in the class and five extra properties _id, _rev, _root, _owners and _amount.","The transaction with id 667c...2357 contains a UTXO at position 0 that encodes the expression","The property _owners is an array of public keys that are able to spend that UTXO and the property _amount is the amount of satoshis in that UTXO. The meaning of the other properties are explained below."]},{"l":"Read a Smart Object","p":["The computer.sync function computes the state of smart object. For example, synchronizing to 667c...2357:0 will return an object with the same value as chat.","By default smart objects are readable by any user but they can be encrypted to restrict read access."]},{"l":"Update a Smart Object","p":["A Smart object can be updated by calling one of it's functions. Note that you have to await on all function calls to read the latest state.","When a function is called, a transaction is broadcast that inscribes the expression of the function call. In the example, the transaction with id de43...818a contains a UTXO at position 0 that inscribes the expression","Note that the _rev property of the chat object has been updated to de43...818a:0. Every time a smart object is updated a new revision is created the corresponding transaction if and output number is assigned to the _rev property. The _id property is never updated and is a unique identifier for each smart object.","The computer.sync function maps revisions to historical states, and will return the current state for the latest revision."]},{"l":"Find a Smart Object","p":["The computer.query function returns the latest revision of a smart objects. It takes different kinds of arguments, for example object one or more ids:","A basic pattern for many applications is to identify a smart object by its id, look up the object's latest revision using computer.query, and then to compute its latest state using computer.sync. For example, imagine a chat app where the url would contain the id of a specific chat. The app could compute the latest state of the chat as follows:"]},{"l":"Data Ownership","p":["Every smart object can have up to three owners. Only an owner can update the object. The owners can be set by assigning string encoded public keys to the _owners property of a smart object. If the _owners property is not assigned in a smart contract it defaults to the public key of the computer object that created the smart object.","In the chat example the initial owner is the public key of the computer object on which computer.new function was called. Thus only a user with the private key for that public key will be able to post to the chat. We can add a function to update the owners array to invite more guests to chat."]},{"l":"Privacy","p":["By default, the state of all smart objects is public in the sense that any user can call the computer.sync function on an object's revision. However, you can restrict read access to an object by setting its _readers property to an array of public keys. If _readers is assigned, the meta-data on the transaction is encrypted using a combination of AES and ECIES. Only the specified readers can decrypt an encrypted object using the computer.sync function.","For example, if we want to ensure that only people invited to the chat can read the messages, we can update our example code as follows:","A user can (only) read the state of a smart object if they have read access to the current and all previous versions of the object. It is, therefore, not possible to revoke access to a revision after it has been granted. However, it is possible to remove a user's ability to read the state of a smart object from a point in time forwards.","When smart objects are encrypted the flow of cryptocurrency is not obfuscated."]},{"l":"Off-Chain Storage","p":["Not all data needs to be stored on the blockchain. For example, personal information should never be stored on chain, not even encrypted.","When the property _url of a smart object is set to the URL of a Bitcoin Computer Node, the metadata of the current function call is stored on the specified Bitcoin Computer Node. The blockchain contains a hash of the meta data and a link to where it can be retrieved.","For example, if we want to allow users to send images that are too large to be stored on chain to the chat, we can make use of the off-chain solution:"]},{"l":"Cryptocurrency","p":["Each smart object can store an amount of satoshi. By default a smart object stores a minimal (non-dust) amount. If the _amount property of a smart object is set to a number, the output storing that smart object will contain that number of satoshis. For example, consider the class Payment below.","If a user A wants to send 210000 satoshis to a user B, the user A can setup the payment as follows:","When the payment smart object is created, the wallet inside the computerA object funds the 210000 satoshi that are stored in the payment object. Once user B becomes aware of the payment, he can withdraw by syncing against the object and calling the cashOut function.","One more transaction is broadcast for which user B pays the fees. This transaction has two outputs: one that records that the cashOut function was called with 546 satoshi and another that spends the remaining satoshi to user B's address."]}],[{"l":"How it Works","p":["We recommend to read the tutorial first.","The Bitcoin Computer is a Javascript runtime environment that uses Bitcoin as a persistence layer."]},{"l":"Storing Values","p":["When an expression is evaluated with the Bitcoin Computer, the expression is inscribed into a Bitcoin transaction. If the value of the expression has object type, this object is considered a \"smart object\" and an output of the transaction is considered the object's id. If the value has multiple sub-objects, each sub-object is assigned a separate output as its id.","To determine the value of a given smart object id, the Bitcoin Computer library will download the corresponding transaction and compute the value of the expression. As the mapping from sub-objects to outputs is deterministic and one-to-one, the software can determine which sub-object of the value is the smart object for the given id."]},{"l":"Updating Values","p":["In order to explain how updating values works we need the notions of \"free variable\", \"environment\", and \"closure\". Consider the Javascript expression:","It contains two variables, x and counter. The variable x is defined in the expression and one can determine that the value of x is 1. The variable counter is not defined so it is impossible to tell what the value of counter is. Such variables are called free variables. In order to evaluate an expression with free variables, a definition of the values of the free variables is required. This is what an environment does: it maps free variables to values. A closure is a pair consisting of an expression and an environment.","To evaluate an expression e containing free variables x_1\\ ...\\ x_n with the Bitcoin Computer, the user needs to provide a Bitcoin environment\\{ x_1: o_1\\ ...\\ x_n: o_n \\} that maps the free variables of e to outputs o_1\\ ...\\ o_n. The Bitcoin Computer will recursively determine the values v_1\\ ...\\ v_n of the outputs o_1\\ ...\\ o_n respectively. It then creates a closure consisting of the expression e and the environment \\{ x_1: v_1\\ ...\\ x_n: v_n \\} and evaluates this closure with a standard Javascript runtime.","All sub-objects of the value returned are designated one output of the transaction. We refer to both the outputs as well as the values they represent as revisions. Note that when a closure is evaluated, the values v_1\\ ...\\ v_n can change (for example if e is a function call f(x_1\\ ...\\ x_n) with side effects). Therefore a these transactions must have outputs that represent the new revisions for these values as well.","The Bitcoin Computer protocol requires that a transaction spends all outputs in the environment. A practical advantage is that this provides a space efficient way to store the environment: Only a list of variable names needs to be stored as meta data and the full environment can be reconstructed from the inputs. It also has two important consequences: It provides a notion of data ownership as it is necessary to be able to spend an output in order to update it's value. And it makes it possible to run the Bitcoin Computer as a light client as the inputs of a transaction contain pointers to the transactions that contain the expressions that need to be evaluated first."]},{"l":"Smart Contract Language","p":["The programming language used for the Bitcoin Computer has the exact same syntax as Javascript. However there is one important semantic difference:","All values returned from evaluating an expression that have object type must inherit from Contract.","The class Contract is exported from the library. It enforces the following properties, which we think turn Javascript into a viable smart contract language."]},{"l":"Assigning Properties Outside of Function Calls is Prohibited","p":["Assigning to a property outside of a function call throws an error.","This makes it possible to write classes that impose constraints on all future values of an object. Consider for example the class Even below. The condition guarantees that all instances of the class will always have an even value.","While this is not a very useful example for a constraint, all smart contracts are based on constraints to future values in a similar way."]},{"l":"Keyword Properties Control the Transaction Being Built","p":["The Contract class enforces certain types for the properties _id, _rev, _root, _amount, _owners, _readers, and _url:","The properties _id, _rev, and _root are read only and set by the runtime to relay information about which transaction created the object and where it is currently stored.","The value of the _id property is the output (encoded as <transaction id>:<output index>) that represented the object immediately after it was created.","The value of the _rev property is the output of the currently representing the object (that is, the object's revision).","The value of the _root property is assigned once when the object is created and is never modified subsequently. If the expression that creates the object is of the form new C(...) then its root is equal to its id. If the expression is of the form x.f(...) then the root of the new object is equal to the id of x. Otherwise the root is set to n/a. The root property is useful for building fungible tokens.","The properties _amount, _owners, _readers, and _url can be set by the smart contract developer to influence how the transaction is built.","If a property _amount is set it needs to be set to a number. It determines the amount of Satoshi stored in the output representing the current revision. If it is not set the revision will have a minimal (non-dust) amount of Satoshi.","If a property _owners is set it needs to be set to an array of strings [p_1\\ ...\\ p_n]. These determine the output script of the current revision. Specifically, the script for the current revision is a 1-of-n multisig script with the public keys p_1\\ ...\\ p_n. This guarantees that only a user that has a private key corresponding to one of the public keys can update the object. If the property is not set it defaults to the public key of the computer that created the object.","If a property _readers is set it needs to be set to an array of strings [p_1\\ ...\\ p_n]. If this property is set the meta data in the corresponding transaction is encrypted such that only users with corresponding private keys can decrypt the expression and compute the value of the smart object. If the _readers property is not set the meta data is not encrypted and any user can compute the value of the smart object.","If a property _url is set it needs to be set to the url of a Bitcoin Computer node. If it is set the expression is not stored in the transaction but on the node instead. The transaction only contains a hash of the expression and the location where the expression can be obtained from the node. This is convenient if the expression is large, for example because it contains a lot of data."]},{"l":"Assigning to this in Constructors is Prohibited","p":["This is not a property that we think this will make Javascript a better smart contract language, it is just a consequence how we enforce the properties above. In order to have useful constructors it is possible to pass an initialization object into the constructor:","This has the same effect as setting assigning to this in a normal Javascript program"]}],[{"l":"Computer API","p":["The Computer class can create smart objects, query for the latest revision of these, and provides the basic functionalities of a Bitcoin wallet. The table below list all of it's methods."]}],[{"l":"broadcast","p":["Broadcasts a Bitcoin transaction to the Bitcoin mining network."]},{"l":"Type"},{"l":"Syntax"},{"l":"Parameters"},{"l":"tx","p":["A Bitcoin transaction object."]},{"l":"Return value","p":["If broadcast is successful, it returns an string encoding the transaction id. Otherwise, an error is thrown."]},{"l":"Examples"}],[{"l":"constructor","p":["Creates an instance of the Computer class."]},{"l":"Type"},{"l":"Syntax"},{"l":"Parameters"},{"l":"config","p":["2","30000 on LTC and 3000 on BTC","A configuration object","BIP32 passphrase","BIP32 path","BIP39 mnemonic phrase","chain","Default Value","Description","Dust relay fee","dustRelayFee","Fee in satoshi per byte","https://node.bitcoincomputer.io","Key","LTC","m/44'/0'/0'","mnemonic","network","passphrase","path","Random phrase","satPerByte","Target blockchain. Values can be 'LTC' or 'BTC'","Target network. Values in 'testnet', 'regtest' or 'mainnet'","testnet","The empty string","url","Url of a Bitcoin Computer Node"]},{"l":"Return Value","p":["An instance of the Computer class"]},{"l":"Examples"}],[{"l":"decode","p":["Parses a Bitcoin transaction to determine if it is a Bitcoin Computer transaction. If so it returns an expression exp, a blockchain environment env, and a module specifier mod. The inverse of encode when the latter was invoked providing exp, env, and mod."]},{"l":"Type"},{"l":"Syntax"},{"l":"Parameters"},{"l":"tx","p":["A Bitcoin transaction object."]},{"l":"Return value","p":["It returns a Bitcoin transaction and an object of type Effect.","The object of type Effect captures the changes induced by evaluating the expression: It contains the result of the evaluation (property res) and the side effects of the evaluation (property env). The object of type Effect can be used to determine if the evaluation had the desired effect. If it did, the transaction can be broadcast to commit the update to the blockchain. If the transaction is not broadcast, the state on the blockchain does not change. The transaction can be broadcast at an arbitrarily long delay after calling encode. If during the time between calling encode and broadcasting the transaction the blockchain undergoes any updates that could affect the evaluation, the miners will reject the transaction. However, if the transaction is accepted by the miners, it is guaranteed to have the effect indicated by object of type Effect.","If fund is required, and the wallet has insufficient funds, an error is thrown. If sign is required, the default behavior is to sign all inputs. The encode function will make a best effort to sign all inputs, but will not throw any error if the signature cannot be added due to hash mismatch. This is useful in the case of partially signed transactions, where a user can encode an expression, sign with the user private key and send the generated partially signed transaction to another user. Then, the receiver can sign the remaining inputs."]},{"l":"Examples"}],[{"l":"deploy","p":["The deploy function broadcasts a transaction containing an ES6 module. Modules can also import other modules that have been deployed to the blockchain previously (see example below).","Deploying your code has the advantage that many objects can import the same module. This saves transaction fees, as large pieces of code can be deployed once and then used to create or update many smart objects.","Please note that modules are currently not encrypted, even if objects that use them have the _readers property set.","Previously this function was called export but this name is deprecated since version 0.16.0."]},{"l":"Syntax"},{"l":"Type"},{"l":"Parameters"},{"l":"exp","p":["A string encoding a javascript class that extends from Contract."]},{"l":"Return value","p":["The return value is a string encoding the location where the object is stored."]},{"l":"Examples"}],[{"l":"encode","p":["The functions encode and decode provide the core functionality of the Bitcoin Computer: recording Javascript expressions on the blockchain and computing their values. The basic interface is syntactic sugar on top of the basic interface. The advanced interface is a more efficient than the basic interface and it provides access to advanced features.","The encode function evaluates a Javascript expression on a blockchain. It returns a Bitcoin transaction and an object of type Effect (see return type).","If the expression to encode contains free variables (for example the variable x in the expression x.f()) an environment must be passed in to define where the free variables are defined. Specifically, an environment is a JSON object that maps variables to their respective revisions.","If a module specifier is provided, the exports of that module are imported when the expression is evaluated. The module specifier can also be used to query for all objects that were created in expressions that imported that module specifier.","Other options can customize the funding and signing process."]},{"l":"Syntax"},{"l":"Type"},{"l":"Parameters"},{"l":"opts","p":["An object with the basic configuration parameters to encode the expression in a transaction."]},{"l":"Return value","p":["It returns a Bitcoin transaction and an object of type Effect.","The object of type Effect captures the changes induced by evaluating the expression: It contains the result of the evaluation (property res) and the side effects of the evaluation (property env). The object of type Effect can be used to determine if the evaluation had the desired effect. If it did, the transaction can be broadcast to commit the update to the blockchain. If the transaction is not broadcast, the state on the blockchain does not change. The transaction can be broadcast at an arbitrarily long delay after calling encode. If during the time between calling encode and broadcasting the transaction the blockchain undergoes any updates that could affect the evaluation, the miners will reject the transaction. However, if the transaction is accepted by the miners, it is guaranteed to have the effect indicated by object of type Effect.","If fund is required, and the wallet has insufficient funds, an error is thrown. If sign is required, the default behavior is to sign all inputs. The encode function will make a best effort to sign all inputs, but will not throw any error if the signature cannot be added due to hash mismatch. This is useful in the case of partially signed transactions, where a user can encode an expression, sign with the user private key and send the generated partially signed transaction to another user. Then, the receiver can sign other inputs."]},{"l":"Examples"}],[{"l":"encodeCall","p":["Encodes a function call on a smart object."]},{"l":"Syntax"},{"l":"Type"},{"l":"Parameters"},{"l":"params","p":["An object with the basic configuration parameters to encode the expression in a transaction."]},{"l":"Return value","p":["It returns a Bitcoin transaction and an object of type Effect (see encode return type)."]},{"l":"Examples"}],[{"l":"encodeNew","p":["Encodes a smart object creation."]},{"l":"Syntax"},{"l":"Type"},{"l":"Parameters"},{"l":"constructor","p":["A named Javascript class that extends from Contract"]},{"l":"args","p":["Arguments to the constructor of T"]},{"l":"mod","p":["A module specifier, i.e., the revision string of an already deployed module (see deploy)."]},{"l":"Return value","p":["It returns a Bitcoin transaction and an object of type Effect (see encode return type)."]},{"l":"Examples"}],[{"l":"fund","p":["Funds a Bitcoin transaction."]},{"l":"Syntax"},{"l":"Type"},{"l":"Parameters"},{"l":"tx","p":["A Bitcoin transaction object."]},{"l":"opts","p":["An optional object can be passed as parameter to include or exclude certain UTXOs. When using include, the transaction will be funded with the UTXOs specified as the first inputs."]},{"l":"Return value","p":["If the wallet does not have sufficient funds, an error is thrown."]},{"l":"Examples"}],[{"l":"getAddress","p":["Returns a string encoding Bitcoin address."]},{"l":"Syntax"},{"l":"Type"},{"l":"Return value","p":["Returns a string encoding Bitcoin address."]},{"l":"Examples"}],[{"l":"getBalance","p":["Returns the current balance in satoshi."]},{"l":"Syntax"},{"l":"Type"},{"l":"Return value","p":["Returns the current balance in satoshi."]},{"l":"Examples"}],[{"l":"getChain","p":["Returns the chain."]},{"l":"Syntax"},{"l":"Type"},{"l":"Return value","p":["Returns a string encoding the chain."]},{"l":"Examples"}],[{"l":"getMnemonic","p":["Returns a string encoding a BIP39 mnemonic sentence."]},{"l":"Syntax"},{"l":"Type"},{"l":"Return value","p":["Returns a string encoding the network."]},{"l":"Examples"}],[{"l":"getNetwork","p":["Returns the network."]},{"l":"Syntax"},{"l":"Type"},{"l":"Return value","p":["Returns a string encoding the network."]},{"l":"Examples"}],[{"l":"getPassphrase","p":["Returns the BIP39 passphrase."]},{"l":"Syntax"},{"l":"Type"},{"l":"Return value","p":["Returns the BIP39 passphrase."]},{"l":"Examples"}],[{"l":"getPrivateKey","p":["Returns a string encoded private key."]},{"l":"Syntax"},{"l":"Type"},{"l":"Return value","p":["Returns a string encoded private key."]},{"l":"Examples"}],[{"l":"getPublicKey","p":["Returns a string encoding a public key."]},{"l":"Syntax"},{"l":"Type"},{"l":"Return value","p":["Returns a string encoding a public key."]},{"l":"Examples"}],[{"l":"getUtxos","p":["Returns an array of unspent transaction outputs (UTXOs)."]},{"l":"Syntax"},{"l":"Type"},{"l":"Return value","p":["Returns an array of unspent transaction outputs (UTXOs)."]},{"l":"Examples"}],[{"l":"load","p":["Imports a ES6 module from a module specifier."]},{"l":"Syntax"},{"l":"Type"},{"l":"Parameters"},{"l":"rev","p":["A string encoding a javascript class that extends from Contract."]},{"l":"wallet","p":["A wallet object."]},{"l":"Return value","p":["A ES6 module."]},{"l":"Examples"}],[{"l":"new","p":["Creates a new smart object. The parameters are a smart contract (a Javascript class inheriting from Contract), a list of arguments for the constructor of the class and an optional module specifier. The arguments of the constructor can be of basic data type or smart objects. The new function builds a transaction that records the creation of a new smart object, signs it and broadcasts it. Smart objects can be updated by calling their functions, see here."]},{"l":"Syntax"},{"l":"Type","p":["Here a Location is the type"]},{"l":"Parameters"},{"l":"constructor","p":["A named Javascript class that extends from Contract"]},{"l":"args","p":["Arguments to the constructor of T"]},{"l":"mod","p":["A module specifier, i.e., the revision string of an already deployed module (see deploy)."]},{"l":"Return value","p":["Returns an instance of the class T. The class T should extend from Contract. The returned object has extra properties _id, _rev, _root, _owners, _amount and possibly _url, _readers."]},{"l":"Examples"}],[{"l":"query","p":["Returns the latest revisions of smart objects. Conditions can be passed in to determine the smart objects. When multiple conditions are passed in, the latest revisions of the smart objects that satisfy all conditions are returned."]},{"l":"Syntax"},{"l":"Type"},{"l":"Parameters"},{"l":"params","p":["An object with the query parameters."]},{"l":"Return value","p":["Given the query parameters, returns an array of strings encoding the latest revisions of smart objects that matches the specified conditions."]},{"l":"Examples"}],[{"l":"rpcCall","p":["Calls a Bitcoin RPC method with the given parameters."]},{"l":"Syntax"},{"l":"Type"},{"l":"Parameters"},{"l":"method","p":["An string encoding the name of the rpc function to be called."]},{"l":"params","p":["An string with the argument list of the rpc function call to be called, separated by spaces."]},{"l":"Return value","p":["A JSON object with the result of the rpc method call."]},{"l":"Examples"}],[{"l":"send","p":["Sends a payment."]},{"l":"Syntax"},{"l":"Type"},{"l":"Parameters"},{"l":"amount","p":["A number representing the amount of satoshis to be sent."]},{"l":"address","p":["An string encoding the receiver address."]},{"l":"Return value","p":["If successful, it returns an string encoding the transaction id of the payment."]},{"l":"Examples"}],[{"l":"sign","p":["Signs a Bitcoin transaction. Options can be passed in that determine which inputs to sign, the sigHash type to use, and which script to use."]},{"l":"Syntax"},{"l":"Type"},{"l":"Parameters"},{"l":"tx","p":["A Bitcoin transaction, possibly partially signed."]},{"l":"opts","p":["An object with specific parameters to use when signing"]},{"l":"Return value","p":["By default, the sign function will make a best effort to sign all inputs, but will not throw any error if the signature cannot be added due to hash mismatch. This is useful in the case of partially signed transactions, where a user can encode an expression, sign with the user private key and send the generated partially signed transaction to another user. Then, the receiver can sign other inputs."]},{"l":"Examples"}],[{"l":"sync","p":["Returns the smart object stored at a given location (revision or transaction id)."]},{"l":"Syntax"},{"l":"Type"},{"l":"Parameters"},{"l":"location","p":["An string encoding a revision (transaction id : output number) where the smart object is located; or an string encoding a transaction id."]},{"l":"Return value","p":["If a revision is provided as parameter, returns the smart object stored at the provided location. If a transaction id is provided as parameter, returns an object of type Effect encoding the result and the environment of the expression encoded in that transaction. In this case, the sync function will try to find any smart object over the outputs list. If the parameter is not a valid revision or transaction id, an error is thrown."]},{"l":"Examples"}]]