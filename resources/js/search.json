[[{"l":"Introduction","p":["The Bitcoin Computer (TBC) is a Turing-complete smart contract system for Bitcoin and Litecoin. You can build decentralized applications, such as tokens, exchanges, games, social networks, and more.","Free Computation. The most important feature of TBC is that the execution cost is independent of the computational complexity of the smart contract. For most other smart contract systems, the execution cost increases with each computational step. Instead, the cost on TBC is fixed for an unlimited number of computational steps.","JavaScript. Smart contracts are JavaScript or TypeScript classes. This makes it seamless to integrate smart contracts into web applications and makes development easy due to the existing JavaScript ecosystem.","How it works. You can inscribe a JavaScript class to deploy a smart contract. Then, you can inscribe a constructor call to create a smart object and a function call to update a smart object.","Data Ownership. Conceptually, a smart object is stored in a UTXO, and only the owner of the UTXO can update its state. This captures a natural notion of data ownership that is as secure as ownership of Bitcoin.","Historical States. As every update is recorded in a separate transaction, every historical state of a smart object can be recovered, together with information about who updated it and when.","Encryption and Off Chain Storage. By default, every user can read all states of all smart objects. However, TBC has support for end-to-end encryption and storing data off-chain built-in. These properties make it easy to build applications that comply with consumer protection laws such as CCPA and GDPR.","Pure Bitcoin. Finally, TBC relies only on Bitcoin. It does not require a side-chain or an extra token. This makes it possible to build applications that are as stable as Bitcoin.","Contact. TBC is being developed by BCDB Inc. If you have any questions, please let us know in our Telegram group, on Twitter, or by email at clemens@bitcoincomputer.io."]}],[{"l":"Start","p":["You can try the Bitcoin Computer without installing or downloading any software. Just create a file index.html and open it in your browser.","When the website is rendered you will see Value: *. When the smart object is created you will see Value: 0. After the smart object update you will see Value: 1."]},{"l":"Development","p":["For serious development you need to have node.js installed. First download and install the Bitcoin Computer library from Npm.","Then create a file index.mjs.","Execute the smart contract.","The expected output is:"]},{"l":"Serious Development","p":["In the setup described above, you are using our node and are subject to the rate limiter there. To try the Bitcoin Computer without rate limiter, please follow the instructions of the readme file of the Bitcoin Computer Node."]},{"l":"Download","p":["You can download all Bitcoin Computer related material (including the library, node, these docs, and example applications) by cloning the monorepo."]}],[{"l":"Tutorial"},{"l":"Write a Smart Contract","p":["Smart contracts are Javascript or Typescript classes that extend from Contract. For example, a smart contract for a simple chat is","Note that it is not possible to assign to this in constructors. Instead you can initialize a smart object by passing an argument into super as shown above."]},{"l":"Create a Computer Object","p":["You need to create an instance of the Computer class in oder to deploy smart contracts and create smart objects.","You can pass in a BIP39 mnemonic to initialize the wallet in the computer object. To securely generate a random mnemonic leave the mnemonic key undefined. You can find more configuration options here."]},{"l":"Create a Smart Object","p":["The computer.new function creates a smart object from a smart contract.","The object chat that is returned has the properties defined in the class and five extra properties _id, _rev, _root, _owners and _amount.","The property _owners is an array of public keys that are able to spend that UTXO and the property _amount is the amount of satoshis in that UTXO. The meaning of the other properties are explained below.","The properties _id, _rev, _root reference a transaction that is broadcast when the expression await computer.new(Chat, ['hello']) is evaluated. This transaction encodes the expression","Another user can download this transaction and evaluate this expression to obtain a copy of the smart object. This can be done using the computer.sync function described in the next section."]},{"l":"Read a Smart Object","p":["The computer.sync function computes the state of smart object. For example, synchronizing to 667c...2357:0 will return an object with the same value as chat.","You can find more details about how this works here."]},{"l":"Update a Smart Object","p":["A Smart object can be updated by calling one of it's functions. Note that you have to await on all function calls to read the latest state.","When a function is called, a transaction is broadcast that inscribes the expression of the function call. In the example, the transaction with id de43...818a inscribes the expression","Note that the _rev property of the chat object has been updated to de43...818a:0. Every time a smart object is updated a new revision is created. The corresponding transaction id and output number is assigned to the _rev property. The _id property is never updated and is a unique identifier for each smart object. You can find more details about updating smart object here.","The computer.sync function maps revisions to historical states. It can be called with any historical revision. It will return the current state for the latest revision."]},{"l":"Find a Smart Object","p":["The computer.query function returns the latest revision of a smart objects. It can be called with many different kinds of arguments, for example object one or more ids:","A basic pattern for many applications is to identify a smart object by its id, look up the object's latest revision using computer.query, and then to compute its latest state using computer.sync. For example, imagine a chat app where the url would contain the id of a specific chat. The app could compute the latest state of the chat as follows:"]},{"l":"Data Ownership","p":["Every smart object can have up to three owners. Only an owner can update the object. The owners can be set by assigning string encoded public keys to the _owners property of a smart object. If the _owners property is not assigned in a smart contract it defaults to the public key of the computer object that created the smart object.","In the chat example the initial owner is the public key of the computer object on which computer.new function was called. Thus only a user with the private key for that public key will be able to post to the chat. We can add a function invite to update the owners array to allow more users to post."]},{"l":"Privacy","p":["By default, the state of all smart objects is public in the sense that any user can call the computer.sync function on an object's revision. However, you can restrict read access to an object by setting its _readers property to an array of public keys. If _readers is assigned, the meta-data on the transaction is encrypted using a combination of AES and ECIES. Only the specified readers can decrypt an encrypted object using the computer.sync function.","For example, if we want to ensure that only people invited to the chat can read the messages, we can update our example code as follows:","A user can (only) read the state of a smart object if they have read access to the current and all previous versions of the object. It is, therefore, not possible to revoke read access to a revision after it has been granted. However, it is possible to remove a user's ability to read the state of a smart object from a point in time forwards.","When smart objects are encrypted the flow of cryptocurrency is not obfuscated."]},{"l":"Off-Chain Storage","p":["Not all data needs to be stored on the blockchain. For example, personal information should never be stored on chain, not even encrypted.","When the property _url of a smart object is set to the URL of a Bitcoin Computer Node, the metadata of the current function call is stored on the specified Bitcoin Computer Node. The blockchain contains a hash of the meta data and a link to where it can be retrieved.","For example, if we want to allow users to send images that are too large to be stored on chain to the chat, we can make use of the off-chain solution:"]},{"l":"Cryptocurrency","p":["Each smart object can store an amount of cryptocurrency. By default a smart object stores a minimal (non-dust) amount. If the _amount property of a smart object is set to a number, the output storing that smart object will contain that number of satoshis. For example, consider the class Payment below.","If a user A wants to send 210000 satoshis to a user B, the user A can setup the payment as follows:","When the payment smart object is created, the wallet inside the computerA object funds the 210000 satoshi that are stored in the payment object. Once user B becomes aware of the payment, he can withdraw by syncing against the object and calling the cashOut function.","One more transaction is broadcast for which user B pays the fees. This transaction has two outputs: one that records that the cashOut function was called with 546 satoshi and another that spends the remaining satoshi to user B's address."]}],[{"l":"How it Works"},{"l":"Intuition","p":["A Bitcoin Computer transaction is a Bitcoin transaction with a Javascript expression inscribed. The value of the expression is associated with the first output of the transaction. If the value is an object or array that has sub-objects, then each sub-object is associated with a distinct output of the transaction.","If the expression contains a free variable (for example the variable x is free in the expression x + 1), then that free variable has to be associated with an input of the transaction. To determine the values of the outputs, the Bitcoin Computer recursively determines the values of each output spent. The free variable is then substituted with the value before the expression is evaluated."]},{"l":"Basic Example","p":["In the examples below, white boxes represent transactions and grey boxes represent expressions inscribed. Inputs and outputs are displayed as circles and spending relations are shown as arrows.","Consider a transaction with the expression 1+2 inscribed. As this expression evaluates to 3, the Bitcoin Computer will associate the first output with the value 3.","If this output is spent by a transaction with an inscription x+4 and the first input is associated with x, the Bitcoin Computer determines the value of the output spent by that input. In the example that output has the value 3. Hence, the output of the second transaction has the value 7."]},{"l":"Detailed Description"},{"l":"Smart Contracts and Objects","p":["We will refer to a Javascript expression that is inscribed in a transaction as a smart contract. The value that such an expression evaluates to is called a smart value. If a smart value is of object type we refer to it as a smart object."]},{"l":"Data Ownership","p":["The method of associating data values to outputs described above gives rise to a natural notion of data ownership: A smart value that is owned by the users that can spend that output. This is analogous to how satoshis in an output are owned by the users that can spend the output.","The Bitcoin Computer adds a property _owners to every smart object. It is set to the array of the public keys of the owners. Conversely, if an object is created with a property _owners that is set to an array of n string encoded public keys, then the output that represents the object has a 1-of- n multisig script with these public keys."]},{"l":"Creating Objects and Object Identity","p":["One advantage of associating values with transaction outputs is that the transaction id and output number can be used as an identity for the object. Whenever a smart object is created the Bitcoin Computer assigns the identity to a property _id of the object. The object identity cannot be reassigned and remains fixed throughout the lifetime of the object."]},{"l":"Updating Objects and Object Revisions","p":["Whenever a smart object is updated a transaction is broadcast that spends the outputs representing the object's old state. The outputs of the transaction are associated with the new state of the object. The transaction id and output number that is associated with the new state of an object is referred to as it's revision. The revision is assigned to a property _rev of the object."]},{"l":"Ancestors and Roots of Objects","p":["If an object is created in a function call of the form x.f(...) we say that x is its parent. We say that an object x1 is the ancestor of an object xn if there is a sequence of objects z2 ... zn-1 such that xi is the parent of xi_1 for all i. The root of an object is its (unique) ancestor that does not have a parent. The Bitcoin Computer assigns the root of an smart object to the property _root. The root can be used to create fungible tokens with the Bitcoin Computer."]},{"l":"Examples"},{"l":"Non Fungible Tokens","p":["The code on the left side of the picture below defines a class NFT with two properties _owners and url and a method send to update the _owners. The _owners property of a smart contract can be set to an array of string encoded public keys.","The right side of the picture shows a transaction in which both the class and a constructor call is inscribed. This expression evaluates to a new object of class NFT. It also shows that all three special properties _id, _rev, _root_ are assigned the same value: the transaction id of the transaction shown and output number 1 (we represent this string as a blue circle in the picture).","The picture below shows the same object after two updates. First, the expression nft.send('038e2...') is evaluated where nft refers to the object immediately after the constructor call. The second update is due to the evaluation of the expression nft.send('03f0b...') where this time nft refers to the object after the first update. We can see that the revision is changed after every update but the identity and the root stays the same.","The computer.sync function can be called with each revision of a smart object. This provides access to all historical states of a smart object."]},{"l":"Fungible Tokens","p":["The figure below illustrates the minting and sending of 100 fungible tokens. The blue user, with public key 03a1d..., mints the tokens in the first transaction, producing one output that represents the 100 newly minted tokens. The second transaction represents the distribution of tokens after the blue user sends 3 tokens to the green user, with public key 03f0b....","The blue output of the second transaction represents the 97 tokens that the blue user still holds, while the green output represents the three tokens now owned by the green user. The _ root property of both outputs in the second transaction is linked to the output of the first transaction, as the memory cell for the three tokens was allocated within a function call.","This setup prevents forgery, as any two tokens with the same root can be traced back to the same mint. To mint a second token with the same root, one would have to broadcast a transaction with the transaction id of the first transaction, which is impossible."]}],[{"l":"Smart Contract Language","p":["The Bitcoin Computer uses Javascript with slight modifications. Specifically:","Property assignments are not permitted outside function calls. This makes it possible to impose constraints on all future values of an object, thereby making Javascript a viable smart contract language","Certain keyword properties have a special semantics. This gives the smart contract programmer fine grained control over the transaction being built.","Assignments to this is not permitted in constructor calls. This is necessary for internal reasons to ensure the first two properties.","These properties are technically enforced by the requirement that all objects returned from a smart contract inherit from a class Contract that is exported from the Bitcoin Computer Library.","In the following we explain the three properties in detail."]},{"l":"Assigning Properties Outside of Function Calls is Prohibited","p":["Assigning to a property outside of a function call throws an error.","This makes it possible to write classes that impose constraints on all future values of an object. Consider for example the class Even below. The condition guarantees that all instances of the class will always have an even value.","Calling even.inc2() works as expected.","However, assigning to even.n outside of a function call throws an error.","While this is not a very useful example for a constraint, all smart contracts are based on constraints to future values in a similar way."]},{"l":"Special Semantics of Keyword Properties","p":["The Bitcoin Computer uses special properties (called keyword properties) that","control details of the transaction being build, and","give the user information as to where on the blockchain a smart object was created and where it is currently stored.","In the following we describe these properties in details"]},{"l":"Control Keyword Properties","p":["Properties named _amount, _owners, _readers, and _url provide control over the transaction being built. These properties can optionally be set in the smart contract.","The effect that these properties have on the transaction being built is described below:","If a property _amount is set it needs to be set to a number. It determines the amount of Satoshi stored in the output representing the current revision. If it is not set the revision will have a minimal (non-dust) amount of Satoshi.","If a property _owners is set it needs to be set to an array of strings [p_1\\ ...\\ p_n]. These determine the output script of the current revision. Specifically, the script for the current revision is a 1-of-n multisig script with the public keys p_1\\ ...\\ p_n. This guarantees that only a user that has a private key corresponding to one of the public keys can update the object. If the property is not set it defaults to the public key of the computer that created the object.","If a property _readers is set it needs to be set to an array of strings [p_1\\ ...\\ p_n]. If this property is set the meta data in the corresponding transaction is encrypted such that only users with corresponding private keys can decrypt the expression and compute the value of the smart object. If the _readers property is not set the meta data is not encrypted and any user can compute the value of the smart object.","If a property _url is set it needs to be set to the url of a Bitcoin Computer node. If it is set the expression is not stored in the transaction but on the node instead. The transaction only contains a hash of the expression and the location where the expression can be obtained from the node. This is convenient if the expression is large, for example because it contains a lot of data."]},{"l":"Location Keyword Properties","p":["The properties _id, _rev, _root contain information about where a smart object was created and where it is currently stored. These properties are set by the runtime. While they can be read, attempts to overwrite their state will lead to an error.","The value of the _id property is the output (encoded as <transaction id>:<output index>) that represented the object immediately after it was created.","The value of the _rev property is the output of the currently representing the object (that is, the object's revision).","The value of the _root property is assigned once when the object is created and is never modified subsequently. If the expression that creates the object is of the form new C(...) then its root is equal to its id. If the expression is of the form x.f(...) then the root of the new object is equal to the id of x. Otherwise the root is set to n/a. The root property is useful for building fungible tokens."]},{"l":"Assigning to this in Constructors is Prohibited","p":["In order to enforce the properties above, it is currently not permitted to assign to this in constructor calls. Instead, an initialization object can be passed into the constructor:","This has the same effect as setting assigning to this in a normal Javascript program"]}],[{"l":"Transaction Format","p":["Coming soon."]}],[{"l":"Examples","p":["Method","Description","Non Fungible Token (NFT)","A non fungible token similar to ERC721","Fungible Token","A fungible token similar to ERC20","Encrypted Chat","An encrypted chat","Swap","Trustlessly exchange two smart object","Sale","Trustlessly sell a smart object to an unknown buyer"]}],[{"l":"Non Fungible Token"},{"l":"Smart Contract","p":["Our example class for a non-fungible token only has two properties name and symbol. It has one function transfer that updates the _owners property."]},{"l":"Usage","p":["To create a non-fungible token you can call the new function as shown below. The faucet function funds the sender object when the sender object is configured to regtest. The sender.new function mints a new NFT and the transfer function send the NFT to another user.","If more than one NFT are broadcast one can save transaction fees by broadcasting a module containing the NFT smart contract first. The class TCB721 is a helper class for that purpose."]},{"l":"Code","p":["You can find the code here."]}],[{"l":"Fungible Token"},{"l":"Smart Contract","p":["A fungible token has three properties, a supply indicating the number of tokens stored in the current smart object, a property totalSupply that that stores the number of tokens that were created during the mint, and an _owners property set to the current owner of the smart object.","The transfer function takes two arguments, an amount to be sent and the public key of the recipient. This function first checks if the current smart object contains sufficient supply and throws an error if it does not. If the supply is sufficient the supply of the current smart object is reduced by the amount to be sent. A new smart object is created that is owned by recipient and that contains the amount to be sent. This object is returned from the function call to create a new smart object."]},{"l":"Usage","p":["The usage is as in the case of a non-fungible token."]},{"l":"Code","p":["You can find the code here."]}],[{"l":"Chat"},{"l":"Smart Contract","p":["A chat is just a smart object with a property messages of type string[]. Like all smart objects it has an _owners property set to the current data owner. The _readers property can be used to restrict read access."]},{"l":"Usage","p":["A new chat can be created using the new function. Note that Bob can initially post to the chat and read it's state as Bob's public key was added to the _owners array and _readers array by Alice upon creation of the chat.","Later, Alice called the remove function removing Bob's public key from these arrays. After this point Bob cannot read or write anymore.","Eve was never part of the _readers array so she cannot read the content of the chat, nor write to it."]}],[{"l":"Swaps"},{"l":"Swap Using a Static Function","p":["The recommended way to build a swap is to use a static function that takes two arguments and exchanges their owners. This method preserves ordinal ranges, so it is safe to use this smart objects that contain ordinals."]},{"l":"Smart Contracts","p":["The code below shows the NFT class. While this example uses NFTs as arguments, the same function can be used to swap any pair of smart objects that have a transfer function."]},{"l":"Minting the NFTs","p":["Alice and Bob mint NFTs using the computer.new function."]},{"l":"Building the Swap Transaction","p":["A swap transaction has two inputs and two outputs. The inputs spend the NFTs to be swapped. The two outputs of the transaction are the NFTs after the swap with their owners exchanged.","Alice passes an expression containing both the code of the StaticSwap class and the expression StaticSwap.exec(a, b) to the encode function. The second argument is an environment that determines that the smart objects a and b are stored at revisions a._rev and b._rev.","The encode function will automatically sign all inputs of the transaction that can be signed with the private key of the computer object on which the function is called. In this case, this is the input as revision a._rev."]},{"l":"Executing the Swap","p":["Then Bob signs the input b._rev and broadcasts the transaction. When the transaction is included in the blockchain the swap is executed and the owners of the two NFTs are reversed."]},{"l":"Full Example","p":["The code snippet below shows how to create two nfts and swap them using the smart contract above."]},{"l":"Reducing Fees","p":["The disadvantage of the code above is that the swap class is written into the blockchain on every swap. This wasts block space and is expensive. A more efficient approach is to deploy the Swap function as a module first and then refer to the module from the transactions executing the swap. To make this easier, we provide a helper class SwapHelper for swaps and TBC721 for NFTs that can be used as follows:"]},{"l":"Swap Using a Method","p":["Another possibility is to add a swap function directly to an NFT. The use is similar to above."]},{"l":"Code","p":["Have a look at the code on Github for details."]}],[{"l":"Sales","p":["These examples use several advanced features (sighash types, mocking, and controlling the order of inputs and outputs, ordinal safe programming) that are not sufficiently documented elsewhere. If you would like to use these features we suggest to ask about their safe use here.","In this section we explain how a smart object can be sold at a predetermined price without requiring trust between seller and buyer. Unlike in a swap where both objects are known in advance, the output that the buyer will provide later is unknown at the time of initiating the swap transaction. To address this problem, the Bitcoin Computer offers a feature called 'mocking,' which enables the Seller to create a mock-up of the payment object that the buyer will create later."]},{"l":"Smart Object Sale","p":["We first explain how to execute the sale of a smart object. The smart contract is quite simple but does not preserve the ordinal ranges of the smart object being sold. It is therefore not safe to use with ordinals. The next section explains a slightly more complicated swap that can be used with ordinals.","The idea is to build a \"crossover\" transaction with two inputs and two outputs. The first input of the transaction spends the NFT n, and the second input will spend the payment p. The first output of the transaction will be p, and the second output will be n after the swap.","Seller signs the first input and output with the sighash type SIGHASH_SINGLE | SIGHASH_ANYONECANPAY so that any other user can modify the second input and output or add arbitrary inputs and outputs as longs as the input-output pair signed by Seller have the same index. As the input-output pair is signed, Seller is guaranteed that if a transaction containing the pair is included in the blockchain then Seller will get paid.","Buyer on the other hand wants to obtain the NFT in the first input so Buyer is incentivized to build the transaction according to the protocol. If the Buyer misbehaves, the worst thing that can happen is that Buyer destroys the NFT and pays the Seller (for example buy broadcasting a transaction with meta data that is invalid under the Bitcoin Computer protocol)."]},{"l":"Smart Contracts","p":["The first challenge is to build a \"crossover\" transaction where we have to control the order of inputs and outputs. This is possible with the Bitcoin Computer because the order of inputs is determined by the order of objects in the environment and the order of outputs is determined by the order of objects in the value returned from the expression.","Seller calls encode with an environment { n: ..., p: ... }, indicating that the first input will spend n and the second input will spend p. Seller will use the expression ${Sale} Sale.exec(n, p). As the exec function of the Sale contract returns an array [p, n] the first output wil represent p and the second output will represent n. This is exactly the \"crossover\" transaction described above.","The first argument to the exec function is an nft of the following class.","The second argument is created by Buyer to pay for the nft.","In the following sections, we explain the process of seller minting an NFT and creating a sales transaction as well as a buyer going through a purchase."]},{"l":"Minting an NFT","p":["To mint an nft, Seller can use the computer.new function."]},{"l":"Building the Sales Transaction","p":["The challenge in creating the sales transaction arises from the fact that the output containing the payment is not yet created at the time of building the transaction. This is a problem because, in order to evaluate an expression on the Bitcoin Computer, either a smart object or a revision of an existing smart object is required for all parameters of the call.","To handle such scenarios the Bitcoin Computer provides a feature called mocking. A mock is a class that has the properties _id, _rev, _root, _amount, and _owners, and sets them to strings of the form mock:transaction-id:output-number. A mock does not have to extend from Contract. Each mocked object must have a distinct transaction id and output number.","The following code shows the class to create the payment mock as well as Seller creating a new instance with the standard Javascript new keyword.","Now Seller is ready to create and sign the sale transaction using computer.encode as shown below. There is a lot going on, so we will break down the arguments below.","The expression contains the source code of the Sale class and an expression that calls the static exec function. Note that every time a sale transaction is created, the source code of the Sale class is written into the blockchain again. A more efficient approach is to deploy the Sale class as a module first. This is described here.","The next two lines contain the instructions for the mocking system. Seller can use the mock object that was created earlier as shown in the code below. The revision of the mock is passed in as the payment revision to the environment; and an object is passed to the mocks key that maps the name payment to the mock object. If an object is mocked up, the Bitcoin Computer will build a transaction without checking that mocked up objects exist on the blockchain and will assume that the value is as in the object passed into mocks. Later buyer will update the input that spends the revision of the payment mock with the revision and output number of an actual payment.","To enable Buyer to modify Seller's transaction later, Seller signs the first input with the sighash type SIGHASH_SINGLE | SIGHASH_ANYONECANPAY. This means that Seller's signature remains valid even when arbitrary inputs and outputs are added to the transaction as long as the input and the output that Seller has signed have the same index. As the input-output pair is signed, the Seller is guaranteed that if a transaction containing the pair is included in the blockchain, then the Seller will get paid.","Essentially, the Seller is stating: you can spend the output containing the NFT as long as you maintain the locking script and the amount of the first output unchanged. The Seller can confidently publish such a partially signed transaction as Seller intendeds to sell the NFT spent by the first input for the amount indicated in the first output, and both are signed.","Finally, Seller set's funding to false to prevent the transaction from being funded by the encode function as he wants the Buyer to cover the transaction fees.","Seller can publish the sales transaction to interested buyers. An interested buyer can create a payment object and broadcast the sale transaction to purchase the nft. This is described in the next section."]},{"l":"Buying the NFT","p":["First, Buyer creates a smart object that can be used in the sale.","Next, Buyer updates the second input of the transaction that currently spends the payment swap. This is possible without invalidating Sellers signature as the special signhash type was used.","Then Buyer updates the second output to contain Buyer's public key. This ensures that Buyer will be new owner of the nft.","Finally Buyer funds, signs, and broadcasts to execute the sale."]},{"l":"Full Example","p":["The code below shows the whole process of minting an nft, listing it for sale, and a purchase. Working code can be found here"]},{"l":"Reducing Fees","p":["The example before is wasteful because the source code of the Sale class is written into the blockchain on every sale. To avoid this, we recommend to deploy the Sale class and refer to the module when executing a sale.","We provide a class TBC721 that helps with deploying the smart contract as a module, minting the nfts with a reference to the deployed module, transferring NFTs, and returning the balance and owner of an NFT.","The code below shows how the same flow as above can be implemented using the TBC721 class."]},{"l":"Ordinal Sale","p":["The Sale smart contract is not safe to use with ordinals because the smart objects have different ordinal ranges before and after the call. To preserve the ordinal ranges the expression must not use the _amount keyword and must not return an object or an array containing an object.","Building a sale contract for ordinals is more complicated than for smart objects. A very clever construction was proposed by Rodarmor here and later refined. Our smart contract below implements this exact idea."]},{"i":"smart-contracts-1","l":"Smart Contracts","p":["The exec function of the OrdSale class swaps the owners just like in the Sale class. However it then proceeds to double the amount of b1 and return [b1, t, p, b2].","When the exec function is evaluated, a transaction of the following form is built:","The amount of b1 after the call is the sum of the amounts of b1 and b2 before combined. The smart object b1 therefore absorbs the entire ordinals range of b2. The objects n and p do not change their amounts during the call, these objects preserve their ordinal ranges.","We now explain the whole process of minting an NFT, listing it for sale, and processing a purchase. We skip the step for minting as it was described above."]},{"i":"building-the-sales-transaction-1","l":"Building the Sales Transaction","p":["In order to build the sale transaction, Seller first needs to create the objects b1, b2, and p:","Next Seller can build the sales transaction by executing the following code:","Conceptually this is very similar to the use of encode above. Note however, that Seller signs the third input output pair this time. This is because the NFT is spent by the third input and the payment that Seller wants to obtain is in the third output."]},{"l":"Buying the Ordinal NFT","p":["This process is similar to the case of a smart object sale above. See the example blow."]},{"i":"full-example-1","l":"Full Example"},{"i":"reducing-fees-1","l":"Reducing Fees","p":["Just like in the case of selling smart object sales, one can save transaction fees by using the module system through a helper class as shown below."]},{"l":"Code","p":["You can find the code here."]}],[{"l":"Lib","p":["The Bitcoin Computer Library (available on Github and Npm) provides all the functionality needed to write smart contracts with the Bitcoin Computer.","To interface with the blockchain, the Bitcoin Computer Lib connects to a Bitcoin Computer node. By default the Bitcoin Computer Lib connects to a node in regtest node that we provide. You can find more information about configuration options in the section constructor."]},{"l":"Api"},{"l":"Basic","p":["You can build almost all smart contracts with following methods.","Method","Description","constructor","Creates an instance of class Computer","new","Creates a smart object from a smart contract","query","Finds the latest revisions of smart object","sync","Computes the state of a smart object from a given revision"]},{"l":"Advanced","p":["To build advanced applications like swaps have a look at the following.","Method","Description","encode","Encodes a Javascript expression into a Bitcoin transaction","encodeNew","Encodes a constructor call into a Bitcoin transaction","encodeCall","Encodes a function call into a Bitcoin transaction","decode","Parses a Bitcoin transaction and returns Javascript expression","faucet","Fund a computer object on Regtest"]},{"l":"Modules","p":["You can save transaction fees by using our ES6 module system.","Method","Description","deploy","Deploys an ES6 module on the blockchain","load","Loads an ES6 module from the blockchain"]},{"l":"Wallet","p":["Access Bitcoin's RPC interface","broadcast","Broadcasts a Bitcoin transaction","Description","getAddress","getBalance","getChain","getMnemonic","getNetwork","getPassphrase","getPrivateKey","getPublicKey","getUtxos","Method","Returns a BIP39 mnemonic sentence","Returns an array of unspent transaction outputs","Returns the balance in satoshi","Returns the Bitcoin address of the computer wallet","Returns the blockchain","Returns the network","Returns the passphrase","Returns the private key","Returns the public key","rpcCall","send","Sends satoshis to an address","sign","Signs a Bitcoin transaction","The wallet functionality within a Computer instance can be accessed using the following."]}],[{"l":"broadcast","p":["The broadcast function broadcasts a Bitcoin transaction to the Bitcoin mining network."]},{"l":"Type"},{"l":"Syntax"},{"l":"Parameters"},{"l":"tx","p":["A Bitcoin transaction object."]},{"l":"Return value","p":["If broadcast is successful, it returns an string encoding the transaction id. Otherwise, an error is thrown."]},{"l":"Examples"}],[{"l":"constructor","p":["The constructor of the Computer class creates an instance. It's functionality is described in this API documentation."]},{"l":"Type"},{"l":"Syntax"},{"l":"Parameters"},{"l":"config","p":["2","30000 on LTC and 3000 on BTC","A configuration object","addressType","BIP32 passphrase","BIP32 path","BIP39 mnemonic phrase","chain","Default Value","Description","Dust relay fee","dustRelayFee","Fee in satoshi per byte","https://rltc.node.bitcoincomputer.io","Key","LTC","m/44'/0'/0'","mnemonic","network","p2pkh","passphrase","path","Random phrase","regtest","satPerByte","Target blockchain. Values can be 'LTC' or 'BTC'","Target network. Values in 'testnet', 'regtest' or 'mainnet'","The address script type. Values in 'p2pkh', 'p2wpkh', 'p2tr'","The empty string","url","Url of a Bitcoin Computer Node"]},{"l":"Return Value","p":["An instance of the Computer class"]},{"l":"Examples"}],[{"l":"decode","p":["The decode function parses a Bitcoin transaction to determine if it is a Bitcoin Computer transaction. If so it returns an expression exp, a blockchain environment env, and a module specifier mod. The function decode is the inverse of encode when the latter is called with exp, env, and mod."]},{"l":"Type"},{"l":"Syntax"},{"l":"Parameters"},{"l":"tx","p":["A Bitcoin transaction object."]},{"l":"Return value","p":["It returns a Bitcoin transaction and an object of type Effect.","The object of type Effect captures the changes induced by evaluating the expression: It contains the result of the evaluation (property res) and the side effects of the evaluation (property env). The object of type Effect can be used to determine if the evaluation had the desired effect. If it did, the transaction can be broadcast to commit the update to the blockchain. If the transaction is not broadcast, the state on the blockchain does not change. The transaction can be broadcast at an arbitrarily long delay after calling encode. If during the time between calling encode and broadcasting the transaction the blockchain undergoes any updates that could affect the evaluation, the miners will reject the transaction. However, if the transaction is accepted by the miners, it is guaranteed to have the effect indicated by object of type Effect.","If fund is required, and the wallet has insufficient funds, an error is thrown. If sign is required, the default behavior is to sign all inputs. The encode function will make a best effort to sign all inputs, but will not throw any error if the signature cannot be added due to hash mismatch. This is useful in the case of partially signed transactions, where a user can encode an expression, sign with the user private key and send the generated partially signed transaction to another user. Then, the receiver can sign the remaining inputs."]},{"l":"Examples"}],[{"l":"deploy","p":["The deploy function stores an ES6 module on the blockchain and returns an identifier for that module. This identifier can be passed into the functions computer.new, computer.encode, computer.encodeNew, and computer.encodeCall to make the exports of the module available there.","The advantage of deploying your code is that it can save transaction fees: A large piece of code can be deployed once and then used to create or update many smart objects.","Please note that modules are not encrypted, even if objects that use them have the _readers property set."]},{"l":"Type"},{"l":"Syntax"},{"l":"Parameters"},{"l":"module","p":["A string encoding an ES6 module."]},{"l":"Return value","p":["A string encoding the location where the module is stored. The format is <transaction id>:<output number>."]},{"l":"Examples","p":["Previously this function was called export but this name is deprecated since version 0.16.0."]}],[{"l":"encode","p":["The encode function builds a Bitcoin transaction from a Javascript expression according to the Bitcoin Computer protocol. In addition to the transaction, this function also returns the value of the expression.","If the expression contains free variables (for example the variable x in the expression x.f()) a \"blockchain environment\" must be passed. A blockchain environment is a JSON object that maps variable names to the latest revisions of smart objects.","A module specifier can be provided in order to make the exports of that module are available to the evaluation.","Other options can customize the funding and signing process.","The state update effected by a Bitcoin Computer transaction is completely predictable:","If the transaction is included in a block the new state will be exactly the state returned from the effect function.","If the transaction is not included the state is not updated."]},{"l":"Type"},{"l":"Syntax"},{"l":"Parameters"},{"l":"opts","p":["[]","{}","1=SIGHASH_ALL","A Blockchain environment, maps free variables to latest revisions","A Javascript expression","A module specifier","An object with the basic configuration parameters to encode the expression in a transaction.","boolean","Default Value","Description","env","exclude","exp","fund","If set to a string a custom input script can be provided. If undefined a signature script is generated","If set to an number the corresponding input is signed. If undefined all inputs are signed.","include","index","inputScript","Key","mod","Module specifiers and UTXOs are encoded as strings of the form <transaction id>:<output number>","number","Record<string, string>","sighashType","sign","string","string[]","The sighash type","true","Type","undefined","UTXOs to exclude when funding","UTXOs to include when funding","Whether the transaction should be funded","Whether to sign the transaction"]},{"l":"Return value","p":["It returns an object { tx, effect } where tx is a Bitcoin transaction and effect is an object with keys res and env.","The transaction tx is an object from the NakamotoJS library - a BitcoinJS clone that supports LTC and BTC and has some extra features that make is easier to build advanced applications like exchanges.","The res object contains the result of the evaluation.","The env object has the same keys as the blockchain environment. However, whereas the values of the blockchain environment are revision strings, the values of env and the smart object at these revisions after evaluating the expression."]},{"l":"Examples"}],[{"l":"encodeCall","p":["Encodes a function call. This function is syntactic sugar for encode."]},{"l":"Type"},{"l":"Syntax"},{"l":"Parameters"},{"l":"params","p":["A module specifier","An object with the configuration parameters to encode the expression in a transaction.","args","Description","InstanceType<T>","Key","mod","Module specifiers are encoded as strings of the form <transaction id>:<output number>","Parameters<InstanceType<T>[K]>","property","string","target","The arguments to the function call","The name of the function being called","The smart object on which to call the function","Type"]},{"l":"Return value","p":["It returns an object { tx, effect } where tx is a Bitcoin transaction and effect is an object with keys res and env. For more details see the description of the return type of encode."]},{"l":"Examples"}],[{"l":"encodeNew","p":["Encodes a constructor call. This function is syntactic sugar for encode."]},{"l":"Type"},{"l":"Syntax"},{"l":"Parameters"},{"l":"params","p":["An object with the configuration parameters to encode the expression in a transaction.","Key","Type","Description","constructor","T extends new (...args: any) => any","A Javascript class that extends from Contract","args","ConstructorParameters<T>","Arguments to the constructor of the class","mod","string","A module specifier","Module specifiers are encoded as strings of the form <transaction id>:<output number>"]},{"l":"Return value","p":["It returns an object { tx, effect } where tx is a Bitcoin transaction and effect is an object with keys res and env. For more details see the description of the return type of encode."]},{"l":"Examples"}],[{"l":"faucet","p":["The faucet function funds a computer object. It is only available when the computer object is connected to a node in regtest mode. The faucet function creates a utxo to fund the address. The utxo is created with the amount of satoshis specified in the first parameter. The address to be funded can be specified in the second parameter. If the address is not specified, the address of the computer object is used. The transaction is broadcasted to the network, and a block is mined immediately to confirm the transaction."]},{"l":"Type"},{"l":"Syntax"},{"l":"Parameters"},{"l":"amount","p":["An amount of Satoshi"]},{"l":"address","p":["An string encoded address to be funded"]},{"l":"Return value","p":["The utxo created to fund the address."]},{"l":"Examples"}],[{"l":"fund","p":["Funds a Bitcoin transaction."]},{"l":"Type"},{"l":"Syntax"},{"l":"Parameters"},{"l":"tx","p":["A Bitcoin transaction object from the NakamotoJS library."]},{"l":"opts","p":["An optional object can be passed as parameter to include or exclude certain UTXOs. When using include, the transaction will be funded with the UTXOs specified as the first inputs.","Key","Type","Description","Default Value","include","string[]","UTXOs to include","[]","exclude","UTXOs to exclude"]},{"l":"Return value","p":["If the wallet does not have sufficient funds, an error is thrown."]},{"l":"Examples"}],[{"l":"getAddress","p":["Returns a string encoding Bitcoin address. Will return an address according to the type set in the Computer constructor."]},{"l":"Type"},{"l":"Syntax"},{"l":"Return value","p":["Returns a string encoded Bitcoin address."]}],[{"l":"getBalance","p":["Returns the current balance in satoshi."]},{"l":"Type"},{"l":"Syntax"},{"l":"Return value","p":["Returns the current balance in Satoshi."]}],[{"l":"getChain","p":["Returns the chain."]},{"l":"Type"},{"l":"Syntax"},{"l":"Return value","p":["Returns a string encoding the chain."]}],[{"l":"getMnemonic","p":["Returns a string encoding a BIP39 mnemonic sentence."]},{"l":"Type"},{"l":"Syntax"},{"l":"Return value","p":["The mnemonic."]}],[{"l":"getNetwork","p":["Returns the network."]},{"l":"Type"},{"l":"Syntax"},{"l":"Return value","p":["Returns a string encoding the network."]}],[{"l":"getPassphrase","p":["Returns the BIP39 passphrase."]},{"l":"Type"},{"l":"Syntax"},{"l":"Return value","p":["Returns the BIP39 passphrase."]}],[{"l":"getPrivateKey","p":["Returns a string encoded private key."]},{"l":"Type"},{"l":"Syntax"},{"l":"Return value","p":["Returns a string encoded private key."]}],[{"l":"getPublicKey","p":["Returns a string encoding a public key."]},{"l":"Type"},{"l":"Syntax"},{"l":"Return value","p":["Returns a string encoding a public key."]}],[{"l":"getUtxos","p":["Returns an array of unspent transaction outputs (UTXOs). Each UTXO is encoded as a string of the form <transaction id>:<output number>"]},{"l":"Syntax"},{"l":"Type"},{"l":"Return value","p":["Returns an array of unspent transaction outputs (UTXOs)."]}],[{"l":"load","p":["Imports a ES6 module from a module specifier encoded as a string <transaction id>:<output number>."]},{"l":"Type"},{"l":"Syntax"},{"l":"Parameters"},{"l":"rev","p":["A string encoding a module specifier."]},{"l":"Return value","p":["A ES6 module."]},{"l":"Examples"}],[{"l":"new","p":["Creates a new smart object. The parameters are a smart contract (a Javascript class inheriting from Contract), a list of arguments for the constructor of the class and an optional module specifier. The arguments of the constructor can be of basic data type or smart objects. The new function builds a transaction that records the creation of a new smart object, signs it and broadcasts it. Smart objects can be updated by calling their functions, see here."]},{"l":"Type","p":["Here a MetaData is the type"]},{"l":"Syntax"},{"l":"Parameters"},{"l":"constructor","p":["A named Javascript class that extends from Contract."]},{"l":"args","p":["Arguments to the constructor of the class."]},{"l":"mod","p":["A module specifier, i.e., the revision string of a deployed module (see deploy)."]},{"l":"Return value","p":["Returns an instance of the class T. The class T should extend from Contract. The returned object has extra properties _id, _rev, _root, _owners, _amount and possibly _url, _readers."]},{"l":"Examples"}],[{"l":"query","p":["Returns the latest revisions of smart objects. Conditions can be passed in to determine the smart objects. When multiple conditions are passed in, the latest revisions of the smart objects that satisfy all conditions are returned."]},{"l":"Type"},{"l":"Syntax"},{"l":"Parameters"},{"l":"params","p":["'ASC' | 'DEC'","{ class: T, args?: ConstructorParameters<T> }","An object with the query parameters.","contract","Description","ids","Key","limit","mod","number","offset","order","Order results in ascending or descending order","publicKey","Return latest revision of smart objects with ids in order","Return latest revisions of smart objects from a class","Return latest revisions of smart objects owned by a public key","Return only limited number of revisions","Return results starting from offset","Return the latest revision of smart objects created with this module specifier","string","string[]","Type"]},{"l":"Return value","p":["Given the query parameters, returns an array of strings encoding the latest revisions of smart objects that matches the specified conditions."]},{"l":"Examples"}],[{"l":"rpcCall","p":["Calls a Bitcoin RPC method with the given parameters."]},{"l":"Type"},{"l":"Syntax"},{"l":"Parameters"},{"l":"method","p":["An string encoding the name of the rpc function to be called."]},{"l":"params","p":["An string with the argument list of the rpc function call to be called, separated by spaces."]},{"l":"Return value","p":["A JSON object with the result of the rpc method call."]},{"l":"Examples"}],[{"l":"send","p":["Sends a payment."]},{"l":"Type"},{"l":"Syntax"},{"l":"Parameters"},{"l":"amount","p":["A number representing the amount of satoshis to be sent."]},{"l":"address","p":["An string encoding the receiver address."]},{"l":"Return value","p":["If successful, it returns the id of the transaction broadcast."]},{"l":"Examples"}],[{"l":"sign","p":["Signs a Bitcoin transaction. Options can be passed in that determine which inputs to sign, the sigHash type to use, and which script to use."]},{"l":"Type"},{"l":"Syntax"},{"l":"Parameters"},{"l":"tx","p":["A Bitcoin transaction, possibly partially signed."]},{"l":"opts","p":["An object with specific parameters to use when signing","Key","Type","Description","inputIndex","number","The input index to be signed","sighashType","A valid sighash type number","inputScript","Buffer","A buffer encoding the signature"]},{"l":"Return value","p":["By default, the sign function will make a best effort to sign all inputs, but will not throw an error if the signature cannot be added due to hash mismatch.","This is useful in the case of partially signed transactions, where a user can encode an expression, sign with the user private key and send the generated partially signed transaction to another user. Then, the receiver can sign other inputs."]},{"l":"Examples"}],[{"l":"sync","p":["Returns smart objects given a location on the blockchain. The location can either be a revision (a string of the for <transaction id>:<output number>) or a transaction id."]},{"l":"Type"},{"l":"Syntax"},{"l":"Parameters"},{"l":"location","p":["An string encoding a revision or a transaction id."]},{"l":"Return value","p":["If the function is called with a revision, it returns the smart object stored at the provided revision. Note that the revision must not be a latest revision. In that case a historical state of the revision is returned.","If the function is called with a transaction id, it returns an object of type { res: Json; env: Json }. The value of res is the result of evaluating the expression inscribed into the transaction. The env object has the same keys as the blockchain environment of the transaction, the values of env are the smart objects at these revisions after evaluating the expression.","If the parameter is not a valid revision or transaction id, an error is thrown."]},{"l":"Examples"},{"l":"Sync to a Revision","p":["Synchronizing to the revision returns a smart object."]},{"l":"Sync to a transaction id","p":["Synchronizing to a transaction id returns all smart objects on that transaction."]}]]