!function(t,e,n,r,o,i,s){"use strict";function c(t){return t&&"object"==typeof t&&"default"in t?t:{default:t}}function u(t){if(t&&t.__esModule)return t;var e=Object.create(null);return t&&Object.keys(t).forEach((function(n){if("default"!==n){var r=Object.getOwnPropertyDescriptor(t,n);Object.defineProperty(e,n,r.get?r:{enumerable:!0,get:function(){return t[n]}})}})),e.default=t,Object.freeze(e)}var a=c(e);var d=c(n);var h=c(r);var l=c(o);var f=u(i);function p(t,e){var n={};for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&e.indexOf(r)<0&&(n[r]=t[r]);if(null!=t&&"function"==typeof Object.getOwnPropertySymbols){var o=0;for(r=Object.getOwnPropertySymbols(t);o<r.length;o++)e.indexOf(r[o])<0&&Object.prototype.propertyIsEnumerable.call(t,r[o])&&(n[r[o]]=t[r[o]])}return n}function v(t,e,n,r){return new(n||(n=Promise))((function(o,i){function s(t){try{u(r.next(t))}catch(t){i(t)}}function c(t){try{u(r.throw(t))}catch(t){i(t)}}function u(t){var e;t.done?o(t.value):(e=t.value,e instanceof n?e:new n((function(t){t(e)}))).then(s,c)}u((r=r.apply(t,e||[])).next())}))}const{CHAIN:g,NETWORK:b,BCN_URL:y,RPC_USER:w,RPC_PASSWORD:m,TEST_MNEMONICS:x}=process.env;const O=g||"LTC";const _=b||"testnet";const S=y||"https://node.bitcoincomputer.io";const j="LTC"===O?3e4:3e3;const E="LTC"===O?5820:582;const{crypto:T}=a.default.bitcore;const $=(t,e)=>{const n=Date.now();const r=T.Hash.sha256(Buffer.from(e+n));const o=[T.ECDSA.sign(r,t,"big").toString("hex"),t.publicKey.toString(),n];return`Bearer ${Buffer.from(o.join(":")).toString("base64")}`};class C{constructor(t=S,e=new a.default.bitcore.PrivateKey,n={}){this.baseUrl=t,this.headers=n,this.privateKey=e}get(t){return v(this,void 0,void 0,(function*(){const e=this.privateKey?{Authentication:$(this.privateKey,this.baseUrl)}:{};return(yield d.default.get(`${this.baseUrl}${t}`,{headers:Object.assign(Object.assign({},this.headers),e)})).data}))}post(t,e){return v(this,void 0,void 0,(function*(){const n=this.privateKey?{Authentication:$(this.privateKey,this.baseUrl)}:{};return(yield d.default.post(`${this.baseUrl}${t}`,e,{headers:Object.assign(Object.assign({},this.headers),n)})).data}))}delete(t){return v(this,void 0,void 0,(function*(){const e=this.privateKey?{Authentication:$(this.privateKey,this.baseUrl)}:{};return(yield d.default.delete(`${this.baseUrl}${t}`,{headers:Object.assign(Object.assign({},this.headers),e)})).data}))}}parseInt(process.env.BC_DEFAULT_FEE||"",10),parseInt(process.env.BC_SCRIPT_CHUNK_SIZE||"",10),parseInt(process.env.MWEB_HEIGHT||"",10);const{PublicKey:I,crypto:k,Script:K}=a.default.bitcore;const{Point:B}=k;function P(t){let e=t.toBuffer().length+9;return t.isWitnessProgram()?e+=67.75:e+=148,j*e/1e3}function R(t){return Buffer.from(t,"hex").toString().replace(/\0/g,"")}function A(t,e){return t.slice(e)+t.slice(0,e)}function D(t,e,n){if(t.length*Math.log2(e)>53)throw new Error(`Input too large ${t.length} ${Math.log2(e)}`);if(![2,10,16].includes(e)||![2,10,16].includes(n))throw new Error("ToBase or FromBase invalid in covertNumber.");if(2===e&&t.length%8!=0)throw new Error("Binary strings must be byte aligned.");if(16===e&&t.length%2!=0)throw new Error("Hex strings must be of even length.");const r=parseInt(t,e).toString(n);return 2===n?r.padStart(8*Math.ceil(r.length/8),"0"):16===n?r.padStart(2*Math.ceil(r.length/2),"0"):r}function M(t,e){const n=new RegExp(`.{1,${e}}`,"g");return t.match(n)||[]}function U(t){return M(t,2).map((t=>D(t,16,2))).join("")}function H(t){return M(t,8).map((t=>D(t,2,16))).join("")}function N(t){if(62!==t.length)throw new Error("Input to hexToPublicKey must be of length 62");let e=!1;let n=0;let r;for(;!e;){if(n>=256)throw new Error("Something went wrong storing data");const o=n.toString(16).padStart(2,"0")+H(A(U(t).padStart(64,"0"),n));try{r=B.fromX(!1,o),e=!0}catch(t){n+=1}}if(!r)throw new Error("Something went wrong storing data");return new I(r)}function L(t){const e=t.point.getX().toString("hex").padStart(64,"0");const n=D(e.slice(0,2),16,10);return H((o=parseInt(n,10),(r=U(e.slice(2))).slice(-o)+r.slice(0,-o)));var r,o}function J(t,e){const n={"any-testnet":"uTKUDCkpo12vstJBsMWmrTPz9wFE6DuzGH","BTC-mainnet":"igpnnoLziUyxtQuWYCP13gHYVhUru6iLaY","LTC-mainnet":"t77o829ngHnuUorwDkf129fL6ERLFNqKG8"};return A("testnet"===e||"regtest"===e?n["any-testnet"]:n[`${t}-${e}`],19)}function z(t=O,e=_){if("testnet"===e||"regtest"===e)return 1;if("BTC"===t)return 0;if("LTC"===t)return 2;if("DOGE"===t)return 3;if("BCH"===t)return 145;if("BSV"===t)return 236;throw new Error(`Unsupported chain ${t}`)}function F({chain:t=O,network:e=_}={}){return function({purpose:t=44,coinType:e=2,account:n=0}={}){return`m/${t.toString()}'/${e.toString()}'/${n.toString()}'`}({coinType:z(t,e)})}function W(t,e){return I.fromString(function(t,e){const n={"any-testnet":"be88416b08d0bfcc88102c4d9b558662f570dbd0676e6fa167552117933f133b8d","BTC-mainnet":"cd3a3ef0281ab2ce66a02ea770fbc2c41e46816ab821c9a91435958284b4aaef13","LTC-mainnet":"12d020c11112a2839d302548072bddbdfbcd39472a54b45a016456b8e30ea631aa"};return A("testnet"===e||"regtest"===e?n["any-testnet"]:n[`${t}-${e}`],19)}(t,e))}function q({mnemonic:t=new a.default,path:e=F(),passphrase:n="",network:r=_}){return t.toHDPrivateKey(n,r).deriveChild(e)}function V(t){return/^[0-9A-Fa-f]{64}\/\d+$/.test(t)}function G(t){if(!/^[0-9A-Fa-f]{64}$/.test(t))throw new Error(`Invalid txId: ${t}`)}function Z(t){if(!/^[0-9A-Fa-f]{64}\/\d+$/.test(t))throw new Error(`Invalid outId: ${t}`)}function Y(t){Z(t);const[e,n]=t.split("/");return{txId:e,outputIndex:parseInt(n,10)}}const Q=t=>{const e=[];const n={};let r=0;return t.forEach((t=>{"string"==typeof t?e.push(`'${t}'`):"number"==typeof t||"boolean"==typeof t?e.push(t):"object"==typeof t&&(t._rev?(e.push(`__bc${r}__`),n[`__bc${r}__`]=t._rev,r+=1):e.push(t))})),{argString:e.join(","),env:n}};function X(t){const e=t.match(/.{1,8}/g);const n=null==e?void 0:e.map((t=>parseInt(t,2)));return Buffer.from(new Uint8Array(n).buffer)}function tt(t){return Array.from(t).map((t=>t.toString(2).padStart(8,"0"))).join("")}const{Transaction:et}=a.default.bitcore;const{UnspentOutput:nt}=et;class rt{constructor({chain:t,network:e,mnemonic:n,path:r,passphrase:o,url:i}={}){if(this.chain=t?t.toUpperCase():O,this.network=e?e.toLowerCase():_,this.mnemonic=new a.default(n?n.toString():void 0),this.path=r||F({chain:this.chain,network:this.network}),this.passphrase=o||"",this.bcn=new C(i,this.privateKey),!["LTC","BTC"].includes(this.chain))throw new Error("We currently only support LTC, support for other currencies will be added soon.");if(!["mainnet","testnet","regtest"].includes(this.network))throw new Error("Please set 'network' to 'regtest', 'testnet', or 'mainnet'")}get privateKey(){return q(this).privateKey}getBalance(t){return v(this,void 0,void 0,(function*(){const{chain:e,network:n}=this;return yield this.bcn.get(`/v1/${e}/${n}/address/${t}/balance`)}))}getTransactions(t){return v(this,void 0,void 0,(function*(){return(yield this.getRawTxs(t)).map((t=>new et(t)))}))}getRawTxs(t){return v(this,void 0,void 0,(function*(){t.map(G);const{chain:e,network:n}=this;return this.bcn.post(`/v1/${e}/${n}/tx/bulk/`,{txIds:t})}))}sendTransaction(t){return v(this,void 0,void 0,(function*(){return this.bcn.post(`/v1/${this.chain}/${this.network}/tx/send`,{txJSON:t})}))}getUtxosByAddress(t){return v(this,void 0,void 0,(function*(){const{chain:e,network:n}=this;return(yield this.bcn.get(`/v1/${e}/${n}/wallet/${t.toString()}/utxos`)).map((({rev:e,scriptPubKey:n,satoshis:r})=>{const[o,i]=e.split("/");return new nt({address:t,txId:o,outputIndex:parseInt(i,10),satoshis:r,script:n})}))}))}query(t){return v(this,void 0,void 0,(function*(){const{publicKey:e,classHash:n,limit:r,offset:o,order:i}=t;if(void 0===e&&void 0===n)throw new Error("Query parameters cannot be empty.");let s="";e&&(s+=`?publicKey=${e}`),n&&(s+=0===s.length?"?":"&",s+=`classHash=${n}`),void 0!==r&&(s+=`&limit=${r}`),void 0!==o&&(s+=`&offset=${o}`),i&&(s+=`&order=${i}`);const{chain:c,network:u}=this;return this.bcn.get(`/v1/${c}/${u}/non-standard-utxos${s}`)}))}idsToRevs(t){return v(this,void 0,void 0,(function*(){t.map(Z);const{chain:e,network:n}=this;return this.bcn.post(`/v1/${e}/${n}/revs`,{ids:t})}))}rpc(t,e){return v(this,void 0,void 0,(function*(){return this.bcn.post(`/v1/${this.chain}/${this.network}/rpc`,{method:t,params:e})}))}static getSecretOutput({_url:t,privateKey:e}){return v(this,void 0,void 0,(function*(){const n=t.split("/");const r=n[n.length-1];const o=n.slice(0,-2).join("/");const i=new C(o,e);return{host:o,data:yield i.get(`/v1/store/${r}`)}}))}static setSecretOutput({secretOutput:t,host:e,privateKey:n}){return v(this,void 0,void 0,(function*(){return new C(e,n).post("/v1/store/",t)}))}static deleteSecretOutput({_url:t,privateKey:e}){return v(this,void 0,void 0,(function*(){const n=t.split("/");const r=n[n.length-1];const o=n.slice(0,-2).join("/");const i=new C(o,e);yield i.delete(`/v1/store/${r}`)}))}get url(){return this.bcn.baseUrl}}const{PublicKey:ot,Script:it}=a.default.bitcore;function st(t,e,n,r){if(t.length>3)throw new Error("Too many owners");return function(t,e,n,r){const o=r?[...t,W(e,n).toBuffer()]:t;const i=new it;return i.add("OP_1"),o.forEach((t=>{i.add(t)})),i.add(`OP_${o.length}`),i.add("OP_CHECKMULTISIG"),i}(t.map((t=>t.toBuffer())),e,n,r)}function ct(t,e){return function(t,e){const n=t.chunks.filter((t=>t.buf));return(e?n.slice(0,-1):n).map((t=>t.buf))}(t,e).map((t=>ot.fromBuffer(t)))}function ut(t){return Buffer.from(l.default.SHA256(t).toString(),"hex").toString("hex").substr(0,4)}function at(t){return`${ut(t)};${t}`}function dt(t){const e=t.substr(0,4);const n=t.substr(5);if(!function(t,e){return ut(t)===e}(n,e))throw new Error("Decryption failure");return n}var ht;!function(t){t.Array="Array",t.Boolean="boolean",t.Null="Null",t.Number="number",t.Object="Object",t.String="string",t.Undefined="undefined"}(ht||(ht={}));const lt=["_owners","_readers","_amount"];const ft=lt.concat(["_id","_rev","_root"]);const pt=t=>(Object.prototype.toString.call(t).match(/\s([a-zA-Z]+)/)||[])[1];const vt=t=>"object"==typeof t?pt(t):pt(t).toLowerCase();const gt=t=>vt(t)===ht.Null;const bt=t=>vt(t)===ht.Number;const yt=t=>gt(t)||vt(t)===ht.Undefined||bt(t)||(t=>vt(t)===ht.String)(t)||(t=>vt(t)===ht.Boolean)(t);const wt=t=>!yt(t)&&!Array.isArray(t);const mt=t=>!yt(t)&&Array.isArray(t);const xt=t=>e=>yt(e)?t(e):mt(e)?e.flatMap(xt(t)):wt(e)?[...t(e),...Object.values(e).flatMap(xt(t))]:[];const Ot=t=>wt(t)?[Object.fromEntries(Object.entries(t).filter((([t])=>ft.includes(t))))]:(yt(t),[]);const _t=t=>e=>t.reduce(((t,n)=>(Object.keys(e).includes(n)&&(t[n]=e[n]),t)),{});const St=t=>{return e=([e,n])=>[e,t(n)],t=>Object.fromEntries(Object.entries(t).map((t=>e(t))));var e};const jt=t=>e=>{if(yt(e))return t(e);if(mt(e))return t(e.map(jt(t)));if(wt(e)){const n=t(St(jt(t))(e));const r=Object.create(Object.getPrototypeOf(e));return Object.assign(r,n)}throw new Error("Unsupported type")};const Et=t=>e=>{if(yt(e));else if(mt(e))e.forEach(Et(t));else{if(!wt(e))throw new Error("Unsupported type");{t(e);const n=(t=>{return e=([e,n])=>[e,t(n)],t=>{Object.entries(t).forEach((t=>e(t)))};var e})(Et(t))(e);const r=Object.create(Object.getPrototypeOf(e));Object.assign(r,n)}}};const Tt=t=>e=>n=>{if(yt(n))return t(e,n);const r=wt(n)?Object.values(n):n;const o=r.flatMap((n=>Tt(t)(e)(n)));return r.reduce(t,o)};const $t=jt((t=>t));function Ct(t){if(void 0!==t._readers){const{_readers:e,_url:n,_owners:r,_amount:o}=t,i=p(t,["_readers","_url","_owners","_amount"]);const s=function(t,e){const n=h.default.randomBytes(32).toString("hex");const r=function(t,e){if(!/^[0-9a-f]{64}$/.test(e))throw new Error("Invalid secret");const n=Buffer.from(e,"hex").toString("binary");const r=at(t);return l.default.AES.encrypt(r,n).toString()}(t,n);const o=e.map((t=>function(t,e){if(!/^0[2-3][0-9a-f]{64}|04[0-9a-f]{128}$/.test(e))throw new Error("Invalid publicKey");const n=at(t);return f.encrypt(e,Buffer.from(n,"utf8")).toString("base64")}(n,t)));return{__cypher:r,__secrets:o}}(JSON.stringify(i),e);return void 0!==n&&(s._url=n),void 0!==r&&(s._owners=r),void 0!==o&&(s._amount=o),s}return t}const{Transaction:It}=a.default.bitcore;const{Output:kt,UnspentOutput:Kt}=It;class Bt{constructor({restClient:t=new rt}={}){this.tx=new It,this.tx.feePerKb(1e4),this.outData=[],this.restClient=t}get txId(){return this.tx.id}get chain(){return this.restClient.chain}get network(){return this.restClient.network}get inputs(){return this.tx.inputs.map((t=>`${t.prevTxId.toString("hex")}/${t.outputIndex}`))}get encoding(){const{outputs:t}=this.tx;const e=t.filter((({script:t})=>null==t?void 0:t.isDataOut())).map((({script:t})=>t.getData()));const{ioDescriptor:n=[],ioMap:r=[],dataPrefix:o=""}=e.length?function(t){const e=t.subarray(0,6);const n=t.subarray(6);const r=tt(e).match(/.{1,12}/g).map((t=>parseInt(t,2)));const o=r[3];const i=Math.ceil(o/8);return{ioDescriptor:r,ioMap:function(t){const e=t.split("").reverse().join("");const n=[];for(let t=0;t<e.length;t+=1)"1"===e[t]&&n.push(t);return n}(tt(n.subarray(0,i))),dataPrefix:n.subarray(i).toString("utf8")}}(e[0]):{};return n.length&&n[0]>this.tx.inputs.length||n.length&&n[1]>this.tx.outputs.length||n.length&&n[2]>this.tx.outputs.length?{ioDescriptor:[],ioMap:[],dataPrefix:""}:{ioDescriptor:n,ioMap:r,dataPrefix:o}}get ioDescriptor(){return this.encoding.ioDescriptor}get dataPrefix(){return this.encoding.dataPrefix}get ioMap(){return this.encoding.ioMap}get inputsLength(){const[t=0]=this.ioDescriptor;return t}get outputsLength(){const[,t=0]=this.ioDescriptor;return t}get maxDataIndex(){const[,,t=-1]=this.ioDescriptor;return t}get ownerInputs(){return this.tx.inputs.slice(0,this.inputsLength)}get ownerOutputs(){return this.tx.outputs.slice(0,this.outputsLength)}get inRevs(){return this.ownerInputs.map((({prevTxId:t,outputIndex:e})=>`${t.toString("hex")}/${e}`))}get outRevs(){return this.ownerOutputs.map(((t,e)=>`${this.tx.id}/${e}`))}get zip(){return this.ownerOutputs.map(((t,e)=>[this.ioMap.indexOf(e)>=0?this.inRevs[this.ioMap.indexOf(e)]:null,this.outRevs[e]]))}isBcTx(){return this.tx.outputs.some((t=>t.script.toAddress(this.network).toString()===J(this.chain,this.network)))}getOwnerOutputs(){const[,t=0]=this.ioDescriptor;return this.tx.outputs.slice(0,t)}getDataOutputs(){const[,t,e]=this.ioDescriptor;return this.tx.outputs.slice(t,e)}getOutData(){return v(this,void 0,void 0,(function*(){try{const t=this.getDataOutputs().map((t=>t.script)).map((t=>ct(t,!0))).flat().map(L).map(R).join("");const{dataPrefix:e}=this;const n=JSON.parse(e+t);const r=this.restClient.privateKey.toBuffer().toString("hex");const o=this.getOwnerOutputs();if(o.length!==n.length)throw new Error("Inconsistent state");const i=o.map(((t,e)=>Object.assign(Object.assign({},n[e]),{_owners:ct(t.script,!1).map((t=>t.toString())),_amount:t.satoshis})));return Promise.all(i.map((t=>v(this,void 0,void 0,(function*(){try{return function(t,e){if(function(t){return wt(t)&&"__cypher"in t&&"__secrets"in t}(t)){const{__cypher:n,__secrets:r}=t,o=p(t,["__cypher","__secrets"]);return Object.assign(Object.assign(Object.assign({},o),JSON.parse(function({__cypher:t,__secrets:e},n){let r="";if(n.forEach((n=>{e.forEach((e=>{try{const o=function(t,e){if(!/^[0-9a-f]{64}$/.test(e))throw new Error("Invalid privateKey");return dt(f.decrypt(e,Buffer.from(t,"base64")).toString("utf8"))}(e,n);r=function(t,e){if(!/^[0-9a-f]{64}$/.test(e))throw new Error("Invalid secret");const n=Buffer.from(e,"hex").toString("binary");return dt(l.default.AES.decrypt(t,n).toString(l.default.enc.Utf8))}(t,o)}catch(t){const e=["Decryption failure","Unsupported state or unable to authenticate data"];if(t instanceof Error&&!e.includes(t.message))throw t}}))})),r)return r;throw new Error("Decryption failure")}({__cypher:n,__secrets:r},e))),{_readers:[]})}return t}(yield function(t){return e=>v(this,void 0,void 0,(function*(){if(function(t){return wt(t)&&"_url"in t}(e)){const{_url:n}=e,r=p(e,["_url"]);const{host:o,data:i}=yield rt.getSecretOutput({_url:n,privateKey:t});return Object.assign(Object.assign(Object.assign({},r),JSON.parse(i)),{_url:o})}return e}))}(this.restClient.privateKey)(t),[r])}catch(t){return null}})))))}catch(t){return[]}}))}getOwners(){return this.getOwnerOutputs().map((t=>ct(t.script,!1).map((t=>t.toString()))))}getAmounts(){return this.getOwnerOutputs().map((t=>t.satoshis))}spendFromData(t){return v(this,void 0,void 0,(function*(){if(!t.length)return;const e=t.map(Y);const n=e.map((t=>t.txId));const r=yield this.restClient.getTransactions(n);for(let t=0;t<e.length;t+=1){const{txId:n,outputIndex:o}=e[t];const{outputs:i}=r[t];const s=i[o];const c=Math.round(s.satoshis);const u=new a.default.bitcore.Script(s.script);const d=new Kt({txId:n,outputIndex:o,satoshis:c,script:u});const h=ct(u,!1).map((t=>t.toString()));this.tx.from([d],h,1,{noSorting:!0})}}))}createDataOuts(t,e=[]){t.forEach((({_amount:t,_owners:e=[]})=>{if(Array.isArray(e)&&e.length>3)throw new Error("Too many owners.");const n=st(e.map((t=>a.default.bitcore.PublicKey.fromString(t))),this.chain,this.network,!1);const r=t||P(n);this.tx.addOutput(new kt({script:n,satoshis:r}))}));const n=t.map((t=>p(t,["_amount","_owners"])));const{opReturnBuffer:r,dataScripts:o}=function(t,e,n,r,o,i){const s=function(t){const e=[];let n=0;let r;if(t.sort(((t,e)=>t-e))!==t)throw new Error("numbers must be in ascending order");for(let e=0;e<t.length;e+=1)if(t[e]===t[e+1])throw new Error("numbers must not contain duplicates");for(let o=0;n<t.length;o+=1)o===t[n]?(r="1",n+=1):r="0",e.unshift(r);return function(t,e){let n;if(t.length%2!=0){const e=t.length/2;n=2*Math.ceil(e)}return t.padStart(n,"0")}(e.join(""))}(r);const c=X(s.padStart(8*Math.ceil(s.length/8),"0"));const u=JSON.stringify(n);const a=80-(6+c.length);const d=u.slice(0,a);const h=function(t,e,n,r){var o;return function(t,e){const n=[];for(let e=0;e<t.length;e+=2)n.push(t.slice(e,e+2));return n}(M((o=t,Buffer.from(o).toString("hex")),62).map((t=>t.padStart(62,"0"))).map(N)).map((t=>st(t,e,n,!0)))}(u.slice(a),o,i);const l=X([t,e,e+h.length,s.length].map((t=>t.toString(2).padStart(12,"0"))).join(""));const f=Buffer.from(d);return{opReturnBuffer:Buffer.concat([l,c,f]),dataScripts:h}}(this.tx.inputs.length,this.tx.outputs.length,n,e,this.chain,this.network);o.forEach((t=>{const e=P(t);this.tx.addOutput(new kt({script:t,satoshis:e}))})),this.tx.addData(r)}static getBcTx({hex:t="",restClient:e=new rt}){const n=new this({restClient:e});return n.tx.fromString(t),n.outData=[],n}static fromTxHex({hex:t="",restClient:e=new rt}){return v(this,void 0,void 0,(function*(){let n=[];let r=[];let o=[];const i=new this({restClient:e});i.tx.fromString(t);try{n=yield i.getOutData()}catch(t){}try{r=i.getOwners()}catch(t){}try{o=i.getAmounts()}catch(t){}return i.outData=n.map(((t,e)=>Object.assign(Object.assign({},t),{_owners:r[e],_amount:o[e]}))),i}))}static fromTxId({txId:t="",restClient:e=new rt}){return v(this,void 0,void 0,(function*(){const[n]=yield e.getRawTxs([t]);return this.fromTxHex({hex:n,restClient:e})}))}}class Pt{constructor(t={}){this.restClient=new rt(t)}derive(t="0"){const e=`${this.path}${this.path.length>0?"/":""}${t}`;const{chain:n,network:r,url:o,mnemonic:i,passphrase:s}=this.restClient;return new Pt({chain:n,network:r,url:o,mnemonic:i.toString(),path:e,passphrase:s})}getBalance(){return v(this,void 0,void 0,(function*(){return this.restClient.getBalance(this.address)}))}getUtxosByEfectiveValue(t){return v(this,void 0,void 0,(function*(){const e=yield this.restClient.getUtxosByAddress(this.address);let n=0;const r=[];!function(t){const e=t;for(let t=e.length-1;t>0;t-=1){const n=Math.floor(Math.random()*(t+1));[e[t],e[n]]=[e[n],e[t]]}}(e);for(const o of e){const e=a.default.bitcore.Transaction.Input.fromObject({address:o.address,prevTxId:o.txId,outputIndex:o.outputIndex,script:o.script,satoshis:o.amount})._estimateSize();if(o.satoshis-10*e<0)throw new Error(`Invalid amount when selecting coins: utxo.satoshis ${null==o?void 0:o.satoshis} FEE_PER_KB 10000 estimated size: ${e}`);if(n+=o.satoshis-10*e,r.push(o),n>=t)return r}const{network:o,chain:i}=this.restClient;const s=this.address.toString();throw new Error(`Insufficient balance in address ${s} on ${o} ${i}. Found ${n}, required ${t}.`)}))}fundAndSendTx(t){return v(this,void 0,void 0,(function*(){return yield this.fundTx(t),this.sendTx(t)}))}fundTx(t){return v(this,void 0,void 0,(function*(){t.tx.feePerKb(1e4);const{chain:e,network:n}=this.restClient;const r=Math.max(5e3,E);t.tx.to(J(e,n),r);const o=t.tx._getInputAmount();const i=t.tx._getOutputAmount();const s=t.tx._estimateFee();const c=i-o+Math.round(s);c>0&&(yield this.getUtxosByEfectiveValue(c)).forEach((e=>{t.tx.from([new a.default.bitcore.Transaction.UnspentOutput(e)])})),t.tx.change(this.address.toString()),t.tx.sign(this.privateKey,1)}))}sendTx(t){return v(this,void 0,void 0,(function*(){return this.restClient.sendTransaction(t.tx)}))}send(t,e){return v(this,void 0,void 0,(function*(){const{restClient:n}=this;const r=new Bt({restClient:n});return r.tx.to(e,t),this.fundAndSendTx(r)}))}get hdPrivateKey(){return q(this.restClient)}get privateKey(){return this.hdPrivateKey.privateKey}get publicKey(){return this.hdPrivateKey.publicKey}get passphrase(){return this.restClient.passphrase}get path(){return this.restClient.path}get chain(){return this.restClient.chain}get network(){return this.restClient.network}get url(){return this.restClient.url}get mnemonic(){return this.restClient.mnemonic}get address(){return this.publicKey.toAddress(this.restClient.network)}}class Rt{constructor(t={}){this.wallet=new Pt(t)}fromTxHex(t){return v(this,void 0,void 0,(function*(){const{restClient:e}=this.wallet;return Bt.fromTxHex({hex:t,restClient:e})}))}fromTxId(t){return v(this,void 0,void 0,(function*(){const[e]=yield this.wallet.restClient.getRawTxs([t]);return this.fromTxHex(e)}))}get(t){return v(this,void 0,void 0,(function*(){const e=t.map(Y);return Promise.all(e.map((({txId:t,outputIndex:e})=>v(this,void 0,void 0,(function*(){const{outData:n}=yield this.fromTxId(t);if(e>n.length)throw new Error("Index out of bounds");return n[e]})))))}))}put(t){return this.update([],t)}getBcTx(t){const{restClient:e}=this.wallet;return Bt.getBcTx({hex:t,restClient:e})}createTx(t,e,n=[]){return v(this,void 0,void 0,(function*(){const{wallet:r}=this;const{restClient:o}=r;const i=new Bt({restClient:o});const{privateKey:s,publicKey:c}=r;const u=e.map((t=>{var{_owners:e}=t,n=p(t,["_owners"]);return Object.assign({_owners:e||[c.toString()]},n)}));const a=u.map(Ct);const d=yield Promise.all(a.map(function(t){return e=>v(this,void 0,void 0,(function*(){if(void 0!==e._url){const{_url:n,_owners:r,_amount:o}=e,i=p(e,["_url","_owners","_amount"]);const s=yield rt.setSecretOutput({host:n,secretOutput:{data:JSON.stringify(i)},privateKey:t});return void 0!==r&&(s._owners=r),void 0!==o&&(s._amount=o),s}return e}))}(s)));return yield i.spendFromData(t),yield i.createDataOuts(d,n),i}))}update(t,e,n=[]){return v(this,void 0,void 0,(function*(){const r=yield this.createTx(t,e,n);return yield this.wallet.fundAndSendTx(r),r.outRevs}))}getTx(t,e,n=[]){return v(this,void 0,void 0,(function*(){const r=yield this.createTx(t,e,n);return yield this.wallet.fundTx(r),r}))}}class At{constructor({db:t=new Rt}={}){this.db=t}deploy(t){return v(this,void 0,void 0,(function*(){const[e]=yield this.db.put([{mod:t}]);return e}))}static bitcoinResolveHook(t){return t}static bitcoinImportHook(t){return v(this,void 0,void 0,(function*(){const[e]=yield(new Rt).get([t]);return new s.StaticModuleRecord(e.mod,t)}))}static nodeResolveHook(t="",e=""){if(void 0===t||void 0===e)throw new Error("!!! Invalid arguments");if(t.startsWith("/"))throw TypeError(`Module specifier ${t} must not begin with "/"`);if(!e.startsWith("./"))throw TypeError(`Module referrer ${e} must begin with "./"`);const n=[];const r=[];(t=>t.startsWith("./")||t.startsWith("../")||"."===t||".."===t)(t)&&(r.push(...e.split("/")),r.pop(),n.push(".")),r.push(...t.split("/"));for(const o of r)if("."===o||""===o);else if(".."===o){if(0===r.length)throw TypeError(`Module specifier ${t} via referrer ${e} must not traverse behind an empty path`);n.pop()}else n.push(o);return n.join("/")}static resolveHook(t,e){if(V(e)&&!V(t))throw new Error("Requiring a local file from a module on the blockchain is not supported.");return V(t)?At.bitcoinResolveHook(t):At.nodeResolveHook(t,e)}static makeImportHook(){return t=>{if(V(t))return At.bitcoinImportHook(t);throw new Error("Not a valid import")}}static getBitcoinCompartment(){const{resolveHook:t,makeImportHook:e}=At;return new Compartment({},{},{resolveHook:t,importHook:e()})}static import(t){return v(this,void 0,void 0,(function*(){const e=At.getBitcoinCompartment();const{namespace:n}=yield e.import(t);return n}))}}var Dt;class Mt{constructor(t){this.enc=bt(t)?t:gt(t)?{null:new Mt(1)}:mt(t)?St((t=>new Mt(t)))(Object.fromEntries(Object.entries(t))):wt(t)?St((t=>new Mt(t)))(t):{[t.toString()]:new Mt(1)},this.type=vt(t)}}Dt=Mt,Mt.zero=t=>({type:t,enc:t===ht.Number?0:{}}),Mt.isZero=t=>Ut(t)?0===t.enc:0===Object.keys(t.enc).length,Mt.isReal=t=>!Ht(t)||1===Object.keys(t.enc).length&&1===t.enc[Object.keys(t.enc)[0]].enc,Mt.scalarMult=t=>e=>{if(Ut(e))return{type:e.type,enc:Number(e.enc)*t};if(Jt(e))return{type:e.type,enc:St(Mt.scalarMult(t))(e.enc)};throw new Error(`Cannot multiply ${t} with ${e}`)},Mt.add=t=>e=>{if(Ut(t)&&Ut(e))return{type:ht.Number,enc:t.enc+e.enc};if(Jt(t)&&Jt(e)){const n=[...Object.keys(t.enc),...Object.keys(e.enc)].map((n=>{const r=t.enc[n]||Mt.zero(e.enc[n].type);const o=e.enc[n]||Mt.zero(t.enc[n].type);return[n,Mt.add(r)(o)]})).filter((([,t])=>!Mt.isZero(t)));return{type:t.type,enc:Object.fromEntries(n)}}throw new Error(`Cannot add ${JSON.stringify(t,null,2)} and ${JSON.stringify(e,null,2)}`)},Mt.toJson=t=>{if(Ut(t))return t.enc;if(Lt(t)){const e=Object.entries(t.enc).filter((([,t])=>Mt.isReal(t)));const n=Object.fromEntries(e);return St(Mt.toJson)(n)}if(Nt(t))return Object.entries(t.enc).filter((([,t])=>Mt.isReal(t))).reduce(((t,[e,n])=>(t[e]=Mt.toJson(n),t)),[]);if(Dt.isReal(t)){const[e]=Object.keys(t.enc);if(t.type===ht.Null)return null;if(t.type===ht.Boolean)return"true"===e;if(t.type===ht.String)return e;throw new Error("Invalid type")}throw new Error("Value is surreal")};const Ut=t=>t.type===ht.Number;const Ht=t=>t.type===ht.String;const Nt=t=>t.type===ht.Array;const Lt=t=>t.type===ht.Object;const Jt=t=>(t=>t.type===ht.Null)(t)||(t=>t.type===ht.Boolean)(t)||Ht(t)||Nt(t)||Lt(t);var zt;let Ft=zt=class{};Ft.plus=t=>e=>Mt.add(t)(e),Ft.inverse=t=>Mt.scalarMult(-1)(t),Ft.minus=t=>e=>zt.plus(t)(zt.inverse(e)),Ft.zero=t=>Mt.zero(t),Ft.toJson=t=>Mt.toJson(t),Ft.fromJson=t=>new Mt(t),Ft=zt=function(t,e,n,r){var o,i=arguments.length,s=i<3?e:null===r?r=Object.getOwnPropertyDescriptor(e,n):r;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,n,r);else for(var c=t.length-1;c>=0;c--)(o=t[c])&&(s=(i<3?o(s):i>3?o(e,n,s):o(e,n))||s);return i>3&&s&&Object.defineProperty(e,n,s),s}([t=>t],Ft);const Wt=t=>e=>n=>{if(void 0===e||void 0===n)throw new Error("projectTree: query or tree is undefined");if(e.type!==n.type)throw new Error("Type mismatch");if(Ut(n))return n;if(Jt(n)){const r=Object.entries(n.enc).map((([n,r])=>t.includes(n)?[n,r]:Object.keys(e.enc).includes(n)?[n,Wt(t)(e.enc[n])(r)]:[n,Mt.zero(r.type)])).filter((([,t])=>!Mt.isZero(t)));return{enc:Object.fromEntries(r),type:e.type}}throw new Error("Invalid query")};class qt{constructor({db:t=new Rt}={}){this.db=t}read(t){return v(this,void 0,void 0,(function*(){const{txId:e}=Y(t);const{outData:n}=yield this.db.fromTxId(e);const{exp:r,env:o,mod:i,root:s}=n[0];const{getVal:c}=yield this.getValAndTx(r,o,i,s);const u=c(e);var a;return(a=e=>e._rev&&e._rev===t,t=>Tt(((t,e)=>a(e)?t.concat([e]):t))([])(t))(u)[0]}))}populateEnv(t){return v(this,void 0,void 0,(function*(){return Object.fromEntries(yield Promise.all(Object.entries(t).map((([t,e])=>v(this,void 0,void 0,(function*(){return[t,(n=e,"string"==typeof n&&V(n)?yield this.read(e):e)];var n}))))))}))}static evaluate(t,e={},n=""){return v(this,void 0,void 0,(function*(){const r=n?yield At.import(n):{};return Object.getOwnPropertyNames(r).forEach((t=>{e[t]=r[t]})),new Compartment(e).evaluate(t)}))}getValAndTx(t,e={},n="",r){return v(this,void 0,void 0,(function*(){if(r&&!Object.keys(e).includes(r))throw new Error(`Root ${r} not found in env.`);const o=yield this.populateEnv(e);const i=$t(o);const s=yield qt.evaluate(t,i,n);const c=o[r];const u=c&&!yt(a=c)&&!Array.isArray(a)&&a._id&&a._rev&&a._root?null==c?void 0:c._root:void 0;var a;const d={_rev:"frame1",env:Object.assign({_rev:"frame2"},o)};const h={_rev:"frame1",env:Object.assign({_rev:"frame2"},i)};void 0!==s&&(h.res=s);const l=qt.updateWithRevImpure((()=>Math.random().toString()));Et(l)(h);const f=t=>wt(t)&&"_rev"in t?[t._rev]:[void 0];const p=xt(f)(h.env).filter((t=>void 0!==t));const g=xt(f)(h.res).filter((t=>void 0!==t));const b=t=>new Set(t).size!==t.length;if(b(p)||b(g))throw new Error("Cannot create a circular object");const{inputs:y,outputs:w}=(t=>e=>{const{inputs:n,outputs:r}=(t=>e=>{const n=(t=>e=>{const n=(t=>e=>{const n=Ft.fromJson(t);const r=Ft.fromJson(e);const o=Ft.minus(r)(n);return Wt(ft)(o)(r)})(t)(e);const r=Ft.toJson(n);return xt(Ot)(r)})(t)(e);return{inputs:n.map((t=>wt(t)&&"string"==typeof t._rev?t._rev:void 0)),outputs:n.map(_t(lt.concat("_rev")))}})(t)(e);const o=n.map(((t,e)=>void 0!==t?e:void 0)).filter((t=>void 0!==t));return{inputs:n.filter((t=>void 0!==t)),outputs:r,ioMap:o}})(d)(h);const m=y.filter(V);const x=w.filter((t=>"frame1"!==t._rev&&"frame2"!==t._rev));const O=Object.fromEntries(x.map(((t,e)=>[t._rev,e])));const _=m.map((t=>O[t]));const S=x.map(_t(lt));S[0]=Object.assign(Object.assign({},S[0]),{exp:t,env:e,mod:n,root:r});const j=(t=>e=>n=>r=>{if(!wt(r)||!r._rev||!Object.keys(e).includes(r._rev.toString()))return r;const o=`${n}/${e[r._rev].toString()}`;const i=r._id||o;const s=r._root||t||i;const c=Object.assign(Object.assign({},r),{_rev:o,_id:i,_root:s});const u=Object.create(Object.getPrototypeOf(r));return Object.assign(u,c)})(u)(O);return{sendTx:()=>v(this,void 0,void 0,(function*(){return this.db.update(m,S,_)})),getVal:t=>jt(j(t))(h),getTx:()=>v(this,void 0,void 0,(function*(){return this.db.getTx(m,S,_)})),ioMap:_}}))}}qt.updateWithRevImpure=t=>e=>{wt(e)&&void 0===e._rev&&(e._rev=t())};class Vt{constructor({db:t=new Rt}={}){this.db=t,this.reader=new qt({db:t}),this.modules=new At({db:t}),Vt.proxyDepth=Vt.proxyDepth||0}write(t,e={},n="",r){return v(this,void 0,void 0,(function*(){const{sendTx:o,getVal:i}=yield this.reader.getValAndTx(t,e,n,r);const[s]=yield o();const{txId:c}=Y(s);return i(c)}))}createTx(t,e={},n="",r){return v(this,void 0,void 0,(function*(){const{getTx:o}=yield this.reader.getValAndTx(t,e,n,r);return yield o()}))}}class Gt{constructor({db:t=new Rt}={}){this.writer=new Vt({db:t})}get(t,e){return"function"!=typeof t[e]?Reflect.get(t,e):(...n)=>v(this,void 0,void 0,(function*(){const{argString:r,env:o}=Q(n);const i=`__bc__.${String(e)}(${r})`;const s=Object.assign(Object.assign({},o),{__bc__:t._rev});const{res:c,env:u}=yield this.writer.write(i,s,"","__bc__");const a=p(u,["_rev","_id","_root"]);return Object.entries(a).forEach((([e,r])=>{const o=parseInt(e.slice(4,-2),10);const i=Number.isNaN(o)?t:n[o];Object.entries(r).forEach((([t,e])=>{i[t]=e}))})),c}))}}const{bitcore:Zt}=a.default;const{crypto:Yt}=Zt;t.Computer=class{constructor(t={}){if(void 0!==t.seed)throw new Error('The constructor parameter "seed" has been renamed to "mnemonic".');this.db=new Rt(t)}write(t,e,n){return v(this,void 0,void 0,(function*(){const r=new Vt({db:this.db});const{res:o}=yield r.write(t,e,n);const i=new Gt({db:this.db});return new Proxy(o,i)}))}read(t){return v(this,void 0,void 0,(function*(){const e=new qt({db:this.db});const n=yield e.read(t);const r=new Gt({db:this.db});return new Proxy(n,r)}))}new(t,e,n=""){return v(this,void 0,void 0,(function*(){const{db:r}=this;const o=new Vt({db:r});const i=new Gt({db:r});const{argString:s,env:c}=Q(e||[]);const u=`${t} new ${t.name}(${s})`;const{res:a,env:d}=yield o.write(u,c,n);const h=p(d,["_rev","_id","_root"]);return Object.values(h).forEach(((t,n)=>{const r=e[n];Object.entries(t).forEach((([t,e])=>{r[t]=e}))})),new Proxy(a,i)}))}getCreateTx(t,e,n=""){return v(this,void 0,void 0,(function*(){const{db:r}=this;const o=new Vt({db:r});const{argString:i,env:s}=Q(e||[]);const c=`${t} new ${t.name}(${i})`;return yield o.createTx(c,s,n)}))}query(t){return v(this,void 0,void 0,(function*(){const{publicKey:e,contract:n,limit:r,offset:o,order:i}=t;let s={};if(e&&(s=Object.assign(Object.assign({},s),{publicKey:new Zt.PublicKey(e).toString()})),n){const t="string"==typeof n?n:n.toString();s=Object.assign(Object.assign({},s),{classHash:Yt.Hash.sha256(Buffer.from(t)).toString("hex")})}if("number"==typeof r||"number"==typeof o){if("number"==typeof r&&r<0)throw new Error("LIMIT must not be negative.");if("number"==typeof o&&o<0)throw new Error("OFFSET must not be negative.");void 0!==r&&(s=Object.assign(Object.assign({},s),{limit:r.toString()})),void 0!==o&&(s=Object.assign(Object.assign({},s),{offset:o.toString()})),s=Object.assign(Object.assign({},s),{order:i||"ASC"})}return this.db.wallet.restClient.query(s)}))}idsToRevs(t){return v(this,void 0,void 0,(function*(){return this.db.wallet.restClient.idsToRevs(t)}))}deploy(t){return v(this,void 0,void 0,(function*(){return new At(this).deploy(t)}))}import(t,e){return v(this,void 0,void 0,(function*(){return(yield At.import(e))[t]}))}getChain(){return this.db.wallet.restClient.chain}getNetwork(){return this.db.wallet.restClient.network}getMnemonic(){return this.db.wallet.restClient.mnemonic.toString()}getPrivateKey(){return this.db.wallet.privateKey.toString()}getPublicKey(){return this.db.wallet.publicKey.toString()}getAddress(){return this.db.wallet.address.toString()}sign(t){t.sign(this.getPrivateKey(),1)}getBalance(){return v(this,void 0,void 0,(function*(){return this.db.wallet.getBalance()}))}getUtxos(){return v(this,void 0,void 0,(function*(){const t=new Zt.Address(this.getAddress());return this.db.wallet.restClient.getUtxosByAddress(t)}))}broadcast(t){return v(this,void 0,void 0,(function*(){return this.db.wallet.restClient.sendTransaction(t.toObject())}))}queryRevs(t){return v(this,void 0,void 0,(function*(){return this.query(t)}))}getOwnedRevs(t=this.db.wallet.publicKey){return this.query({publicKey:t.toString()})}getRevs(t=this.db.wallet.publicKey){return v(this,void 0,void 0,(function*(){return this.query({publicKey:t.toString()})}))}getLatestRevs(t){return v(this,void 0,void 0,(function*(){return this.idsToRevs(t)}))}getLatestRev(t){return v(this,void 0,void 0,(function*(){const[e]=yield this.idsToRevs([t]);return e}))}rpcCall(t,e){return v(this,void 0,void 0,(function*(){const n=yield this.db.wallet.restClient.rpc(t,e);return n.result?n.result:{}}))}sync(t){return v(this,void 0,void 0,(function*(){return this.read(t)}))}},Object.defineProperty(t,"__esModule",{value:!0})}({},Mnemonic,axios,crypto,CryptoJS,eciesjs,endoStaticModuleRecord);
