import t from"@bitcoin-computer/bitcore-mnemonic-ltc";import e from"axios";import n from"crypto";import r from"crypto-js";import*as o from"eciesjs";import{StaticModuleRecord as i}from"@endo/static-module-record";import"ses";function s(t,e){var n={};for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&e.indexOf(r)<0&&(n[r]=t[r]);if(null!=t&&"function"==typeof Object.getOwnPropertySymbols){var o=0;for(r=Object.getOwnPropertySymbols(t);o<r.length;o++)e.indexOf(r[o])<0&&Object.prototype.propertyIsEnumerable.call(t,r[o])&&(n[r[o]]=t[r[o]])}return n}function c(t,e,n,r){return new(n||(n=Promise))((function(o,i){function s(t){try{u(r.next(t))}catch(t){i(t)}}function c(t){try{u(r.throw(t))}catch(t){i(t)}}function u(t){var e;t.done?o(t.value):(e=t.value,e instanceof n?e:new n((function(t){t(e)}))).then(s,c)}u((r=r.apply(t,e||[])).next())}))}const{CHAIN:u,NETWORK:a,BCN_URL:d,RPC_USER:h,RPC_PASSWORD:l,TEST_MNEMONICS:p}=process.env;const f=u||"LTC";const v=a||"testnet";const g=d||"https://node.bitcoincomputer.io";const b="LTC"===f?3e4:3e3;const m="LTC"===f?5820:582;const{crypto:w}=t.bitcore;const y=(t,e)=>{const n=Date.now();const r=w.Hash.sha256(Buffer.from(e+n));const o=[w.ECDSA.sign(r,t,"big").toString("hex"),t.publicKey.toString(),n];return`Bearer ${Buffer.from(o.join(":")).toString("base64")}`};class x{constructor(e=g,n=new t.bitcore.PrivateKey,r={}){this.baseUrl=e,this.headers=r,this.privateKey=n}get(t){return c(this,void 0,void 0,(function*(){const n=this.privateKey?{Authentication:y(this.privateKey,this.baseUrl)}:{};return(yield e.get(`${this.baseUrl}${t}`,{headers:Object.assign(Object.assign({},this.headers),n)})).data}))}post(t,n){return c(this,void 0,void 0,(function*(){const r=this.privateKey?{Authentication:y(this.privateKey,this.baseUrl)}:{};return(yield e.post(`${this.baseUrl}${t}`,n,{headers:Object.assign(Object.assign({},this.headers),r)})).data}))}delete(t){return c(this,void 0,void 0,(function*(){const n=this.privateKey?{Authentication:y(this.privateKey,this.baseUrl)}:{};return(yield e.delete(`${this.baseUrl}${t}`,{headers:Object.assign(Object.assign({},this.headers),n)})).data}))}}parseInt(process.env.BC_DEFAULT_FEE||"",10),parseInt(process.env.BC_SCRIPT_CHUNK_SIZE||"",10),parseInt(process.env.MWEB_HEIGHT||"",10);const{PublicKey:O,crypto:_,Script:S}=t.bitcore;const{Point:j}=_;function E(t){let e=t.toBuffer().length+9;return t.isWitnessProgram()?e+=67.75:e+=148,b*e/1e3}function T(t){return Buffer.from(t,"hex").toString().replace(/\0/g,"")}function $(t,e){return t.slice(e)+t.slice(0,e)}function C(t,e,n){if(t.length*Math.log2(e)>53)throw new Error(`Input too large ${t.length} ${Math.log2(e)}`);if(![2,10,16].includes(e)||![2,10,16].includes(n))throw new Error("ToBase or FromBase invalid in covertNumber.");if(2===e&&t.length%8!=0)throw new Error("Binary strings must be byte aligned.");if(16===e&&t.length%2!=0)throw new Error("Hex strings must be of even length.");const r=parseInt(t,e).toString(n);return 2===n?r.padStart(8*Math.ceil(r.length/8),"0"):16===n?r.padStart(2*Math.ceil(r.length/2),"0"):r}function I(t,e){const n=new RegExp(`.{1,${e}}`,"g");return t.match(n)||[]}function K(t){return I(t,2).map((t=>C(t,16,2))).join("")}function k(t){return I(t,8).map((t=>C(t,2,16))).join("")}function B(t){if(62!==t.length)throw new Error("Input to hexToPublicKey must be of length 62");let e=!1;let n=0;let r;for(;!e;){if(n>=256)throw new Error("Something went wrong storing data");const o=n.toString(16).padStart(2,"0")+k($(K(t).padStart(64,"0"),n));try{r=j.fromX(!1,o),e=!0}catch(t){n+=1}}if(!r)throw new Error("Something went wrong storing data");return new O(r)}function P(t){const e=t.point.getX().toString("hex").padStart(64,"0");const n=C(e.slice(0,2),16,10);return k((o=parseInt(n,10),(r=K(e.slice(2))).slice(-o)+r.slice(0,-o)));var r,o}function A(t,e){const n={"any-testnet":"uTKUDCkpo12vstJBsMWmrTPz9wFE6DuzGH","BTC-mainnet":"igpnnoLziUyxtQuWYCP13gHYVhUru6iLaY","LTC-mainnet":"t77o829ngHnuUorwDkf129fL6ERLFNqKG8"};return $("testnet"===e||"regtest"===e?n["any-testnet"]:n[`${t}-${e}`],19)}function R(t=f,e=v){if("testnet"===e||"regtest"===e)return 1;if("BTC"===t)return 0;if("LTC"===t)return 2;if("DOGE"===t)return 3;if("BCH"===t)return 145;if("BSV"===t)return 236;throw new Error(`Unsupported chain ${t}`)}function D({chain:t=f,network:e=v}={}){return function({purpose:t=44,coinType:e=2,account:n=0}={}){return`m/${t.toString()}'/${e.toString()}'/${n.toString()}'`}({coinType:R(t,e)})}function M(t,e){return O.fromString(function(t,e){const n={"any-testnet":"be88416b08d0bfcc88102c4d9b558662f570dbd0676e6fa167552117933f133b8d","BTC-mainnet":"cd3a3ef0281ab2ce66a02ea770fbc2c41e46816ab821c9a91435958284b4aaef13","LTC-mainnet":"12d020c11112a2839d302548072bddbdfbcd39472a54b45a016456b8e30ea631aa"};return $("testnet"===e||"regtest"===e?n["any-testnet"]:n[`${t}-${e}`],19)}(t,e))}function U({mnemonic:e=new t,path:n=D(),passphrase:r="",network:o=v}){return e.toHDPrivateKey(r,o).deriveChild(n)}function H(t){return/^[0-9A-Fa-f]{64}\/\d+$/.test(t)}function N(t){if(!/^[0-9A-Fa-f]{64}$/.test(t))throw new Error(`Invalid txId: ${t}`)}function L(t){if(!/^[0-9A-Fa-f]{64}\/\d+$/.test(t))throw new Error(`Invalid outId: ${t}`)}function J(t){L(t);const[e,n]=t.split("/");return{txId:e,outputIndex:parseInt(n,10)}}const F=t=>{const e=[];const n={};let r=0;return t.forEach((t=>{"string"==typeof t?e.push(`'${t}'`):"number"==typeof t||"boolean"==typeof t?e.push(t):"object"==typeof t&&(t._rev?(e.push(`__bc${r}__`),n[`__bc${r}__`]=t._rev,r+=1):e.push(t))})),{argString:e.join(","),env:n}};function z(t){const e=t.match(/.{1,8}/g);const n=null==e?void 0:e.map((t=>parseInt(t,2)));return Buffer.from(new Uint8Array(n).buffer)}function W(t){return Array.from(t).map((t=>t.toString(2).padStart(8,"0"))).join("")}const{Transaction:q}=t.bitcore;const{UnspentOutput:V}=q;class G{constructor({chain:e,network:n,mnemonic:r,path:o,passphrase:i,url:s}={}){if(this.chain=e?e.toUpperCase():f,this.network=n?n.toLowerCase():v,this.mnemonic=new t(r?r.toString():void 0),this.path=o||D({chain:this.chain,network:this.network}),this.passphrase=i||"",this.bcn=new x(s,this.privateKey),!["LTC","BTC"].includes(this.chain))throw new Error("We currently only support LTC, support for other currencies will be added soon.");if(!["mainnet","testnet","regtest"].includes(this.network))throw new Error("Please set 'network' to 'regtest', 'testnet', or 'mainnet'")}get privateKey(){return U(this).privateKey}getBalance(t){return c(this,void 0,void 0,(function*(){const{chain:e,network:n}=this;return yield this.bcn.get(`/v1/${e}/${n}/address/${t}/balance`)}))}getTransactions(t){return c(this,void 0,void 0,(function*(){return(yield this.getRawTxs(t)).map((t=>new q(t)))}))}getRawTxs(t){return c(this,void 0,void 0,(function*(){t.map(N);const{chain:e,network:n}=this;return this.bcn.post(`/v1/${e}/${n}/tx/bulk/`,{txIds:t})}))}sendTransaction(t){return c(this,void 0,void 0,(function*(){return this.bcn.post(`/v1/${this.chain}/${this.network}/tx/send`,{txJSON:t})}))}getUtxosByAddress(t){return c(this,void 0,void 0,(function*(){const{chain:e,network:n}=this;return(yield this.bcn.get(`/v1/${e}/${n}/wallet/${t.toString()}/utxos`)).map((({rev:e,scriptPubKey:n,satoshis:r})=>{const[o,i]=e.split("/");return new V({address:t,txId:o,outputIndex:parseInt(i,10),satoshis:r,script:n})}))}))}query(t){return c(this,void 0,void 0,(function*(){const{publicKey:e,classHash:n,limit:r,offset:o,order:i}=t;if(void 0===e&&void 0===n)throw new Error("Query parameters cannot be empty.");let s="";e&&(s+=`?publicKey=${e}`),n&&(s+=0===s.length?"?":"&",s+=`classHash=${n}`),void 0!==r&&(s+=`&limit=${r}`),void 0!==o&&(s+=`&offset=${o}`),i&&(s+=`&order=${i}`);const{chain:c,network:u}=this;return this.bcn.get(`/v1/${c}/${u}/non-standard-utxos${s}`)}))}idsToRevs(t){return c(this,void 0,void 0,(function*(){t.map(L);const{chain:e,network:n}=this;return this.bcn.post(`/v1/${e}/${n}/revs`,{ids:t})}))}rpc(t,e){return c(this,void 0,void 0,(function*(){return this.bcn.post(`/v1/${this.chain}/${this.network}/rpc`,{method:t,params:e})}))}static getSecretOutput({_url:t,privateKey:e}){return c(this,void 0,void 0,(function*(){const n=t.split("/");const r=n[n.length-1];const o=n.slice(0,-2).join("/");const i=new x(o,e);return{host:o,data:yield i.get(`/v1/store/${r}`)}}))}static setSecretOutput({secretOutput:t,host:e,privateKey:n}){return c(this,void 0,void 0,(function*(){return new x(e,n).post("/v1/store/",t)}))}static deleteSecretOutput({_url:t,privateKey:e}){return c(this,void 0,void 0,(function*(){const n=t.split("/");const r=n[n.length-1];const o=n.slice(0,-2).join("/");const i=new x(o,e);yield i.delete(`/v1/store/${r}`)}))}get url(){return this.bcn.baseUrl}}const{PublicKey:Z,Script:Y}=t.bitcore;function Q(t,e,n,r){if(t.length>3)throw new Error("Too many owners");return function(t,e,n,r){const o=r?[...t,M(e,n).toBuffer()]:t;const i=new Y;return i.add("OP_1"),o.forEach((t=>{i.add(t)})),i.add(`OP_${o.length}`),i.add("OP_CHECKMULTISIG"),i}(t.map((t=>t.toBuffer())),e,n,r)}function X(t,e){return function(t,e){const n=t.chunks.filter((t=>t.buf));return(e?n.slice(0,-1):n).map((t=>t.buf))}(t,e).map((t=>Z.fromBuffer(t)))}function tt(t){return Buffer.from(r.SHA256(t).toString(),"hex").toString("hex").substr(0,4)}function et(t){return`${tt(t)};${t}`}function nt(t){const e=t.substr(0,4);const n=t.substr(5);if(!function(t,e){return tt(t)===e}(n,e))throw new Error("Decryption failure");return n}var rt;!function(t){t.Array="Array",t.Boolean="boolean",t.Null="Null",t.Number="number",t.Object="Object",t.String="string",t.Undefined="undefined"}(rt||(rt={}));const ot=["_owners","_readers","_amount"];const it=ot.concat(["_id","_rev","_root"]);const st=t=>(Object.prototype.toString.call(t).match(/\s([a-zA-Z]+)/)||[])[1];const ct=t=>"object"==typeof t?st(t):st(t).toLowerCase();const ut=t=>ct(t)===rt.Null;const at=t=>ct(t)===rt.Number;const dt=t=>ut(t)||ct(t)===rt.Undefined||at(t)||(t=>ct(t)===rt.String)(t)||(t=>ct(t)===rt.Boolean)(t);const ht=t=>!dt(t)&&!Array.isArray(t);const lt=t=>!dt(t)&&Array.isArray(t);const pt=t=>e=>dt(e)?t(e):lt(e)?e.flatMap(pt(t)):ht(e)?[...t(e),...Object.values(e).flatMap(pt(t))]:[];const ft=t=>ht(t)?[Object.fromEntries(Object.entries(t).filter((([t])=>it.includes(t))))]:(dt(t),[]);const vt=t=>e=>t.reduce(((t,n)=>(Object.keys(e).includes(n)&&(t[n]=e[n]),t)),{});const gt=t=>{return e=([e,n])=>[e,t(n)],t=>Object.fromEntries(Object.entries(t).map((t=>e(t))));var e};const bt=t=>e=>{if(dt(e))return t(e);if(lt(e))return t(e.map(bt(t)));if(ht(e)){const n=t(gt(bt(t))(e));const r=Object.create(Object.getPrototypeOf(e));return Object.assign(r,n)}throw new Error("Unsupported type")};const mt=t=>e=>{if(dt(e));else if(lt(e))e.forEach(mt(t));else{if(!ht(e))throw new Error("Unsupported type");{t(e);const n=(t=>{return e=([e,n])=>[e,t(n)],t=>{Object.entries(t).forEach((t=>e(t)))};var e})(mt(t))(e);const r=Object.create(Object.getPrototypeOf(e));Object.assign(r,n)}}};const wt=t=>e=>n=>{if(dt(n))return t(e,n);const r=ht(n)?Object.values(n):n;const o=r.flatMap((n=>wt(t)(e)(n)));return r.reduce(t,o)};const yt=bt((t=>t));function xt(t){if(void 0!==t._readers){const{_readers:e,_url:i,_owners:c,_amount:u}=t,a=s(t,["_readers","_url","_owners","_amount"]);const d=function(t,e){const i=n.randomBytes(32).toString("hex");const s=function(t,e){if(!/^[0-9a-f]{64}$/.test(e))throw new Error("Invalid secret");const n=Buffer.from(e,"hex").toString("binary");const o=et(t);return r.AES.encrypt(o,n).toString()}(t,i);const c=e.map((t=>function(t,e){if(!/^0[2-3][0-9a-f]{64}|04[0-9a-f]{128}$/.test(e))throw new Error("Invalid publicKey");const n=et(t);return o.encrypt(e,Buffer.from(n,"utf8")).toString("base64")}(i,t)));return{__cypher:s,__secrets:c}}(JSON.stringify(a),e);return void 0!==i&&(d._url=i),void 0!==c&&(d._owners=c),void 0!==u&&(d._amount=u),d}return t}const{Transaction:Ot}=t.bitcore;const{Output:_t,UnspentOutput:St}=Ot;class jt{constructor({restClient:t=new G}={}){this.tx=new Ot,this.tx.feePerKb(1e4),this.outData=[],this.restClient=t}get txId(){return this.tx.id}get chain(){return this.restClient.chain}get network(){return this.restClient.network}get inputs(){return this.tx.inputs.map((t=>`${t.prevTxId.toString("hex")}/${t.outputIndex}`))}get encoding(){const{outputs:t}=this.tx;const e=t.filter((({script:t})=>null==t?void 0:t.isDataOut())).map((({script:t})=>t.getData()));const{ioDescriptor:n=[],ioMap:r=[],dataPrefix:o=""}=e.length?function(t){const e=t.subarray(0,6);const n=t.subarray(6);const r=W(e).match(/.{1,12}/g).map((t=>parseInt(t,2)));const o=r[3];const i=Math.ceil(o/8);return{ioDescriptor:r,ioMap:function(t){const e=t.split("").reverse().join("");const n=[];for(let t=0;t<e.length;t+=1)"1"===e[t]&&n.push(t);return n}(W(n.subarray(0,i))),dataPrefix:n.subarray(i).toString("utf8")}}(e[0]):{};return n.length&&n[0]>this.tx.inputs.length||n.length&&n[1]>this.tx.outputs.length||n.length&&n[2]>this.tx.outputs.length?{ioDescriptor:[],ioMap:[],dataPrefix:""}:{ioDescriptor:n,ioMap:r,dataPrefix:o}}get ioDescriptor(){return this.encoding.ioDescriptor}get dataPrefix(){return this.encoding.dataPrefix}get ioMap(){return this.encoding.ioMap}get inputsLength(){const[t=0]=this.ioDescriptor;return t}get outputsLength(){const[,t=0]=this.ioDescriptor;return t}get maxDataIndex(){const[,,t=-1]=this.ioDescriptor;return t}get ownerInputs(){return this.tx.inputs.slice(0,this.inputsLength)}get ownerOutputs(){return this.tx.outputs.slice(0,this.outputsLength)}get inRevs(){return this.ownerInputs.map((({prevTxId:t,outputIndex:e})=>`${t.toString("hex")}/${e}`))}get outRevs(){return this.ownerOutputs.map(((t,e)=>`${this.tx.id}/${e}`))}get zip(){return this.ownerOutputs.map(((t,e)=>[this.ioMap.indexOf(e)>=0?this.inRevs[this.ioMap.indexOf(e)]:null,this.outRevs[e]]))}isBcTx(){return this.tx.outputs.some((t=>t.script.toAddress(this.network).toString()===A(this.chain,this.network)))}getOwnerOutputs(){const[,t=0]=this.ioDescriptor;return this.tx.outputs.slice(0,t)}getDataOutputs(){const[,t,e]=this.ioDescriptor;return this.tx.outputs.slice(t,e)}getOutData(){return c(this,void 0,void 0,(function*(){try{const t=this.getDataOutputs().map((t=>t.script)).map((t=>X(t,!0))).flat().map(P).map(T).join("");const{dataPrefix:e}=this;const n=JSON.parse(e+t);const i=this.restClient.privateKey.toBuffer().toString("hex");const u=this.getOwnerOutputs();if(u.length!==n.length)throw new Error("Inconsistent state");const a=u.map(((t,e)=>Object.assign(Object.assign({},n[e]),{_owners:X(t.script,!1).map((t=>t.toString())),_amount:t.satoshis})));return Promise.all(a.map((t=>c(this,void 0,void 0,(function*(){try{return function(t,e){if(function(t){return ht(t)&&"__cypher"in t&&"__secrets"in t}(t)){const{__cypher:n,__secrets:i}=t,c=s(t,["__cypher","__secrets"]);return Object.assign(Object.assign(Object.assign({},c),JSON.parse(function({__cypher:t,__secrets:e},n){let i="";if(n.forEach((n=>{e.forEach((e=>{try{const s=function(t,e){if(!/^[0-9a-f]{64}$/.test(e))throw new Error("Invalid privateKey");return nt(o.decrypt(e,Buffer.from(t,"base64")).toString("utf8"))}(e,n);i=function(t,e){if(!/^[0-9a-f]{64}$/.test(e))throw new Error("Invalid secret");const n=Buffer.from(e,"hex").toString("binary");return nt(r.AES.decrypt(t,n).toString(r.enc.Utf8))}(t,s)}catch(t){const e=["Decryption failure","Unsupported state or unable to authenticate data"];if(t instanceof Error&&!e.includes(t.message))throw t}}))})),i)return i;throw new Error("Decryption failure")}({__cypher:n,__secrets:i},e))),{_readers:[]})}return t}(yield function(t){return e=>c(this,void 0,void 0,(function*(){if(function(t){return ht(t)&&"_url"in t}(e)){const{_url:n}=e,r=s(e,["_url"]);const{host:o,data:i}=yield G.getSecretOutput({_url:n,privateKey:t});return Object.assign(Object.assign(Object.assign({},r),JSON.parse(i)),{_url:o})}return e}))}(this.restClient.privateKey)(t),[i])}catch(t){return null}})))))}catch(t){return[]}}))}getOwners(){return this.getOwnerOutputs().map((t=>X(t.script,!1).map((t=>t.toString()))))}getAmounts(){return this.getOwnerOutputs().map((t=>t.satoshis))}spendFromData(e){return c(this,void 0,void 0,(function*(){if(!e.length)return;const n=e.map(J);const r=n.map((t=>t.txId));const o=yield this.restClient.getTransactions(r);for(let e=0;e<n.length;e+=1){const{txId:r,outputIndex:i}=n[e];const{outputs:s}=o[e];const c=s[i];const u=Math.round(c.satoshis);const a=new t.bitcore.Script(c.script);const d=new St({txId:r,outputIndex:i,satoshis:u,script:a});const h=X(a,!1).map((t=>t.toString()));this.tx.from([d],h,1,{noSorting:!0})}}))}createDataOuts(e,n=[]){e.forEach((({_amount:e,_owners:n=[]})=>{if(Array.isArray(n)&&n.length>3)throw new Error("Too many owners.");const r=Q(n.map((e=>t.bitcore.PublicKey.fromString(e))),this.chain,this.network,!1);const o=e||E(r);this.tx.addOutput(new _t({script:r,satoshis:o}))}));const r=e.map((t=>s(t,["_amount","_owners"])));const{opReturnBuffer:o,dataScripts:i}=function(t,e,n,r,o,i){const s=function(t){const e=[];let n=0;let r;if(t.sort(((t,e)=>t-e))!==t)throw new Error("numbers must be in ascending order");for(let e=0;e<t.length;e+=1)if(t[e]===t[e+1])throw new Error("numbers must not contain duplicates");for(let o=0;n<t.length;o+=1)o===t[n]?(r="1",n+=1):r="0",e.unshift(r);return function(t,e){let n;if(t.length%2!=0){const e=t.length/2;n=2*Math.ceil(e)}return t.padStart(n,"0")}(e.join(""))}(r);const c=z(s.padStart(8*Math.ceil(s.length/8),"0"));const u=JSON.stringify(n);const a=80-(6+c.length);const d=u.slice(0,a);const h=function(t,e,n,r){var o;return function(t,e){const n=[];for(let e=0;e<t.length;e+=2)n.push(t.slice(e,e+2));return n}(I((o=t,Buffer.from(o).toString("hex")),62).map((t=>t.padStart(62,"0"))).map(B)).map((t=>Q(t,e,n,!0)))}(u.slice(a),o,i);const l=z([t,e,e+h.length,s.length].map((t=>t.toString(2).padStart(12,"0"))).join(""));const p=Buffer.from(d);return{opReturnBuffer:Buffer.concat([l,c,p]),dataScripts:h}}(this.tx.inputs.length,this.tx.outputs.length,r,n,this.chain,this.network);i.forEach((t=>{const e=E(t);this.tx.addOutput(new _t({script:t,satoshis:e}))})),this.tx.addData(o)}static getBcTx({hex:t="",restClient:e=new G}){const n=new this({restClient:e});return n.tx.fromString(t),n.outData=[],n}static fromTxHex({hex:t="",restClient:e=new G}){return c(this,void 0,void 0,(function*(){let n=[];let r=[];let o=[];const i=new this({restClient:e});i.tx.fromString(t);try{n=yield i.getOutData()}catch(t){}try{r=i.getOwners()}catch(t){}try{o=i.getAmounts()}catch(t){}return i.outData=n.map(((t,e)=>Object.assign(Object.assign({},t),{_owners:r[e],_amount:o[e]}))),i}))}static fromTxId({txId:t="",restClient:e=new G}){return c(this,void 0,void 0,(function*(){const[n]=yield e.getRawTxs([t]);return this.fromTxHex({hex:n,restClient:e})}))}}class Et{constructor(t={}){this.restClient=new G(t)}derive(t="0"){const e=`${this.path}${this.path.length>0?"/":""}${t}`;const{chain:n,network:r,url:o,mnemonic:i,passphrase:s}=this.restClient;return new Et({chain:n,network:r,url:o,mnemonic:i.toString(),path:e,passphrase:s})}getBalance(){return c(this,void 0,void 0,(function*(){return this.restClient.getBalance(this.address)}))}getUtxosByEfectiveValue(e){return c(this,void 0,void 0,(function*(){const n=yield this.restClient.getUtxosByAddress(this.address);let r=0;const o=[];!function(t){const e=t;for(let t=e.length-1;t>0;t-=1){const n=Math.floor(Math.random()*(t+1));[e[t],e[n]]=[e[n],e[t]]}}(n);for(const i of n){const n=t.bitcore.Transaction.Input.fromObject({address:i.address,prevTxId:i.txId,outputIndex:i.outputIndex,script:i.script,satoshis:i.amount})._estimateSize();if(i.satoshis-10*n<0)throw new Error(`Invalid amount when selecting coins: utxo.satoshis ${null==i?void 0:i.satoshis} FEE_PER_KB 10000 estimated size: ${n}`);if(r+=i.satoshis-10*n,o.push(i),r>=e)return o}const{network:i,chain:s}=this.restClient;const c=this.address.toString();throw new Error(`Insufficient balance in address ${c} on ${i} ${s}. Found ${r}, required ${e}.`)}))}fundAndSendTx(t){return c(this,void 0,void 0,(function*(){return yield this.fundTx(t),this.sendTx(t)}))}fundTx(e){return c(this,void 0,void 0,(function*(){e.tx.feePerKb(1e4);const{chain:n,network:r}=this.restClient;const o=Math.max(5e3,m);e.tx.to(A(n,r),o);const i=e.tx._getInputAmount();const s=e.tx._getOutputAmount();const c=e.tx._estimateFee();const u=s-i+Math.round(c);u>0&&(yield this.getUtxosByEfectiveValue(u)).forEach((n=>{e.tx.from([new t.bitcore.Transaction.UnspentOutput(n)])})),e.tx.change(this.address.toString()),e.tx.sign(this.privateKey,1)}))}sendTx(t){return c(this,void 0,void 0,(function*(){return this.restClient.sendTransaction(t.tx)}))}send(t,e){return c(this,void 0,void 0,(function*(){const{restClient:n}=this;const r=new jt({restClient:n});return r.tx.to(e,t),this.fundAndSendTx(r)}))}get hdPrivateKey(){return U(this.restClient)}get privateKey(){return this.hdPrivateKey.privateKey}get publicKey(){return this.hdPrivateKey.publicKey}get passphrase(){return this.restClient.passphrase}get path(){return this.restClient.path}get chain(){return this.restClient.chain}get network(){return this.restClient.network}get url(){return this.restClient.url}get mnemonic(){return this.restClient.mnemonic}get address(){return this.publicKey.toAddress(this.restClient.network)}}class Tt{constructor(t={}){this.wallet=new Et(t)}fromTxHex(t){return c(this,void 0,void 0,(function*(){const{restClient:e}=this.wallet;return jt.fromTxHex({hex:t,restClient:e})}))}fromTxId(t){return c(this,void 0,void 0,(function*(){const[e]=yield this.wallet.restClient.getRawTxs([t]);return this.fromTxHex(e)}))}get(t){return c(this,void 0,void 0,(function*(){const e=t.map(J);return Promise.all(e.map((({txId:t,outputIndex:e})=>c(this,void 0,void 0,(function*(){const{outData:n}=yield this.fromTxId(t);if(e>n.length)throw new Error("Index out of bounds");return n[e]})))))}))}put(t){return this.update([],t)}getBcTx(t){const{restClient:e}=this.wallet;return jt.getBcTx({hex:t,restClient:e})}createTx(t,e,n=[]){return c(this,void 0,void 0,(function*(){const{wallet:r}=this;const{restClient:o}=r;const i=new jt({restClient:o});const{privateKey:u,publicKey:a}=r;const d=e.map((t=>{var{_owners:e}=t,n=s(t,["_owners"]);return Object.assign({_owners:e||[a.toString()]},n)}));const h=d.map(xt);const l=yield Promise.all(h.map(function(t){return e=>c(this,void 0,void 0,(function*(){if(void 0!==e._url){const{_url:n,_owners:r,_amount:o}=e,i=s(e,["_url","_owners","_amount"]);const c=yield G.setSecretOutput({host:n,secretOutput:{data:JSON.stringify(i)},privateKey:t});return void 0!==r&&(c._owners=r),void 0!==o&&(c._amount=o),c}return e}))}(u)));return yield i.spendFromData(t),yield i.createDataOuts(l,n),i}))}update(t,e,n=[]){return c(this,void 0,void 0,(function*(){const r=yield this.createTx(t,e,n);return yield this.wallet.fundAndSendTx(r),r.outRevs}))}getTx(t,e,n=[]){return c(this,void 0,void 0,(function*(){const r=yield this.createTx(t,e,n);return yield this.wallet.fundTx(r),r}))}}class $t{constructor({db:t=new Tt}={}){this.db=t}deploy(t){return c(this,void 0,void 0,(function*(){const[e]=yield this.db.put([{mod:t}]);return e}))}static bitcoinResolveHook(t){return t}static bitcoinImportHook(t){return c(this,void 0,void 0,(function*(){const[e]=yield(new Tt).get([t]);return new i(e.mod,t)}))}static nodeResolveHook(t="",e=""){if(void 0===t||void 0===e)throw new Error("!!! Invalid arguments");if(t.startsWith("/"))throw TypeError(`Module specifier ${t} must not begin with "/"`);if(!e.startsWith("./"))throw TypeError(`Module referrer ${e} must begin with "./"`);const n=[];const r=[];(t=>t.startsWith("./")||t.startsWith("../")||"."===t||".."===t)(t)&&(r.push(...e.split("/")),r.pop(),n.push(".")),r.push(...t.split("/"));for(const o of r)if("."===o||""===o);else if(".."===o){if(0===r.length)throw TypeError(`Module specifier ${t} via referrer ${e} must not traverse behind an empty path`);n.pop()}else n.push(o);return n.join("/")}static resolveHook(t,e){if(H(e)&&!H(t))throw new Error("Requiring a local file from a module on the blockchain is not supported.");return H(t)?$t.bitcoinResolveHook(t):$t.nodeResolveHook(t,e)}static makeImportHook(){return t=>{if(H(t))return $t.bitcoinImportHook(t);throw new Error("Not a valid import")}}static getBitcoinCompartment(){const{resolveHook:t,makeImportHook:e}=$t;return new Compartment({},{},{resolveHook:t,importHook:e()})}static import(t){return c(this,void 0,void 0,(function*(){const e=$t.getBitcoinCompartment();const{namespace:n}=yield e.import(t);return n}))}}var Ct;class It{constructor(t){this.enc=at(t)?t:ut(t)?{null:new It(1)}:lt(t)?gt((t=>new It(t)))(Object.fromEntries(Object.entries(t))):ht(t)?gt((t=>new It(t)))(t):{[t.toString()]:new It(1)},this.type=ct(t)}}Ct=It,It.zero=t=>({type:t,enc:t===rt.Number?0:{}}),It.isZero=t=>Kt(t)?0===t.enc:0===Object.keys(t.enc).length,It.isReal=t=>!kt(t)||1===Object.keys(t.enc).length&&1===t.enc[Object.keys(t.enc)[0]].enc,It.scalarMult=t=>e=>{if(Kt(e))return{type:e.type,enc:Number(e.enc)*t};if(At(e))return{type:e.type,enc:gt(It.scalarMult(t))(e.enc)};throw new Error(`Cannot multiply ${t} with ${e}`)},It.add=t=>e=>{if(Kt(t)&&Kt(e))return{type:rt.Number,enc:t.enc+e.enc};if(At(t)&&At(e)){const n=[...Object.keys(t.enc),...Object.keys(e.enc)].map((n=>{const r=t.enc[n]||It.zero(e.enc[n].type);const o=e.enc[n]||It.zero(t.enc[n].type);return[n,It.add(r)(o)]})).filter((([,t])=>!It.isZero(t)));return{type:t.type,enc:Object.fromEntries(n)}}throw new Error(`Cannot add ${JSON.stringify(t,null,2)} and ${JSON.stringify(e,null,2)}`)},It.toJson=t=>{if(Kt(t))return t.enc;if(Pt(t)){const e=Object.entries(t.enc).filter((([,t])=>It.isReal(t)));const n=Object.fromEntries(e);return gt(It.toJson)(n)}if(Bt(t))return Object.entries(t.enc).filter((([,t])=>It.isReal(t))).reduce(((t,[e,n])=>(t[e]=It.toJson(n),t)),[]);if(Ct.isReal(t)){const[e]=Object.keys(t.enc);if(t.type===rt.Null)return null;if(t.type===rt.Boolean)return"true"===e;if(t.type===rt.String)return e;throw new Error("Invalid type")}throw new Error("Value is surreal")};const Kt=t=>t.type===rt.Number;const kt=t=>t.type===rt.String;const Bt=t=>t.type===rt.Array;const Pt=t=>t.type===rt.Object;const At=t=>(t=>t.type===rt.Null)(t)||(t=>t.type===rt.Boolean)(t)||kt(t)||Bt(t)||Pt(t);var Rt;let Dt=Rt=class{};Dt.plus=t=>e=>It.add(t)(e),Dt.inverse=t=>It.scalarMult(-1)(t),Dt.minus=t=>e=>Rt.plus(t)(Rt.inverse(e)),Dt.zero=t=>It.zero(t),Dt.toJson=t=>It.toJson(t),Dt.fromJson=t=>new It(t),Dt=Rt=function(t,e,n,r){var o,i=arguments.length,s=i<3?e:null===r?r=Object.getOwnPropertyDescriptor(e,n):r;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,n,r);else for(var c=t.length-1;c>=0;c--)(o=t[c])&&(s=(i<3?o(s):i>3?o(e,n,s):o(e,n))||s);return i>3&&s&&Object.defineProperty(e,n,s),s}([t=>t],Dt);const Mt=t=>e=>n=>{if(void 0===e||void 0===n)throw new Error("projectTree: query or tree is undefined");if(e.type!==n.type)throw new Error("Type mismatch");if(Kt(n))return n;if(At(n)){const r=Object.entries(n.enc).map((([n,r])=>t.includes(n)?[n,r]:Object.keys(e.enc).includes(n)?[n,Mt(t)(e.enc[n])(r)]:[n,It.zero(r.type)])).filter((([,t])=>!It.isZero(t)));return{enc:Object.fromEntries(r),type:e.type}}throw new Error("Invalid query")};class Ut{constructor({db:t=new Tt}={}){this.db=t}read(t){return c(this,void 0,void 0,(function*(){const{txId:e}=J(t);const{outData:n}=yield this.db.fromTxId(e);const{exp:r,env:o,mod:i,root:s}=n[0];const{getVal:c}=yield this.getValAndTx(r,o,i,s);const u=c(e);var a;return(a=e=>e._rev&&e._rev===t,t=>wt(((t,e)=>a(e)?t.concat([e]):t))([])(t))(u)[0]}))}populateEnv(t){return c(this,void 0,void 0,(function*(){return Object.fromEntries(yield Promise.all(Object.entries(t).map((([t,e])=>c(this,void 0,void 0,(function*(){return[t,(n=e,"string"==typeof n&&H(n)?yield this.read(e):e)];var n}))))))}))}static evaluate(t,e={},n=""){return c(this,void 0,void 0,(function*(){const r=n?yield $t.import(n):{};return Object.getOwnPropertyNames(r).forEach((t=>{e[t]=r[t]})),new Compartment(e).evaluate(t)}))}getValAndTx(t,e={},n="",r){return c(this,void 0,void 0,(function*(){if(r&&!Object.keys(e).includes(r))throw new Error(`Root ${r} not found in env.`);const o=yield this.populateEnv(e);const i=yt(o);const s=yield Ut.evaluate(t,i,n);const u=o[r];const a=u&&!dt(d=u)&&!Array.isArray(d)&&d._id&&d._rev&&d._root?null==u?void 0:u._root:void 0;var d;const h={_rev:"frame1",env:Object.assign({_rev:"frame2"},o)};const l={_rev:"frame1",env:Object.assign({_rev:"frame2"},i)};void 0!==s&&(l.res=s);const p=Ut.updateWithRevImpure((()=>Math.random().toString()));mt(p)(l);const f=t=>ht(t)&&"_rev"in t?[t._rev]:[void 0];const v=pt(f)(l.env).filter((t=>void 0!==t));const g=pt(f)(l.res).filter((t=>void 0!==t));const b=t=>new Set(t).size!==t.length;if(b(v)||b(g))throw new Error("Cannot create a circular object");const{inputs:m,outputs:w}=(t=>e=>{const{inputs:n,outputs:r}=(t=>e=>{const n=(t=>e=>{const n=(t=>e=>{const n=Dt.fromJson(t);const r=Dt.fromJson(e);const o=Dt.minus(r)(n);return Mt(it)(o)(r)})(t)(e);const r=Dt.toJson(n);return pt(ft)(r)})(t)(e);return{inputs:n.map((t=>ht(t)&&"string"==typeof t._rev?t._rev:void 0)),outputs:n.map(vt(ot.concat("_rev")))}})(t)(e);const o=n.map(((t,e)=>void 0!==t?e:void 0)).filter((t=>void 0!==t));return{inputs:n.filter((t=>void 0!==t)),outputs:r,ioMap:o}})(h)(l);const y=m.filter(H);const x=w.filter((t=>"frame1"!==t._rev&&"frame2"!==t._rev));const O=Object.fromEntries(x.map(((t,e)=>[t._rev,e])));const _=y.map((t=>O[t]));const S=x.map(vt(ot));S[0]=Object.assign(Object.assign({},S[0]),{exp:t,env:e,mod:n,root:r});const j=(t=>e=>n=>r=>{if(!ht(r)||!r._rev||!Object.keys(e).includes(r._rev.toString()))return r;const o=`${n}/${e[r._rev].toString()}`;const i=r._id||o;const s=r._root||t||i;const c=Object.assign(Object.assign({},r),{_rev:o,_id:i,_root:s});const u=Object.create(Object.getPrototypeOf(r));return Object.assign(u,c)})(a)(O);return{sendTx:()=>c(this,void 0,void 0,(function*(){return this.db.update(y,S,_)})),getVal:t=>bt(j(t))(l),getTx:()=>c(this,void 0,void 0,(function*(){return this.db.getTx(y,S,_)})),ioMap:_}}))}}Ut.updateWithRevImpure=t=>e=>{ht(e)&&void 0===e._rev&&(e._rev=t())};class Ht{constructor({db:t=new Tt}={}){this.db=t,this.reader=new Ut({db:t}),this.modules=new $t({db:t}),Ht.proxyDepth=Ht.proxyDepth||0}write(t,e={},n="",r){return c(this,void 0,void 0,(function*(){const{sendTx:o,getVal:i}=yield this.reader.getValAndTx(t,e,n,r);const[s]=yield o();const{txId:c}=J(s);return i(c)}))}createTx(t,e={},n="",r){return c(this,void 0,void 0,(function*(){const{getTx:o}=yield this.reader.getValAndTx(t,e,n,r);return yield o()}))}}class Nt{constructor({db:t=new Tt}={}){this.writer=new Ht({db:t})}get(t,e){return"function"!=typeof t[e]?Reflect.get(t,e):(...n)=>c(this,void 0,void 0,(function*(){const{argString:r,env:o}=F(n);const i=`__bc__.${String(e)}(${r})`;const c=Object.assign(Object.assign({},o),{__bc__:t._rev});const{res:u,env:a}=yield this.writer.write(i,c,"","__bc__");const d=s(a,["_rev","_id","_root"]);return Object.entries(d).forEach((([e,r])=>{const o=parseInt(e.slice(4,-2),10);const i=Number.isNaN(o)?t:n[o];Object.entries(r).forEach((([t,e])=>{i[t]=e}))})),u}))}}const{bitcore:Lt}=t;const{crypto:Jt}=Lt;class Ft{constructor(t={}){if(void 0!==t.seed)throw new Error('The constructor parameter "seed" has been renamed to "mnemonic".');this.db=new Tt(t)}write(t,e,n){return c(this,void 0,void 0,(function*(){const r=new Ht({db:this.db});const{res:o}=yield r.write(t,e,n);const i=new Nt({db:this.db});return new Proxy(o,i)}))}read(t){return c(this,void 0,void 0,(function*(){const e=new Ut({db:this.db});const n=yield e.read(t);const r=new Nt({db:this.db});return new Proxy(n,r)}))}new(t,e,n=""){return c(this,void 0,void 0,(function*(){const{db:r}=this;const o=new Ht({db:r});const i=new Nt({db:r});const{argString:c,env:u}=F(e||[]);const a=`${t} new ${t.name}(${c})`;const{res:d,env:h}=yield o.write(a,u,n);const l=s(h,["_rev","_id","_root"]);return Object.values(l).forEach(((t,n)=>{const r=e[n];Object.entries(t).forEach((([t,e])=>{r[t]=e}))})),new Proxy(d,i)}))}getCreateTx(t,e,n=""){return c(this,void 0,void 0,(function*(){const{db:r}=this;const o=new Ht({db:r});const{argString:i,env:s}=F(e||[]);const c=`${t} new ${t.name}(${i})`;return yield o.createTx(c,s,n)}))}query(t){return c(this,void 0,void 0,(function*(){const{publicKey:e,contract:n,limit:r,offset:o,order:i}=t;let s={};if(e&&(s=Object.assign(Object.assign({},s),{publicKey:new Lt.PublicKey(e).toString()})),n){const t="string"==typeof n?n:n.toString();s=Object.assign(Object.assign({},s),{classHash:Jt.Hash.sha256(Buffer.from(t)).toString("hex")})}if("number"==typeof r||"number"==typeof o){if("number"==typeof r&&r<0)throw new Error("LIMIT must not be negative.");if("number"==typeof o&&o<0)throw new Error("OFFSET must not be negative.");void 0!==r&&(s=Object.assign(Object.assign({},s),{limit:r.toString()})),void 0!==o&&(s=Object.assign(Object.assign({},s),{offset:o.toString()})),s=Object.assign(Object.assign({},s),{order:i||"ASC"})}return this.db.wallet.restClient.query(s)}))}idsToRevs(t){return c(this,void 0,void 0,(function*(){return this.db.wallet.restClient.idsToRevs(t)}))}deploy(t){return c(this,void 0,void 0,(function*(){return new $t(this).deploy(t)}))}import(t,e){return c(this,void 0,void 0,(function*(){return(yield $t.import(e))[t]}))}getChain(){return this.db.wallet.restClient.chain}getNetwork(){return this.db.wallet.restClient.network}getMnemonic(){return this.db.wallet.restClient.mnemonic.toString()}getPrivateKey(){return this.db.wallet.privateKey.toString()}getPublicKey(){return this.db.wallet.publicKey.toString()}getAddress(){return this.db.wallet.address.toString()}sign(t){t.sign(this.getPrivateKey(),1)}getBalance(){return c(this,void 0,void 0,(function*(){return this.db.wallet.getBalance()}))}getUtxos(){return c(this,void 0,void 0,(function*(){const t=new Lt.Address(this.getAddress());return this.db.wallet.restClient.getUtxosByAddress(t)}))}broadcast(t){return c(this,void 0,void 0,(function*(){return this.db.wallet.restClient.sendTransaction(t.toObject())}))}queryRevs(t){return c(this,void 0,void 0,(function*(){return this.query(t)}))}getOwnedRevs(t=this.db.wallet.publicKey){return this.query({publicKey:t.toString()})}getRevs(t=this.db.wallet.publicKey){return c(this,void 0,void 0,(function*(){return this.query({publicKey:t.toString()})}))}getLatestRevs(t){return c(this,void 0,void 0,(function*(){return this.idsToRevs(t)}))}getLatestRev(t){return c(this,void 0,void 0,(function*(){const[e]=yield this.idsToRevs([t]);return e}))}rpcCall(t,e){return c(this,void 0,void 0,(function*(){const n=yield this.db.wallet.restClient.rpc(t,e);return n.result?n.result:{}}))}sync(t){return c(this,void 0,void 0,(function*(){return this.read(t)}))}}export{Ft as Computer};
