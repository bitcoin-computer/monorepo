import t from"@bitcoin-computer/bitcore-mnemonic-ltc";import e from"axios";import*as r from"crypto";import n from"crypto-js";import*as s from"eciesjs";import{StaticModuleRecord as o}from"@endo/static-module-record";import"ses";function i(t,e){var r={};for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&e.indexOf(n)<0&&(r[n]=t[n]);if(null!=t&&"function"==typeof Object.getOwnPropertySymbols){var s=0;for(n=Object.getOwnPropertySymbols(t);s<n.length;s++)e.indexOf(n[s])<0&&Object.prototype.propertyIsEnumerable.call(t,n[s])&&(r[n[s]]=t[n[s]])}return r}const c=process.env.CHAIN||"LTC";const a=process.env.NETWORK||"testnet";const u=process.env.BCN_URL||"https://node.bitcoincomputer.io";process.env.RPC_USER,process.env.RPC_PASSWORD,process.env.TEST_MNEMONICS;const h="LTC"===c?3e4:3e3;const p="LTC"===c?5820:582;const{crypto:l}=t.bitcore;const f=(t,e)=>{const r=Date.now();const n=l.Hash.sha256(Buffer.from(e+r));const s=[l.ECDSA.sign(n,t,"big").toString("hex"),t.publicKey.toString(),r];return`Bearer ${Buffer.from(s.join(":")).toString("base64")}`};class d{constructor(e=u,r=new t.bitcore.PrivateKey,n={}){this.baseUrl=e,this.headers=n,this.privateKey=r}async get(t){const r=this.privateKey?{Authentication:f(this.privateKey,this.baseUrl)}:{};return(await e.get(`${this.baseUrl}${t}`,{headers:Object.assign(Object.assign({},this.headers),r)})).data}async post(t,r){const n=this.privateKey?{Authentication:f(this.privateKey,this.baseUrl)}:{};return(await e.post(`${this.baseUrl}${t}`,r,{headers:Object.assign(Object.assign({},this.headers),n)})).data}async delete(t){const r=this.privateKey?{Authentication:f(this.privateKey,this.baseUrl)}:{};return(await e.delete(`${this.baseUrl}${t}`,{headers:Object.assign(Object.assign({},this.headers),r)})).data}}parseInt(process.env.BC_DEFAULT_FEE||"",10),parseInt(process.env.BC_SCRIPT_CHUNK_SIZE||"",10),parseInt(process.env.MWEB_HEIGHT||"",10);const{PublicKey:w,crypto:g,Script:y}=t.bitcore;const{Point:m}=g;function b(t){let e=t.toBuffer().length+9;return t.isWitnessProgram()?e+=67.75:e+=148,h*e/1e3}function v(t){return Buffer.from(t,"hex").toString().replace(/\0/g,"")}function O(t,e){return t.slice(e)+t.slice(0,e)}function _(t,e,r){if(t.length*Math.log2(e)>53)throw new Error(`Input too large ${t.length} ${Math.log2(e)}`);if(![2,10,16].includes(e)||![2,10,16].includes(r))throw new Error("ToBase or FromBase invalid in covertNumber.");if(2===e&&t.length%8!=0)throw new Error("Binary strings must be byte aligned.");if(16===e&&t.length%2!=0)throw new Error("Hex strings must be of even length.");const n=parseInt(t,e).toString(r);return 2===r?n.padStart(8*Math.ceil(n.length/8),"0"):16===r?n.padStart(2*Math.ceil(n.length/2),"0"):n}function x(t,e){const r=new RegExp(`.{1,${e}}`,"g");return t.match(r)||[]}function S(t){return x(t,2).map((t=>_(t,16,2))).join("")}function j(t){return x(t,8).map((t=>_(t,2,16))).join("")}function E(t){if(62!==t.length)throw new Error("Input to hexToPublicKey must be of length 62");let e=!1;let r=0;let n;for(;!e;){if(r>=256)throw new Error("Something went wrong storing data");const s=r.toString(16).padStart(2,"0")+j(O(S(t).padStart(64,"0"),r));try{n=m.fromX(!1,s),e=!0}catch(t){r+=1}}if(!n)throw new Error("Something went wrong storing data");return new w(n)}function C(t){const e=t.point.getX().toString("hex").padStart(64,"0");const r=_(e.slice(0,2),16,10);return j((s=parseInt(r,10),(n=S(e.slice(2))).slice(-s)+n.slice(0,-s)));var n,s}function $(t,e){const r={"any-testnet":"uTKUDCkpo12vstJBsMWmrTPz9wFE6DuzGH","BTC-mainnet":"igpnnoLziUyxtQuWYCP13gHYVhUru6iLaY","LTC-mainnet":"t77o829ngHnuUorwDkf129fL6ERLFNqKG8"};return O("testnet"===e||"regtest"===e?r["any-testnet"]:r[`${t}-${e}`],19)}function T(t=c,e=a){if("testnet"===e||"regtest"===e)return 1;if("BTC"===t)return 0;if("LTC"===t)return 2;if("DOGE"===t)return 3;if("BCH"===t)return 145;if("BSV"===t)return 236;throw new Error(`Unsupported chain ${t}`)}function I({chain:t=c,network:e=a}={}){return function({purpose:t=44,coinType:e=2,account:r=0}={}){return`m/${t.toString()}'/${e.toString()}'/${r.toString()}'`}({coinType:T(t,e)})}function k(t,e){return w.fromString(function(t,e){const r={"any-testnet":"be88416b08d0bfcc88102c4d9b558662f570dbd0676e6fa167552117933f133b8d","BTC-mainnet":"cd3a3ef0281ab2ce66a02ea770fbc2c41e46816ab821c9a91435958284b4aaef13","LTC-mainnet":"12d020c11112a2839d302548072bddbdfbcd39472a54b45a016456b8e30ea631aa"};return O("testnet"===e||"regtest"===e?r["any-testnet"]:r[`${t}-${e}`],19)}(t,e))}function K({mnemonic:e=new t,path:r=I(),passphrase:n="",network:s=a}){return e.toHDPrivateKey(n,s).deriveChild(r)}function B(t){return/^[0-9A-Fa-f]{64}\/\d+$/.test(t)}function P(t){if(!/^[0-9A-Fa-f]{64}$/.test(t))throw new Error(`Invalid txId: ${t}`)}function A(t){if(!/^[0-9A-Fa-f]{64}\/\d+$/.test(t))throw new Error(`Invalid outId: ${t}`)}function R(t){A(t);const[e,r]=t.split("/");return{txId:e,outputIndex:parseInt(r,10)}}const D=t=>{const e=[];const r={};let n=0;return t.forEach((t=>{"string"==typeof t?e.push(`'${t}'`):"number"==typeof t||"boolean"==typeof t?e.push(t):"object"==typeof t&&(t._rev?(e.push(`__bc${n}__`),r[`__bc${n}__`]=t._rev,n+=1):e.push(t))})),{argString:e.join(","),env:r}};function M(t){const e=t.match(/.{1,8}/g);const r=null==e?void 0:e.map((t=>parseInt(t,2)));return Buffer.from(new Uint8Array(r).buffer)}function U(t){return Array.from(t).map((t=>t.toString(2).padStart(8,"0"))).join("")}const{Transaction:N}=t.bitcore;const{UnspentOutput:H}=N;class L{constructor({chain:e,network:r,mnemonic:n,path:s,passphrase:o,url:i}={}){if(this.chain=e?e.toUpperCase():c,this.network=r?r.toLowerCase():a,this.mnemonic=new t(n?n.toString():void 0),this.path=s||I({chain:this.chain,network:this.network}),this.passphrase=o||"",this.bcn=new d(i,this.privateKey),!["LTC","BTC"].includes(this.chain))throw new Error("We currently only support LTC, support for other currencies will be added soon.");if(!["mainnet","testnet","regtest"].includes(this.network))throw new Error("Please set 'network' to 'regtest', 'testnet', or 'mainnet'")}get privateKey(){return K(this).privateKey}async getBalance(t){const{chain:e,network:r}=this;return await this.bcn.get(`/v1/${e}/${r}/address/${t}/balance`)}async getTransactions(t){return(await this.getRawTxs(t)).map((t=>new N(t)))}async getRawTxs(t){t.map(P);const{chain:e,network:r}=this;return this.bcn.post(`/v1/${e}/${r}/tx/bulk/`,{txIds:t})}async sendTransaction(t){return this.bcn.post(`/v1/${this.chain}/${this.network}/tx/send`,{txJSON:t})}async getUtxosByAddress(t){const{chain:e,network:r}=this;return(await this.bcn.get(`/v1/${e}/${r}/wallet/${t.toString()}/utxos`)).map((({rev:e,scriptPubKey:r,satoshis:n})=>{const[s,o]=e.split("/");return new H({address:t,txId:s,outputIndex:parseInt(o,10),satoshis:n,script:r})}))}async query(t){const{publicKey:e,classHash:r,limit:n,offset:s,order:o}=t;if(void 0===e&&void 0===r)throw new Error("Query parameters cannot be empty.");let i="";e&&(i+=`?publicKey=${e}`),r&&(i+=0===i.length?"?":"&",i+=`classHash=${r}`),void 0!==n&&(i+=`&limit=${n}`),void 0!==s&&(i+=`&offset=${s}`),o&&(i+=`&order=${o}`);const{chain:c,network:a}=this;return this.bcn.get(`/v1/${c}/${a}/non-standard-utxos${i}`)}async idsToRevs(t){t.map(A);const{chain:e,network:r}=this;return this.bcn.post(`/v1/${e}/${r}/revs`,{ids:t})}async rpc(t,e){return this.bcn.post(`/v1/${this.chain}/${this.network}/rpc`,{method:t,params:e})}static async getSecretOutput({_url:t,privateKey:e}){const r=t.split("/");const n=r[r.length-1];const s=r.slice(0,-2).join("/");const o=new d(s,e);return{host:s,data:await o.get(`/v1/store/${n}`)}}static async setSecretOutput({secretOutput:t,host:e,privateKey:r}){return new d(e,r).post("/v1/store/",t)}static async deleteSecretOutput({_url:t,privateKey:e}){const r=t.split("/");const n=r[r.length-1];const s=r.slice(0,-2).join("/");const o=new d(s,e);await o.delete(`/v1/store/${n}`)}get url(){return this.bcn.baseUrl}}const{PublicKey:J,Script:q}=t.bitcore;function F(t,e,r,n){if(t.length>3)throw new Error("Too many owners");return function(t,e,r,n){const s=n?[...t,k(e,r).toBuffer()]:t;const o=new q;return o.add("OP_1"),s.forEach((t=>{o.add(t)})),o.add(`OP_${s.length}`),o.add("OP_CHECKMULTISIG"),o}(t.map((t=>t.toBuffer())),e,r,n)}function W(t,e){return function(t,e){const r=t.chunks.filter((t=>t.buf));return(e?r.slice(0,-1):r).map((t=>t.buf))}(t,e).map((t=>J.fromBuffer(t)))}function z(t){return Buffer.from(n.SHA256(t).toString(),"hex").toString("hex").substr(0,4)}function V(t){return`${z(t)};${t}`}function Z(t){const e=t.substr(0,4);const r=t.substr(5);if(!function(t,e){return z(t)===e}(r,e))throw new Error("Decryption failure");return r}var G;!function(t){t.Array="Array",t.Boolean="boolean",t.Null="Null",t.Number="number",t.Object="Object",t.String="string",t.Undefined="undefined"}(G||(G={}));const Y=["_owners","_readers","_amount"];const Q=Y.concat(["_id","_rev","_root"]);const X=t=>(Object.prototype.toString.call(t).match(/\s([a-zA-Z]+)/)||[])[1];const tt=t=>"object"==typeof t?X(t):X(t).toLowerCase();const et=t=>tt(t)===G.Undefined;const rt=t=>tt(t)===G.Null;const nt=t=>tt(t)===G.Number;const st=t=>rt(t)||et(t)||nt(t)||(t=>tt(t)===G.String)(t)||(t=>tt(t)===G.Boolean)(t);const ot=t=>!st(t)&&!Array.isArray(t);const it=t=>!st(t)&&Array.isArray(t);const ct=t=>ot(t)?[ut((([t])=>Q.includes(t)))(t)]:[];const at=t=>e=>t.reduce(((t,r)=>(Object.keys(e).includes(r)&&(t[r]=e[r]),t)),{});const ut=t=>e=>Object.fromEntries(Object.entries(e).filter((e=>t(e))));const ht=t=>e=>{if(st(e))return e;if(it(e))return e.filter(ht(t));if(ot(e))return pt(ht(t))((r=t,t=>{const e=ut((([,t])=>r(t)));const n=Object.create(Object.getPrototypeOf(t));return Object.assign(n,e(t))})(e));var r;throw new Error("Unsupported type")};const pt=t=>e=>{const r=(n=([e,r])=>[e,t(r)],t=>Object.fromEntries(Object.entries(t).map(n)));var n;const s=Object.create(Object.getPrototypeOf(e));return Object.assign(s,r(e))};const lt=t=>e=>{if(st(e))return t(e);if(it(e))return t(e.map(lt(t)));if(ot(e))return t(pt(lt(t))(e));throw new Error("Unsupported type")};const ft=lt((t=>t));const dt=t=>{return e=([e,r])=>[e,t(r)],t=>{Object.entries(t).forEach(e)};var e};const wt=t=>e=>{if(st(e));else if(it(e))e.forEach(wt(t));else{if(!ot(e))throw new Error("Unsupported type");{t(e);const r=dt(wt(t))(e);const n=Object.create(Object.getPrototypeOf(e));Object.assign(n,r)}}};const gt=t=>e=>st(e)?t(e):it(e)?e.flatMap(gt(t)):ot(e)?[...t(e),...Object.values(e).flatMap(gt(t))]:[];const yt=t=>e=>r=>{if(st(r))return t(r);if(it(r))return e([r,...r.flatMap(yt(t)(e))]);if(ot(r))return e([r,...Object.values(r).flatMap(yt(t)(e))]);throw new Error("Unsupported type")};const mt=t=>e=>yt((t=>t))((e=>e.filter(t)))(e);function bt(t){if(void 0!==t._readers){const{_readers:e,_url:o,_owners:c,_amount:a}=t,u=i(t,["_readers","_url","_owners","_amount"]);const h=function(t,e){const o=r.randomBytes(32).toString("hex");const i=function(t,e){if(!/^[0-9a-f]{64}$/.test(e))throw new Error("Invalid secret");const r=Buffer.from(e,"hex").toString("binary");const s=V(t);return n.AES.encrypt(s,r).toString()}(t,o);const c=e.map((t=>function(t,e){if(!/^0[2-3][0-9a-f]{64}|04[0-9a-f]{128}$/.test(e))throw new Error("Invalid publicKey");const r=V(t);return s.encrypt(e,Buffer.from(r,"utf8")).toString("base64")}(o,t)));return{__cypher:i,__secrets:c}}(JSON.stringify(u),e);return void 0!==o&&(h._url=o),void 0!==c&&(h._owners=c),void 0!==a&&(h._amount=a),h}return t}const{Transaction:vt}=t.bitcore;const{Output:Ot,UnspentOutput:_t}=vt;class xt{constructor({restClient:t=new L}={}){this.tx=new vt,this.tx.feePerKb(1e4),this.outData=[],this.restClient=t}get txId(){return this.tx.id}get chain(){return this.restClient.chain}get network(){return this.restClient.network}get inputs(){return this.tx.inputs.map((t=>`${t.prevTxId.toString("hex")}/${t.outputIndex}`))}get encoding(){const{outputs:t}=this.tx;const e=t.filter((({script:t})=>null==t?void 0:t.isDataOut())).map((({script:t})=>t.getData()));const{ioDescriptor:r=[],ioMap:n=[],dataPrefix:s=""}=e.length?function(t){const e=t.subarray(0,6);const r=t.subarray(6);const n=U(e).match(/.{1,12}/g).map((t=>parseInt(t,2)));const s=n[3];const o=Math.ceil(s/8);return{ioDescriptor:n,ioMap:function(t){const e=t.split("").reverse().join("");const r=[];for(let t=0;t<e.length;t+=1)"1"===e[t]&&r.push(t);return r}(U(r.subarray(0,o))),dataPrefix:r.subarray(o).toString("utf8")}}(e[0]):{};return r.length&&r[0]>this.tx.inputs.length||r.length&&r[1]>this.tx.outputs.length||r.length&&r[2]>this.tx.outputs.length?{ioDescriptor:[],ioMap:[],dataPrefix:""}:{ioDescriptor:r,ioMap:n,dataPrefix:s}}get ioDescriptor(){return this.encoding.ioDescriptor}get dataPrefix(){return this.encoding.dataPrefix}get ioMap(){return this.encoding.ioMap}get inputsLength(){const[t=0]=this.ioDescriptor;return t}get outputsLength(){const[,t=0]=this.ioDescriptor;return t}get maxDataIndex(){const[,,t=-1]=this.ioDescriptor;return t}get ownerInputs(){return this.tx.inputs.slice(0,this.inputsLength)}get ownerOutputs(){return this.tx.outputs.slice(0,this.outputsLength)}get inRevs(){return this.ownerInputs.map((({prevTxId:t,outputIndex:e})=>`${t.toString("hex")}/${e}`))}get outRevs(){return this.ownerOutputs.map(((t,e)=>`${this.tx.id}/${e}`))}get zip(){return this.ownerOutputs.map(((t,e)=>[this.ioMap.indexOf(e)>=0?this.inRevs[this.ioMap.indexOf(e)]:null,this.outRevs[e]]))}isBcTx(){return this.tx.outputs.some((t=>t.script.toAddress(this.network).toString()===$(this.chain,this.network)))}getOwnerOutputs(){const[,t=0]=this.ioDescriptor;return this.tx.outputs.slice(0,t)}getDataOutputs(){const[,t,e]=this.ioDescriptor;return this.tx.outputs.slice(t,e)}async getOutData(){try{const t=this.getDataOutputs().map((t=>t.script)).map((t=>W(t,!0))).flat().map(C).map(v).join("");const{dataPrefix:e}=this;const r=JSON.parse(e+t);const o=this.restClient.privateKey.toBuffer().toString("hex");const c=this.getOwnerOutputs();if(c.length!==r.length)throw new Error("Inconsistent state");const a=c.map(((t,e)=>Object.assign(Object.assign({},r[e]),{_owners:W(t.script,!1).map((t=>t.toString())),_amount:t.satoshis})));return Promise.all(a.map((async t=>{try{return function(t,e){if(function(t){return ot(t)&&"__cypher"in t&&"__secrets"in t}(t)){const{__cypher:r,__secrets:o}=t,c=i(t,["__cypher","__secrets"]);return Object.assign(Object.assign(Object.assign({},c),JSON.parse(function({__cypher:t,__secrets:e},r){let o="";if(r.forEach((r=>{e.forEach((e=>{try{const i=function(t,e){if(!/^[0-9a-f]{64}$/.test(e))throw new Error("Invalid privateKey");return Z(s.decrypt(e,Buffer.from(t,"base64")).toString("utf8"))}(e,r);o=function(t,e){if(!/^[0-9a-f]{64}$/.test(e))throw new Error("Invalid secret");const r=Buffer.from(e,"hex").toString("binary");return Z(n.AES.decrypt(t,r).toString(n.enc.Utf8))}(t,i)}catch(t){if(t instanceof Error&&!["Decryption failure","Unsupported state or unable to authenticate data"].includes(t.message))throw t}}))})),o)return o;throw new Error("Decryption failure")}({__cypher:r,__secrets:o},e))),{_readers:[]})}return t}(await(e=this.restClient.privateKey,async t=>{if(function(t){return ot(t)&&"_url"in t}(t)){const{_url:r}=t,n=i(t,["_url"]);const{host:s,data:o}=await L.getSecretOutput({_url:r,privateKey:e});return Object.assign(Object.assign(Object.assign({},n),JSON.parse(o)),{_url:s})}return t})(t),[o])}catch(t){return null}var e})))}catch(t){return[]}}getOwners(){return this.getOwnerOutputs().map((t=>W(t.script,!1).map((t=>t.toString()))))}getAmounts(){return this.getOwnerOutputs().map((t=>t.satoshis))}async spendFromData(e){if(!e.length)return;const r=e.map(R);const n=r.map((t=>t.txId));const s=await this.restClient.getTransactions(n);for(let e=0;e<r.length;e+=1){const{txId:n,outputIndex:o}=r[e];const{outputs:i}=s[e];const c=i[o];const a=Math.round(c.satoshis);const u=new t.bitcore.Script(c.script);const h=new _t({txId:n,outputIndex:o,satoshis:a,script:u});const p=W(u,!1).map((t=>t.toString()));this.tx.from([h],p,1,{noSorting:!0})}}createDataOuts(e,r=[]){e.forEach((({_amount:e,_owners:r=[]})=>{if(Array.isArray(r)&&r.length>3)throw new Error("Too many owners.");const n=F(r.map((e=>t.bitcore.PublicKey.fromString(e))),this.chain,this.network,!1);const s=e||b(n);this.tx.addOutput(new Ot({script:n,satoshis:s}))}));const n=e.map((t=>i(t,["_amount","_owners"])));const{opReturnBuffer:s,dataScripts:o}=function(t,e,r,n,s,o){const i=function(t){const e=[];let r=0;let n;if(t.sort(((t,e)=>t-e))!==t)throw new Error("numbers must be in ascending order");for(let e=0;e<t.length;e+=1)if(t[e]===t[e+1])throw new Error("numbers must not contain duplicates");for(let s=0;r<t.length;s+=1)s===t[r]?(n="1",r+=1):n="0",e.unshift(n);return function(t,e){let r;if(t.length%2!=0){const e=t.length/2;r=2*Math.ceil(e)}return t.padStart(r,"0")}(e.join(""))}(n);const c=M(i.padStart(8*Math.ceil(i.length/8),"0"));const a=JSON.stringify(r);const u=80-(6+c.length);const h=a.slice(0,u);const p=function(t,e,r,n){var s;return function(t,e){const r=[];for(let e=0;e<t.length;e+=2)r.push(t.slice(e,e+2));return r}(x((s=t,Buffer.from(s).toString("hex")),62).map((t=>t.padStart(62,"0"))).map(E)).map((t=>F(t,e,r,!0)))}(a.slice(u),s,o);const l=M([t,e,e+p.length,i.length].map((t=>t.toString(2).padStart(12,"0"))).join(""));const f=Buffer.from(h);return{opReturnBuffer:Buffer.concat([l,c,f]),dataScripts:p}}(this.tx.inputs.length,this.tx.outputs.length,n,r,this.chain,this.network);o.forEach((t=>{const e=b(t);this.tx.addOutput(new Ot({script:t,satoshis:e}))})),this.tx.addData(s)}static getBcTx({hex:t="",restClient:e=new L}){const r=new this({restClient:e});return r.tx.fromString(t),r.outData=[],r}static async fromTxHex({hex:t="",restClient:e=new L}){let r=[];let n=[];let s=[];const o=new this({restClient:e});o.tx.fromString(t);try{r=await o.getOutData()}catch(t){}try{n=o.getOwners()}catch(t){}try{s=o.getAmounts()}catch(t){}return o.outData=r.map(((t,e)=>Object.assign(Object.assign({},t),{_owners:n[e],_amount:s[e]}))),o}static async fromTxId({txId:t="",restClient:e=new L}){const[r]=await e.getRawTxs([t]);return this.fromTxHex({hex:r,restClient:e})}}class St{constructor(t={}){this.restClient=new L(t)}derive(t="0"){const e=`${this.path}${this.path.length>0?"/":""}${t}`;const{chain:r,network:n,url:s,mnemonic:o,passphrase:i}=this.restClient;return new St({chain:r,network:n,url:s,mnemonic:o.toString(),path:e,passphrase:i})}async getBalance(){return this.restClient.getBalance(this.address)}async getUtxosByEffectiveValue(e){const r=await this.restClient.getUtxosByAddress(this.address);let n=0;const s=[];!function(t){const e=t;for(let t=e.length-1;t>0;t-=1){const r=Math.floor(Math.random()*(t+1));[e[t],e[r]]=[e[r],e[t]]}}(r);for(const o of r){const r=t.bitcore.Transaction.Input.fromObject(Object.assign(Object.assign({},o),{prevTxId:o.txId,satoshis:o.amount}))._estimateSize();if(o.satoshis-10*r>0&&(n+=o.satoshis-10*r,s.push(o)),n>=e)return s}const{network:o,chain:i}=this.restClient;const c=this.address.toString();throw new Error(`Insufficient balance in address ${c} on ${o} ${i}. Found ${n}, required ${e}.`)}async fundAndSendTx(e){e.tx.feePerKb(1e4);const{chain:r,network:n}=this.restClient;const s=Math.max(5e3,p);e.tx.to($(r,n),s);const o=e.tx._getInputAmount();const i=e.tx._getOutputAmount();const c=e.tx._estimateFee();const a=i-o+Math.round(c);return a>0&&(await this.getUtxosByEffectiveValue(a)).forEach((r=>{e.tx.from([new t.bitcore.Transaction.UnspentOutput(r)])})),e.tx.change(this.address.toString()),e.tx.sign(this.privateKey,1),this.restClient.sendTransaction(e.tx)}async send(t,e){const{restClient:r}=this;const n=new xt({restClient:r});return n.tx.to(e,t),this.fundAndSendTx(n)}get hdPrivateKey(){return K(this.restClient)}get privateKey(){return this.hdPrivateKey.privateKey}get publicKey(){return this.hdPrivateKey.publicKey}get passphrase(){return this.restClient.passphrase}get path(){return this.restClient.path}get chain(){return this.restClient.chain}get network(){return this.restClient.network}get url(){return this.restClient.url}get mnemonic(){return this.restClient.mnemonic}get address(){return this.publicKey.toAddress(this.restClient.network)}}class jt{constructor(t={}){this.wallet=new St(t)}async fromTxHex(t){const{restClient:e}=this.wallet;return xt.fromTxHex({hex:t,restClient:e})}async fromTxId(t){const[e]=await this.wallet.restClient.getRawTxs([t]);return this.fromTxHex(e)}async get(t){const e=t.map(R);return Promise.all(e.map((async({txId:t,outputIndex:e})=>{const{outData:r}=await this.fromTxId(t);if(e>r.length)throw new Error("Index out of bounds");return r[e]})))}put(t){return this.update([],t)}getBcTx(t){const{restClient:e}=this.wallet;return xt.getBcTx({hex:t,restClient:e})}async createTx(t,e,r=[]){const{wallet:n}=this;const{restClient:s}=n;const o=new xt({restClient:s});const{privateKey:c,publicKey:a}=n;const u=e.map((t=>{var{_owners:e}=t,r=i(t,["_owners"]);return Object.assign({_owners:e||[a.toString()]},r)}));const h=u.map(bt);const p=await Promise.all(h.map(function(t){return async e=>{if(void 0!==e._url){const{_url:r,_owners:n,_amount:s}=e,o=i(e,["_url","_owners","_amount"]);const c=await L.setSecretOutput({host:r,secretOutput:{data:JSON.stringify(o)},privateKey:t});return void 0!==n&&(c._owners=n),void 0!==s&&(c._amount=s),c}return e}}(c)));return await o.spendFromData(t),await o.createDataOuts(p,r),o}async update(t,e,r=[]){const n=await this.createTx(t,e,r);return await this.wallet.fundAndSendTx(n),n.outRevs}}const Et=new WeakSet;function Ct(t){Et.add(t)}let $t=!1;function Tt(t){const e=$t;try{return $t=!0,t()}finally{$t=e}}function It(){return $t}class kt{set(t,e,r){if("_id"===e&&!It())throw new Error("Cannot set _id");if("_rev"===e&&!It())throw new Error("Cannot set _rev");if("_root"===e&&!It())throw new Error("Cannot set _root");return Reflect.set(t,e,r)}}class Kt{constructor(){const t=new Proxy(this,new kt);return Ct(t),t}}class Bt{constructor({db:t=new jt}={}){this.db=t}async deploy(t){const[e]=await this.db.put([{mod:t}]);return e}static bitcoinResolveHook(t){return t}static async bitcoinImportHook(t){const[e]=await(new jt).get([t]);return new o(e.mod,t)}static nodeResolveHook(t="",e=""){if(void 0===t||void 0===e)throw new Error("!!! Invalid arguments");if(t.startsWith("/"))throw TypeError(`Module specifier ${t} must not begin with "/"`);if(!e.startsWith("./"))throw TypeError(`Module referrer ${e} must begin with "./"`);const r=[];const n=[];(t=>t.startsWith("./")||t.startsWith("../")||"."===t||".."===t)(t)&&(n.push(...e.split("/")),n.pop(),r.push(".")),n.push(...t.split("/"));for(const s of n)if("."===s||""===s);else if(".."===s){if(0===n.length)throw TypeError(`Module specifier ${t} via referrer ${e} must not traverse behind an empty path`);r.pop()}else r.push(s);return r.join("/")}static resolveHook(t,e){if(B(e)&&!B(t))throw new Error("Requiring a local file from a module on the blockchain is not supported.");return B(t)?Bt.bitcoinResolveHook(t):Bt.nodeResolveHook(t,e)}static makeImportHook(){return t=>{if(B(t))return Bt.bitcoinImportHook(t);throw new Error("Not a valid import")}}static getBitcoinCompartment(){const{resolveHook:t,makeImportHook:e}=Bt;return new Compartment({Contract:Kt},{},{resolveHook:t,importHook:e()})}static async import(t){const e=Bt.getBitcoinCompartment();const{namespace:r}=await e.import(t);return r}}var Pt;class At{constructor(t){this.enc=nt(t)?t:rt(t)?{null:new At(1)}:et(t)?{undefined:new At(1)}:it(t)?pt((t=>new At(t)))(Object.fromEntries(Object.entries(t))):ot(t)?pt((t=>new At(t)))(t):{[t.toString()]:new At(1)},this.type=tt(t)}}Pt=At,At.zero=t=>({type:t,enc:t===G.Number?0:{}}),At.isZero=t=>Rt(t)?0===t.enc:0===Object.keys(t.enc).length,At.isTopLevelReal=t=>{const e=Object.keys(t.enc);return[G.Array,G.Object,G.Number].includes(t.type)||1===e.length&&1===t.enc[e[0]].enc},At.scalarMult=t=>e=>{if(Rt(e))return{type:e.type,enc:Number(e.enc)*t};if(Ut(e))return{type:e.type,enc:pt(At.scalarMult(t))(e.enc)};throw new Error(`Cannot multiply ${t} with ${e}`)},At.add=t=>e=>{if(t.type!==e.type)throw new Error(`Cannot add two vectors of different types: ${t.type} and ${e.type}`);if(Rt(t)&&Rt(e))return{type:G.Number,enc:t.enc+e.enc};if(Ut(t)&&Ut(e)){const r=[...Object.keys(t.enc),...Object.keys(e.enc)].map((r=>{const n=t.enc[r]||At.zero(e.enc[r].type);const s=e.enc[r]||At.zero(t.enc[r].type);return[r,At.add(n)(s)]})).filter((([,t])=>!At.isZero(t)));return{type:t.type,enc:Object.fromEntries(r)}}throw new Error(`Cannot add ${JSON.stringify(t,null,2)} and ${JSON.stringify(e,null,2)}`)},At.toJson=t=>{if(!Pt.isTopLevelReal(t))throw new Error("Cannot convert surreal to JSON");if(Rt(t))return t.enc;if(Mt(t)){const e=Object.entries(t.enc);const r=Object.fromEntries(e);return pt(At.toJson)(r)}if(Dt(t))return Object.entries(t.enc).reduce(((t,[e,r])=>(t[e]=At.toJson(r),t)),[]);const[e]=Object.keys(t.enc);if(t.type===G.Null)return null;if(t.type!==G.Undefined){if(t.type===G.Boolean)return"true"===e;if(t.type===G.String)return e;throw new Error("Invalid type")}};const Rt=t=>t.type===G.Number;const Dt=t=>t.type===G.Array;const Mt=t=>t.type===G.Object;const Ut=t=>(t=>t.type===G.Null)(t)||(t=>t.type===G.Undefined)(t)||(t=>t.type===G.Boolean)(t)||(t=>t.type===G.String)(t)||Dt(t)||Mt(t);var Nt;let Ht=Nt=class{};Ht.plus=t=>e=>At.add(t)(e),Ht.minus=t=>e=>Nt.plus(t)(Nt.inverse(e)),Ht.inverse=t=>At.scalarMult(-1)(t),Ht.zero=t=>At.zero(t),Ht.toJson=t=>At.toJson(t),Ht.fromJson=t=>new At(t),Ht.eq=t=>e=>At.isZero(Nt.minus(t)(e)),Ht=Nt=function(t,e,r,n){var s,o=arguments.length,i=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,r,n);else for(var c=t.length-1;c>=0;c--)(s=t[c])&&(i=(o<3?s(i):o>3?s(e,r,i):s(e,r))||i);return o>3&&i&&Object.defineProperty(e,r,i),i}([t=>t],Ht);const Lt=t=>e=>r=>{if(void 0===e||void 0===r)throw new Error("projectTree: query or tree is undefined");if(e.type!==r.type)throw new Error("Type mismatch");if(Rt(r))return r;if(Ut(r)){const n=Object.entries(r.enc).map((([r,n])=>t.includes(r)?[r,n]:Object.keys(e.enc).includes(r)?[r,Lt(t)(e.enc[r])(n)]:[r,At.zero(n.type)])).filter((([,t])=>!At.isZero(t)));return{enc:Object.fromEntries(n),type:e.type}}throw new Error("Invalid query")};const Jt=gt((t=>ot(t)&&t._rev?[t._rev]:[]));function qt(t){return!st(t)&&mt((t=>{return ot(t)&&(e=t,!Et.has(e));var e}))(t).length>0}class Ft{constructor({db:t=new jt}={}){this.db=t}async read(t){const{txId:e}=R(t);const{outData:r}=await this.db.fromTxId(e);const{exp:n,env:s,mod:o,root:i}=r[0];const{getVal:c}=await this.getValAndTx(n,s,o,i);const a=c(e);return mt((e=>ot(e)&&e._rev&&e._rev===t))(a)[0]}async populateEnv(t){return Object.fromEntries(await Promise.all(Object.entries(t).map((async([t,e])=>{return[t,(r=e,"string"==typeof r&&B(r)?await this.read(e):e)];var r}))))}static async evaluate(t,e={},r=""){const n=r?await Bt.import(r):{};return new Compartment(Object.assign(Object.assign({Contract:Kt},e),n)).evaluate(t)}async getValAndTx(t,e={},r="",n){if(/super(\[|\.)/.test(t))throw new Error("Super is not supported allowed in smart contracts");if(n&&!Object.keys(e).includes(n))throw new Error(`Root ${n} not found in env.`);const s=await this.populateEnv(e);const o=ft(s);var i;i=s,wt(Ct)(i);const c=await Ft.evaluate(t,s,r);if(qt(c)||qt(s))throw new Error("Objects created inside smart contracts must inherit from Contract");const a=s[n];const u=a&&!st(h=a)&&!Array.isArray(h)&&h._id&&h._rev&&h._root?null==a?void 0:a._root:void 0;var h;const p=t=>({_rev:"frame1",env:Object.assign({_rev:"frame2"},t)});const l=p(o);const f=p(s);"object"==typeof c&&(f.res=c);const d=Ft.updateWithRevImpure((()=>Math.random().toString()));if(wt(d)(f),w=o,g=s,Ht.eq(Ht.fromJson(w))(Ht.fromJson(g))&&"object"!=typeof c)return{getVal:()=>({res:c,env:s})};var w,g;Ft.markRootsImpure(o);const y=t=>ot(t)&&"_rev"in t?[t._rev]:[void 0];const m=gt(y)(f.env).filter((t=>void 0!==t));const b=gt(y)(f.res).filter((t=>void 0!==t));const v=t=>new Set(t).size!==t.length;if(v(m)||v(b))throw new Error("Cannot create a circular object");const O=ft(f);const _=(t=>e=>{const r=Jt(t);if(void 0!==e&&!r.includes(e._rev))return ht((t=>!ot(t)||!r.includes(t._rev)))(e)})(s)(c);"object"==typeof c&&(O.res=_),void 0===_&&delete O.res;const{inputs:x,outputs:S}=(t=>e=>{const r=(t=>e=>{const r=(t=>e=>{const r=Ht.fromJson(t);const n=Ht.fromJson(e);const s=Ht.minus(n)(r);return Lt(Q)(s)(n)})(t)(e);const n=Ht.toJson(r);return gt(ct)(n)})(t)(e);return{inputs:r.map((t=>ot(t)&&"string"==typeof t._rev?t._rev:void 0)),outputs:r.map(at(Y.concat("_rev")))}})(l)(O);const j=x.filter(B);const E=S.filter((t=>"frame1"!==t._rev&&"frame2"!==t._rev));const C=Object.fromEntries(E.map(((t,e)=>[t._rev,e])));const $=j.map((t=>C[t]));const T=E.map(at(Y));T[0]=Object.assign(Object.assign({},T[0]),{exp:t,env:e,mod:r,root:n}),f.res=c;const I=(t=>e=>r=>n=>{ot(n)&&n._rev&&Object.keys(e).includes(n._rev.toString())&&Tt((()=>{n._rev=`${r}/${e[n._rev].toString()}`,n._id=n._id||n._rev,n._root=n._root||t||n._id}))})(u)(C);return{sendTx:async()=>this.db.update(j,T,$),getVal:t=>(wt(I(t))(f),f),ioMap:$}}}Ft.updateWithRevImpure=t=>e=>{ot(e)&&void 0===e._rev&&Tt((()=>{e._rev=t()}))},Ft.markRootsImpure=t=>{dt((t=>{ot(t)&&(t[Math.random()]=1)}))(t)};class Wt{constructor({db:t=new jt}={}){this.db=t,this.reader=new Ft({db:t}),this.modules=new Bt({db:t}),Wt.proxyDepth=Wt.proxyDepth||0}async write(t,e={},r="",n){const{sendTx:s,getVal:o}=await this.reader.getValAndTx(t,e,r,n);if(s){const[t]=await s();const{txId:e}=R(t);return o(e)}return o("")}}class zt{constructor({db:t=new jt}={}){this.writer=new Wt({db:t})}get(t,e){return"function"!=typeof t[e]?Reflect.get(t,e):async(...r)=>{const{argString:n,env:s}=D(r);const o=`__bc__.${String(e)}(${n})`;const c=Object.assign(Object.assign({},s),{__bc__:t._rev});const{res:a,env:u}=await this.writer.write(o,c,"","__bc__");const h=i(u,["_rev","_id","_root"]);return Object.entries(h).forEach((([e,n])=>{const s=parseInt(e.slice(4,-2),10);const o=Number.isNaN(s)?t:r[s];Object.entries(n).forEach((([t,e])=>{Tt((()=>{o[t]=e}))}))})),a}}}const{bitcore:Vt}=t;const{crypto:Zt}=Vt;const Gt=class{constructor(t={}){if(void 0!==t.seed)throw new Error('The constructor parameter "seed" has been renamed to "mnemonic".');this.db=new jt(t)}async write(t,e,r){const n=new Wt({db:this.db});const{res:s}=await n.write(t,e,r);const o=new zt({db:this.db});return new Proxy(s,o)}async read(t){const e=new Ft({db:this.db});const r=await e.read(t);const n=new zt({db:this.db});return new Proxy(r,n)}async new(t,e,r=""){const{db:n}=this;const s=new Wt({db:n});const o=new zt({db:n});const{argString:c,env:a}=D(e||[]);const u=`${t} new ${t.name}(${c})`;const{res:h,env:p}=await s.write(u,a,r);const l=i(p,["_rev","_id","_root"]);return Object.values(l).forEach(((t,r)=>{const n=e[r];Object.entries(t).forEach((([t,e])=>{Tt((()=>{n[t]=e}))}))})),new Proxy(h,o)}async query(t){const{publicKey:e,contract:r,limit:n,offset:s,order:o}=t;let i={};if(e&&(i=Object.assign(Object.assign({},i),{publicKey:new Vt.PublicKey(e).toString()})),r){const t="string"==typeof r?r:r.toString();i=Object.assign(Object.assign({},i),{classHash:Zt.Hash.sha256(Buffer.from(t)).toString("hex")})}if("number"==typeof n||"number"==typeof s){if("number"==typeof n&&n<0)throw new Error("LIMIT must not be negative.");if("number"==typeof s&&s<0)throw new Error("OFFSET must not be negative.");void 0!==n&&(i=Object.assign(Object.assign({},i),{limit:n.toString()})),void 0!==s&&(i=Object.assign(Object.assign({},i),{offset:s.toString()})),i=Object.assign(Object.assign({},i),{order:o||"ASC"})}return this.db.wallet.restClient.query(i)}async idsToRevs(t){return this.db.wallet.restClient.idsToRevs(t)}async deploy(t){return new Bt(this).deploy(t)}async import(t,e){return(await Bt.import(e))[t]}getChain(){return this.db.wallet.restClient.chain}getNetwork(){return this.db.wallet.restClient.network}getMnemonic(){return this.db.wallet.restClient.mnemonic.toString()}getPrivateKey(){return this.db.wallet.privateKey.toString()}getPublicKey(){return this.db.wallet.publicKey.toString()}getAddress(){return this.db.wallet.address.toString()}sign(t){t.sign(this.getPrivateKey(),1)}async getBalance(){return this.db.wallet.getBalance()}async getUtxos(){const t=new Vt.Address(this.getAddress());return this.db.wallet.restClient.getUtxosByAddress(t)}async broadcast(t){return this.db.wallet.restClient.sendTransaction(t)}async sendTx(t){return this.broadcast(t.toObject())}async queryRevs(t){return this.query(t)}getOwnedRevs(t=this.db.wallet.publicKey){return this.query({publicKey:t.toString()})}async getRevs(t=this.db.wallet.publicKey){return this.query({publicKey:t.toString()})}async getLatestRevs(t){return this.idsToRevs(t)}async getLatestRev(t){const[e]=await this.idsToRevs([t]);return e}async rpcCall(t,e){const r=await this.db.wallet.restClient.rpc(t,e);return r.result?r.result:{}}async sync(t){return this.read(t)}};export{Gt as Computer,Kt as Contract};
