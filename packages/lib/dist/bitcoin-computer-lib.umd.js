var t,e;t=this,e=function(t,e,r,n,s,o,i){"use strict";function a(t){return t&&"object"==typeof t&&"default"in t?t:{default:t}}function c(t){if(t&&t.__esModule)return t;var e=Object.create(null);return t&&Object.keys(t).forEach((function(r){if("default"!==r){var n=Object.getOwnPropertyDescriptor(t,r);Object.defineProperty(e,r,n.get?n:{enumerable:!0,get:function(){return t[r]}})}})),e.default=t,Object.freeze(e)}var u=a(e);var l=a(r);var p=c(n);var h=a(s);var f=c(o);function d(t,e){var r={};for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&e.indexOf(n)<0&&(r[n]=t[n]);if(null!=t&&"function"==typeof Object.getOwnPropertySymbols){var s=0;for(n=Object.getOwnPropertySymbols(t);s<n.length;s++)e.indexOf(n[s])<0&&Object.prototype.propertyIsEnumerable.call(t,n[s])&&(r[n[s]]=t[n[s]])}return r}const w=process.env.CHAIN||"LTC";const g=process.env.NETWORK||"testnet";const y=process.env.BCN_URL||"https://node.bitcoincomputer.io";process.env.RPC_USER,process.env.RPC_PASSWORD,process.env.TEST_MNEMONICS;const b="LTC"===w?3e4:3e3;const m="LTC"===w?5820:582;const{crypto:v}=u.default.bitcore;const O=(t,e)=>{const r=Date.now();const n=v.Hash.sha256(Buffer.from(e+r));const s=[v.ECDSA.sign(n,t,"big").toString("hex"),t.publicKey.toString(),r];return`Bearer ${Buffer.from(s.join(":")).toString("base64")}`};class _{constructor(t=y,e=new u.default.bitcore.PrivateKey,r={}){this.baseUrl=t,this.headers=r,this.privateKey=e}async get(t){const e=this.privateKey?{Authentication:O(this.privateKey,this.baseUrl)}:{};return(await l.default.get(`${this.baseUrl}${t}`,{headers:Object.assign(Object.assign({},this.headers),e)})).data}async post(t,e){const r=this.privateKey?{Authentication:O(this.privateKey,this.baseUrl)}:{};return(await l.default.post(`${this.baseUrl}${t}`,e,{headers:Object.assign(Object.assign({},this.headers),r)})).data}async delete(t){const e=this.privateKey?{Authentication:O(this.privateKey,this.baseUrl)}:{};return(await l.default.delete(`${this.baseUrl}${t}`,{headers:Object.assign(Object.assign({},this.headers),e)})).data}}parseInt(process.env.BC_DEFAULT_FEE||"",10),parseInt(process.env.BC_SCRIPT_CHUNK_SIZE||"",10),parseInt(process.env.MWEB_HEIGHT||"",10);const{PublicKey:x,crypto:S,Script:j}=u.default.bitcore;const{Point:E}=S;function C(t){let e=t.toBuffer().length+9;return t.isWitnessProgram()?e+=67.75:e+=148,b*e/1e3}function $(t){return Buffer.from(t,"hex").toString().replace(/\0/g,"")}function T(t,e){return t.slice(e)+t.slice(0,e)}function I(t,e,r){if(t.length*Math.log2(e)>53)throw new Error(`Input too large ${t.length} ${Math.log2(e)}`);if(![2,10,16].includes(e)||![2,10,16].includes(r))throw new Error("ToBase or FromBase invalid in covertNumber.");if(2===e&&t.length%8!=0)throw new Error("Binary strings must be byte aligned.");if(16===e&&t.length%2!=0)throw new Error("Hex strings must be of even length.");const n=parseInt(t,e).toString(r);return 2===r?n.padStart(8*Math.ceil(n.length/8),"0"):16===r?n.padStart(2*Math.ceil(n.length/2),"0"):n}function k(t,e){const r=new RegExp(`.{1,${e}}`,"g");return t.match(r)||[]}function K(t){return k(t,2).map((t=>I(t,16,2))).join("")}function B(t){return k(t,8).map((t=>I(t,2,16))).join("")}function P(t){if(62!==t.length)throw new Error("Input to hexToPublicKey must be of length 62");let e=!1;let r=0;let n;for(;!e;){if(r>=256)throw new Error("Something went wrong storing data");const s=r.toString(16).padStart(2,"0")+B(T(K(t).padStart(64,"0"),r));try{n=E.fromX(!1,s),e=!0}catch(t){r+=1}}if(!n)throw new Error("Something went wrong storing data");return new x(n)}function R(t){const e=t.point.getX().toString("hex").padStart(64,"0");const r=I(e.slice(0,2),16,10);return B((s=parseInt(r,10),(n=K(e.slice(2))).slice(-s)+n.slice(0,-s)));var n,s}function A(t,e){const r={"any-testnet":"uTKUDCkpo12vstJBsMWmrTPz9wFE6DuzGH","BTC-mainnet":"igpnnoLziUyxtQuWYCP13gHYVhUru6iLaY","LTC-mainnet":"t77o829ngHnuUorwDkf129fL6ERLFNqKG8"};return T("testnet"===e||"regtest"===e?r["any-testnet"]:r[`${t}-${e}`],19)}function M(t=w,e=g){if("testnet"===e||"regtest"===e)return 1;if("BTC"===t)return 0;if("LTC"===t)return 2;if("DOGE"===t)return 3;if("BCH"===t)return 145;if("BSV"===t)return 236;throw new Error(`Unsupported chain ${t}`)}function D({chain:t=w,network:e=g}={}){return function({purpose:t=44,coinType:e=2,account:r=0}={}){return`m/${t.toString()}'/${e.toString()}'/${r.toString()}'`}({coinType:M(t,e)})}function U(t,e){return x.fromString(function(t,e){const r={"any-testnet":"be88416b08d0bfcc88102c4d9b558662f570dbd0676e6fa167552117933f133b8d","BTC-mainnet":"cd3a3ef0281ab2ce66a02ea770fbc2c41e46816ab821c9a91435958284b4aaef13","LTC-mainnet":"12d020c11112a2839d302548072bddbdfbcd39472a54b45a016456b8e30ea631aa"};return T("testnet"===e||"regtest"===e?r["any-testnet"]:r[`${t}-${e}`],19)}(t,e))}function N({mnemonic:t=new u.default,path:e=D(),passphrase:r="",network:n=g}){return t.toHDPrivateKey(r,n).deriveChild(e)}function H(t){return/^[0-9A-Fa-f]{64}\/\d+$/.test(t)}function L(t){if(!/^[0-9A-Fa-f]{64}$/.test(t))throw new Error(`Invalid txId: ${t}`)}function J(t){if(!/^[0-9A-Fa-f]{64}\/\d+$/.test(t))throw new Error(`Invalid outId: ${t}`)}function q(t){J(t);const[e,r]=t.split("/");return{txId:e,outputIndex:parseInt(r,10)}}const z=t=>{const e=[];const r={};let n=0;return t.forEach((t=>{"string"==typeof t?e.push(`'${t}'`):"number"==typeof t||"boolean"==typeof t?e.push(t):"object"==typeof t&&(t._rev?(e.push(`__bc${n}__`),r[`__bc${n}__`]=t._rev,n+=1):e.push(t))})),{argString:e.join(","),env:r}};function F(t){const e=t.match(/.{1,8}/g);const r=null==e?void 0:e.map((t=>parseInt(t,2)));return Buffer.from(new Uint8Array(r).buffer)}function W(t){return Array.from(t).map((t=>t.toString(2).padStart(8,"0"))).join("")}const{Transaction:V}=u.default.bitcore;const{UnspentOutput:Z}=V;class G{constructor({chain:t,network:e,mnemonic:r,path:n,passphrase:s,url:o}={}){if(this.chain=t?t.toUpperCase():w,this.network=e?e.toLowerCase():g,this.mnemonic=new u.default(r?r.toString():void 0),this.path=n||D({chain:this.chain,network:this.network}),this.passphrase=s||"",this.bcn=new _(o,this.privateKey),!["LTC","BTC"].includes(this.chain))throw new Error("We currently only support LTC, support for other currencies will be added soon.");if(!["mainnet","testnet","regtest"].includes(this.network))throw new Error("Please set 'network' to 'regtest', 'testnet', or 'mainnet'")}get privateKey(){return N(this).privateKey}async getBalance(t){const{chain:e,network:r}=this;return await this.bcn.get(`/v1/${e}/${r}/address/${t}/balance`)}async getTransactions(t){return(await this.getRawTxs(t)).map((t=>new V(t)))}async getRawTxs(t){t.map(L);const{chain:e,network:r}=this;return this.bcn.post(`/v1/${e}/${r}/tx/bulk/`,{txIds:t})}async sendTransaction(t){return this.bcn.post(`/v1/${this.chain}/${this.network}/tx/send`,{txJSON:t})}async getUtxosByAddress(t){const{chain:e,network:r}=this;return(await this.bcn.get(`/v1/${e}/${r}/wallet/${t.toString()}/utxos`)).map((({rev:e,scriptPubKey:r,satoshis:n})=>{const[s,o]=e.split("/");return new Z({address:t,txId:s,outputIndex:parseInt(o,10),satoshis:n,script:r})}))}async query(t){const{publicKey:e,classHash:r,limit:n,offset:s,order:o}=t;if(void 0===e&&void 0===r)throw new Error("Query parameters cannot be empty.");let i="";e&&(i+=`?publicKey=${e}`),r&&(i+=0===i.length?"?":"&",i+=`classHash=${r}`),void 0!==n&&(i+=`&limit=${n}`),void 0!==s&&(i+=`&offset=${s}`),o&&(i+=`&order=${o}`);const{chain:a,network:c}=this;return this.bcn.get(`/v1/${a}/${c}/non-standard-utxos${i}`)}async idsToRevs(t){t.map(J);const{chain:e,network:r}=this;return this.bcn.post(`/v1/${e}/${r}/revs`,{ids:t})}async rpc(t,e){return this.bcn.post(`/v1/${this.chain}/${this.network}/rpc`,{method:t,params:e})}static async getSecretOutput({_url:t,privateKey:e}){const r=t.split("/");const n=r[r.length-1];const s=r.slice(0,-2).join("/");const o=new _(s,e);return{host:s,data:await o.get(`/v1/store/${n}`)}}static async setSecretOutput({secretOutput:t,host:e,privateKey:r}){return new _(e,r).post("/v1/store/",t)}static async deleteSecretOutput({_url:t,privateKey:e}){const r=t.split("/");const n=r[r.length-1];const s=r.slice(0,-2).join("/");const o=new _(s,e);await o.delete(`/v1/store/${n}`)}get url(){return this.bcn.baseUrl}}const{PublicKey:Y,Script:Q}=u.default.bitcore;function X(t,e,r,n){if(t.length>3)throw new Error("Too many owners");return function(t,e,r,n){const s=n?[...t,U(e,r).toBuffer()]:t;const o=new Q;return o.add("OP_1"),s.forEach((t=>{o.add(t)})),o.add(`OP_${s.length}`),o.add("OP_CHECKMULTISIG"),o}(t.map((t=>t.toBuffer())),e,r,n)}function tt(t,e){return function(t,e){const r=t.chunks.filter((t=>t.buf));return(e?r.slice(0,-1):r).map((t=>t.buf))}(t,e).map((t=>Y.fromBuffer(t)))}function et(t){return Buffer.from(h.default.SHA256(t).toString(),"hex").toString("hex").substr(0,4)}function rt(t){return`${et(t)};${t}`}function nt(t){const e=t.substr(0,4);const r=t.substr(5);if(!function(t,e){return et(t)===e}(r,e))throw new Error("Decryption failure");return r}var st;!function(t){t.Array="Array",t.Boolean="boolean",t.Null="Null",t.Number="number",t.Object="Object",t.String="string",t.Undefined="undefined"}(st||(st={}));const ot=["_owners","_readers","_amount"];const it=ot.concat(["_id","_rev","_root"]);const at=t=>(Object.prototype.toString.call(t).match(/\s([a-zA-Z]+)/)||[])[1];const ct=t=>"object"==typeof t?at(t):at(t).toLowerCase();const ut=t=>ct(t)===st.Undefined;const lt=t=>ct(t)===st.Null;const pt=t=>ct(t)===st.Number;const ht=t=>lt(t)||ut(t)||pt(t)||(t=>ct(t)===st.String)(t)||(t=>ct(t)===st.Boolean)(t);const ft=t=>!ht(t)&&!Array.isArray(t);const dt=t=>!ht(t)&&Array.isArray(t);const wt=t=>ft(t)?[yt((([t])=>it.includes(t)))(t)]:[];const gt=t=>e=>t.reduce(((t,r)=>(Object.keys(e).includes(r)&&(t[r]=e[r]),t)),{});const yt=t=>e=>Object.fromEntries(Object.entries(e).filter((e=>t(e))));const bt=t=>e=>{if(ht(e))return e;if(dt(e))return e.filter(bt(t));if(ft(e))return mt(bt(t))((r=t,t=>{const e=yt((([,t])=>r(t)));const n=Object.create(Object.getPrototypeOf(t));return Object.assign(n,e(t))})(e));var r;throw new Error("Unsupported type")};const mt=t=>e=>{const r=(n=([e,r])=>[e,t(r)],t=>Object.fromEntries(Object.entries(t).map(n)));var n;const s=Object.create(Object.getPrototypeOf(e));return Object.assign(s,r(e))};const vt=t=>e=>{if(ht(e))return t(e);if(dt(e))return t(e.map(vt(t)));if(ft(e))return t(mt(vt(t))(e));throw new Error("Unsupported type")};const Ot=vt((t=>t));const _t=t=>{return e=([e,r])=>[e,t(r)],t=>{Object.entries(t).forEach(e)};var e};const xt=t=>e=>{if(ht(e));else if(dt(e))e.forEach(xt(t));else{if(!ft(e))throw new Error("Unsupported type");{t(e);const r=_t(xt(t))(e);const n=Object.create(Object.getPrototypeOf(e));Object.assign(n,r)}}};const St=t=>e=>ht(e)?t(e):dt(e)?e.flatMap(St(t)):ft(e)?[...t(e),...Object.values(e).flatMap(St(t))]:[];const jt=t=>e=>r=>{if(ht(r))return t(r);if(dt(r))return e([r,...r.flatMap(jt(t)(e))]);if(ft(r))return e([r,...Object.values(r).flatMap(jt(t)(e))]);throw new Error("Unsupported type")};const Et=t=>e=>jt((t=>t))((e=>e.filter(t)))(e);function Ct(t){if(void 0!==t._readers){const{_readers:e,_url:r,_owners:n,_amount:s}=t,o=d(t,["_readers","_url","_owners","_amount"]);const i=function(t,e){const r=p.randomBytes(32).toString("hex");const n=function(t,e){if(!/^[0-9a-f]{64}$/.test(e))throw new Error("Invalid secret");const r=Buffer.from(e,"hex").toString("binary");const n=rt(t);return h.default.AES.encrypt(n,r).toString()}(t,r);const s=e.map((t=>function(t,e){if(!/^0[2-3][0-9a-f]{64}|04[0-9a-f]{128}$/.test(e))throw new Error("Invalid publicKey");const r=rt(t);return f.encrypt(e,Buffer.from(r,"utf8")).toString("base64")}(r,t)));return{__cypher:n,__secrets:s}}(JSON.stringify(o),e);return void 0!==r&&(i._url=r),void 0!==n&&(i._owners=n),void 0!==s&&(i._amount=s),i}return t}const{Transaction:$t}=u.default.bitcore;const{Output:Tt,UnspentOutput:It}=$t;class kt{constructor({restClient:t=new G}={}){this.tx=new $t,this.tx.feePerKb(1e4),this.outData=[],this.restClient=t}get txId(){return this.tx.id}get chain(){return this.restClient.chain}get network(){return this.restClient.network}get inputs(){return this.tx.inputs.map((t=>`${t.prevTxId.toString("hex")}/${t.outputIndex}`))}get encoding(){const{outputs:t}=this.tx;const e=t.filter((({script:t})=>null==t?void 0:t.isDataOut())).map((({script:t})=>t.getData()));const{ioDescriptor:r=[],ioMap:n=[],dataPrefix:s=""}=e.length?function(t){const e=t.subarray(0,6);const r=t.subarray(6);const n=W(e).match(/.{1,12}/g).map((t=>parseInt(t,2)));const s=n[3];const o=Math.ceil(s/8);return{ioDescriptor:n,ioMap:function(t){const e=t.split("").reverse().join("");const r=[];for(let t=0;t<e.length;t+=1)"1"===e[t]&&r.push(t);return r}(W(r.subarray(0,o))),dataPrefix:r.subarray(o).toString("utf8")}}(e[0]):{};return r.length&&r[0]>this.tx.inputs.length||r.length&&r[1]>this.tx.outputs.length||r.length&&r[2]>this.tx.outputs.length?{ioDescriptor:[],ioMap:[],dataPrefix:""}:{ioDescriptor:r,ioMap:n,dataPrefix:s}}get ioDescriptor(){return this.encoding.ioDescriptor}get dataPrefix(){return this.encoding.dataPrefix}get ioMap(){return this.encoding.ioMap}get inputsLength(){const[t=0]=this.ioDescriptor;return t}get outputsLength(){const[,t=0]=this.ioDescriptor;return t}get maxDataIndex(){const[,,t=-1]=this.ioDescriptor;return t}get ownerInputs(){return this.tx.inputs.slice(0,this.inputsLength)}get ownerOutputs(){return this.tx.outputs.slice(0,this.outputsLength)}get inRevs(){return this.ownerInputs.map((({prevTxId:t,outputIndex:e})=>`${t.toString("hex")}/${e}`))}get outRevs(){return this.ownerOutputs.map(((t,e)=>`${this.tx.id}/${e}`))}get zip(){return this.ownerOutputs.map(((t,e)=>[this.ioMap.indexOf(e)>=0?this.inRevs[this.ioMap.indexOf(e)]:null,this.outRevs[e]]))}isBcTx(){return this.tx.outputs.some((t=>t.script.toAddress(this.network).toString()===A(this.chain,this.network)))}getOwnerOutputs(){const[,t=0]=this.ioDescriptor;return this.tx.outputs.slice(0,t)}getDataOutputs(){const[,t,e]=this.ioDescriptor;return this.tx.outputs.slice(t,e)}async getOutData(){try{const t=this.getDataOutputs().map((t=>t.script)).map((t=>tt(t,!0))).flat().map(R).map($).join("");const{dataPrefix:e}=this;const r=JSON.parse(e+t);const n=this.restClient.privateKey.toBuffer().toString("hex");const s=this.getOwnerOutputs();if(s.length!==r.length)throw new Error("Inconsistent state");const o=s.map(((t,e)=>Object.assign(Object.assign({},r[e]),{_owners:tt(t.script,!1).map((t=>t.toString())),_amount:t.satoshis})));return Promise.all(o.map((async t=>{try{return function(t,e){if(function(t){return ft(t)&&"__cypher"in t&&"__secrets"in t}(t)){const{__cypher:r,__secrets:n}=t,s=d(t,["__cypher","__secrets"]);return Object.assign(Object.assign(Object.assign({},s),JSON.parse(function({__cypher:t,__secrets:e},r){let n="";if(r.forEach((r=>{e.forEach((e=>{try{const s=function(t,e){if(!/^[0-9a-f]{64}$/.test(e))throw new Error("Invalid privateKey");return nt(f.decrypt(e,Buffer.from(t,"base64")).toString("utf8"))}(e,r);n=function(t,e){if(!/^[0-9a-f]{64}$/.test(e))throw new Error("Invalid secret");const r=Buffer.from(e,"hex").toString("binary");return nt(h.default.AES.decrypt(t,r).toString(h.default.enc.Utf8))}(t,s)}catch(t){if(t instanceof Error&&!["Decryption failure","Unsupported state or unable to authenticate data"].includes(t.message))throw t}}))})),n)return n;throw new Error("Decryption failure")}({__cypher:r,__secrets:n},e))),{_readers:[]})}return t}(await(e=this.restClient.privateKey,async t=>{if(function(t){return ft(t)&&"_url"in t}(t)){const{_url:r}=t,n=d(t,["_url"]);const{host:s,data:o}=await G.getSecretOutput({_url:r,privateKey:e});return Object.assign(Object.assign(Object.assign({},n),JSON.parse(o)),{_url:s})}return t})(t),[n])}catch(t){return null}var e})))}catch(t){return[]}}getOwners(){return this.getOwnerOutputs().map((t=>tt(t.script,!1).map((t=>t.toString()))))}getAmounts(){return this.getOwnerOutputs().map((t=>t.satoshis))}async spendFromData(t){if(!t.length)return;const e=t.map(q);const r=e.map((t=>t.txId));const n=await this.restClient.getTransactions(r);for(let t=0;t<e.length;t+=1){const{txId:r,outputIndex:s}=e[t];const{outputs:o}=n[t];const i=o[s];const a=Math.round(i.satoshis);const c=new u.default.bitcore.Script(i.script);const l=new It({txId:r,outputIndex:s,satoshis:a,script:c});const p=tt(c,!1).map((t=>t.toString()));this.tx.from([l],p,1,{noSorting:!0})}}createDataOuts(t,e=[]){t.forEach((({_amount:t,_owners:e=[]})=>{if(Array.isArray(e)&&e.length>3)throw new Error("Too many owners.");const r=X(e.map((t=>u.default.bitcore.PublicKey.fromString(t))),this.chain,this.network,!1);const n=t||C(r);this.tx.addOutput(new Tt({script:r,satoshis:n}))}));const r=t.map((t=>d(t,["_amount","_owners"])));const{opReturnBuffer:n,dataScripts:s}=function(t,e,r,n,s,o){const i=function(t){const e=[];let r=0;let n;if(t.sort(((t,e)=>t-e))!==t)throw new Error("numbers must be in ascending order");for(let e=0;e<t.length;e+=1)if(t[e]===t[e+1])throw new Error("numbers must not contain duplicates");for(let s=0;r<t.length;s+=1)s===t[r]?(n="1",r+=1):n="0",e.unshift(n);return function(t,e){let r;if(t.length%2!=0){const e=t.length/2;r=2*Math.ceil(e)}return t.padStart(r,"0")}(e.join(""))}(n);const a=F(i.padStart(8*Math.ceil(i.length/8),"0"));const c=JSON.stringify(r);const u=80-(6+a.length);const l=c.slice(0,u);const p=function(t,e,r,n){var s;return function(t,e){const r=[];for(let e=0;e<t.length;e+=2)r.push(t.slice(e,e+2));return r}(k((s=t,Buffer.from(s).toString("hex")),62).map((t=>t.padStart(62,"0"))).map(P)).map((t=>X(t,e,r,!0)))}(c.slice(u),s,o);const h=F([t,e,e+p.length,i.length].map((t=>t.toString(2).padStart(12,"0"))).join(""));const f=Buffer.from(l);return{opReturnBuffer:Buffer.concat([h,a,f]),dataScripts:p}}(this.tx.inputs.length,this.tx.outputs.length,r,e,this.chain,this.network);s.forEach((t=>{const e=C(t);this.tx.addOutput(new Tt({script:t,satoshis:e}))})),this.tx.addData(n)}static getBcTx({hex:t="",restClient:e=new G}){const r=new this({restClient:e});return r.tx.fromString(t),r.outData=[],r}static async fromTxHex({hex:t="",restClient:e=new G}){let r=[];let n=[];let s=[];const o=new this({restClient:e});o.tx.fromString(t);try{r=await o.getOutData()}catch(t){}try{n=o.getOwners()}catch(t){}try{s=o.getAmounts()}catch(t){}return o.outData=r.map(((t,e)=>Object.assign(Object.assign({},t),{_owners:n[e],_amount:s[e]}))),o}static async fromTxId({txId:t="",restClient:e=new G}){const[r]=await e.getRawTxs([t]);return this.fromTxHex({hex:r,restClient:e})}}class Kt{constructor(t={}){this.restClient=new G(t)}derive(t="0"){const e=`${this.path}${this.path.length>0?"/":""}${t}`;const{chain:r,network:n,url:s,mnemonic:o,passphrase:i}=this.restClient;return new Kt({chain:r,network:n,url:s,mnemonic:o.toString(),path:e,passphrase:i})}async getBalance(){return this.restClient.getBalance(this.address)}async getUtxosByEffectiveValue(t){const e=await this.restClient.getUtxosByAddress(this.address);let r=0;const n=[];!function(t){const e=t;for(let t=e.length-1;t>0;t-=1){const r=Math.floor(Math.random()*(t+1));[e[t],e[r]]=[e[r],e[t]]}}(e);for(const s of e){const e=u.default.bitcore.Transaction.Input.fromObject(Object.assign(Object.assign({},s),{prevTxId:s.txId,satoshis:s.amount}))._estimateSize();if(s.satoshis-10*e>0&&(r+=s.satoshis-10*e,n.push(s)),r>=t)return n}const{network:s,chain:o}=this.restClient;const i=this.address.toString();throw new Error(`Insufficient balance in address ${i} on ${s} ${o}. Found ${r}, required ${t}.`)}async fundAndSendTx(t){t.tx.feePerKb(1e4);const{chain:e,network:r}=this.restClient;const n=Math.max(5e3,m);t.tx.to(A(e,r),n);const s=t.tx._getInputAmount();const o=t.tx._getOutputAmount();const i=t.tx._estimateFee();const a=o-s+Math.round(i);return a>0&&(await this.getUtxosByEffectiveValue(a)).forEach((e=>{t.tx.from([new u.default.bitcore.Transaction.UnspentOutput(e)])})),t.tx.change(this.address.toString()),t.tx.sign(this.privateKey,1),this.restClient.sendTransaction(t.tx)}async send(t,e){const{restClient:r}=this;const n=new kt({restClient:r});return n.tx.to(e,t),this.fundAndSendTx(n)}get hdPrivateKey(){return N(this.restClient)}get privateKey(){return this.hdPrivateKey.privateKey}get publicKey(){return this.hdPrivateKey.publicKey}get passphrase(){return this.restClient.passphrase}get path(){return this.restClient.path}get chain(){return this.restClient.chain}get network(){return this.restClient.network}get url(){return this.restClient.url}get mnemonic(){return this.restClient.mnemonic}get address(){return this.publicKey.toAddress(this.restClient.network)}}class Bt{constructor(t={}){this.wallet=new Kt(t)}async fromTxHex(t){const{restClient:e}=this.wallet;return kt.fromTxHex({hex:t,restClient:e})}async fromTxId(t){const[e]=await this.wallet.restClient.getRawTxs([t]);return this.fromTxHex(e)}async get(t){const e=t.map(q);return Promise.all(e.map((async({txId:t,outputIndex:e})=>{const{outData:r}=await this.fromTxId(t);if(e>r.length)throw new Error("Index out of bounds");return r[e]})))}put(t){return this.update([],t)}getBcTx(t){const{restClient:e}=this.wallet;return kt.getBcTx({hex:t,restClient:e})}async createTx(t,e,r=[]){const{wallet:n}=this;const{restClient:s}=n;const o=new kt({restClient:s});const{privateKey:i,publicKey:a}=n;const c=e.map((t=>{var{_owners:e}=t,r=d(t,["_owners"]);return Object.assign({_owners:e||[a.toString()]},r)}));const u=c.map(Ct);const l=await Promise.all(u.map(function(t){return async e=>{if(void 0!==e._url){const{_url:r,_owners:n,_amount:s}=e,o=d(e,["_url","_owners","_amount"]);const i=await G.setSecretOutput({host:r,secretOutput:{data:JSON.stringify(o)},privateKey:t});return void 0!==n&&(i._owners=n),void 0!==s&&(i._amount=s),i}return e}}(i)));return await o.spendFromData(t),await o.createDataOuts(l,r),o}async update(t,e,r=[]){const n=await this.createTx(t,e,r);return await this.wallet.fundAndSendTx(n),n.outRevs}}const Pt=new WeakSet;function Rt(t){Pt.add(t)}let At=!1;function Mt(t){const e=At;try{return At=!0,t()}finally{At=e}}function Dt(){return At}class Ut{set(t,e,r){if("_id"===e&&!Dt())throw new Error("Cannot set _id");if("_rev"===e&&!Dt())throw new Error("Cannot set _rev");if("_root"===e&&!Dt())throw new Error("Cannot set _root");return Reflect.set(t,e,r)}}class Nt{constructor(){const t=new Proxy(this,new Ut);return Rt(t),t}}class Ht{constructor({db:t=new Bt}={}){this.db=t}async deploy(t){const[e]=await this.db.put([{mod:t}]);return e}static bitcoinResolveHook(t){return t}static async bitcoinImportHook(t){const[e]=await(new Bt).get([t]);return new i.StaticModuleRecord(e.mod,t)}static nodeResolveHook(t="",e=""){if(void 0===t||void 0===e)throw new Error("!!! Invalid arguments");if(t.startsWith("/"))throw TypeError(`Module specifier ${t} must not begin with "/"`);if(!e.startsWith("./"))throw TypeError(`Module referrer ${e} must begin with "./"`);const r=[];const n=[];(t=>t.startsWith("./")||t.startsWith("../")||"."===t||".."===t)(t)&&(n.push(...e.split("/")),n.pop(),r.push(".")),n.push(...t.split("/"));for(const s of n)if("."===s||""===s);else if(".."===s){if(0===n.length)throw TypeError(`Module specifier ${t} via referrer ${e} must not traverse behind an empty path`);r.pop()}else r.push(s);return r.join("/")}static resolveHook(t,e){if(H(e)&&!H(t))throw new Error("Requiring a local file from a module on the blockchain is not supported.");return H(t)?Ht.bitcoinResolveHook(t):Ht.nodeResolveHook(t,e)}static makeImportHook(){return t=>{if(H(t))return Ht.bitcoinImportHook(t);throw new Error("Not a valid import")}}static getBitcoinCompartment(){const{resolveHook:t,makeImportHook:e}=Ht;return new Compartment({Contract:Nt},{},{resolveHook:t,importHook:e()})}static async import(t){const e=Ht.getBitcoinCompartment();const{namespace:r}=await e.import(t);return r}}var Lt;class Jt{constructor(t){this.enc=pt(t)?t:lt(t)?{null:new Jt(1)}:ut(t)?{undefined:new Jt(1)}:dt(t)?mt((t=>new Jt(t)))(Object.fromEntries(Object.entries(t))):ft(t)?mt((t=>new Jt(t)))(t):{[t.toString()]:new Jt(1)},this.type=ct(t)}}Lt=Jt,Jt.zero=t=>({type:t,enc:t===st.Number?0:{}}),Jt.isZero=t=>qt(t)?0===t.enc:0===Object.keys(t.enc).length,Jt.isTopLevelReal=t=>{const e=Object.keys(t.enc);return[st.Array,st.Object,st.Number].includes(t.type)||1===e.length&&1===t.enc[e[0]].enc},Jt.scalarMult=t=>e=>{if(qt(e))return{type:e.type,enc:Number(e.enc)*t};if(Wt(e))return{type:e.type,enc:mt(Jt.scalarMult(t))(e.enc)};throw new Error(`Cannot multiply ${t} with ${e}`)},Jt.add=t=>e=>{if(t.type!==e.type)throw new Error(`Cannot add two vectors of different types: ${t.type} and ${e.type}`);if(qt(t)&&qt(e))return{type:st.Number,enc:t.enc+e.enc};if(Wt(t)&&Wt(e)){const r=[...Object.keys(t.enc),...Object.keys(e.enc)].map((r=>{const n=t.enc[r]||Jt.zero(e.enc[r].type);const s=e.enc[r]||Jt.zero(t.enc[r].type);return[r,Jt.add(n)(s)]})).filter((([,t])=>!Jt.isZero(t)));return{type:t.type,enc:Object.fromEntries(r)}}throw new Error(`Cannot add ${JSON.stringify(t,null,2)} and ${JSON.stringify(e,null,2)}`)},Jt.toJson=t=>{if(!Lt.isTopLevelReal(t))throw new Error("Cannot convert surreal to JSON");if(qt(t))return t.enc;if(Ft(t)){const e=Object.entries(t.enc);const r=Object.fromEntries(e);return mt(Jt.toJson)(r)}if(zt(t))return Object.entries(t.enc).reduce(((t,[e,r])=>(t[e]=Jt.toJson(r),t)),[]);const[e]=Object.keys(t.enc);if(t.type===st.Null)return null;if(t.type!==st.Undefined){if(t.type===st.Boolean)return"true"===e;if(t.type===st.String)return e;throw new Error("Invalid type")}};const qt=t=>t.type===st.Number;const zt=t=>t.type===st.Array;const Ft=t=>t.type===st.Object;const Wt=t=>(t=>t.type===st.Null)(t)||(t=>t.type===st.Undefined)(t)||(t=>t.type===st.Boolean)(t)||(t=>t.type===st.String)(t)||zt(t)||Ft(t);var Vt;let Zt=Vt=class{};Zt.plus=t=>e=>Jt.add(t)(e),Zt.minus=t=>e=>Vt.plus(t)(Vt.inverse(e)),Zt.inverse=t=>Jt.scalarMult(-1)(t),Zt.zero=t=>Jt.zero(t),Zt.toJson=t=>Jt.toJson(t),Zt.fromJson=t=>new Jt(t),Zt.eq=t=>e=>Jt.isZero(Vt.minus(t)(e)),Zt=Vt=function(t,e,r,n){var s,o=arguments.length,i=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,r,n);else for(var a=t.length-1;a>=0;a--)(s=t[a])&&(i=(o<3?s(i):o>3?s(e,r,i):s(e,r))||i);return o>3&&i&&Object.defineProperty(e,r,i),i}([t=>t],Zt);const Gt=t=>e=>r=>{if(void 0===e||void 0===r)throw new Error("projectTree: query or tree is undefined");if(e.type!==r.type)throw new Error("Type mismatch");if(qt(r))return r;if(Wt(r)){const n=Object.entries(r.enc).map((([r,n])=>t.includes(r)?[r,n]:Object.keys(e.enc).includes(r)?[r,Gt(t)(e.enc[r])(n)]:[r,Jt.zero(n.type)])).filter((([,t])=>!Jt.isZero(t)));return{enc:Object.fromEntries(n),type:e.type}}throw new Error("Invalid query")};const Yt=St((t=>ft(t)&&t._rev?[t._rev]:[]));function Qt(t){return!ht(t)&&Et((t=>{return ft(t)&&(e=t,!Pt.has(e));var e}))(t).length>0}class Xt{constructor({db:t=new Bt}={}){this.db=t}async read(t){const{txId:e}=q(t);const{outData:r}=await this.db.fromTxId(e);const{exp:n,env:s,mod:o,root:i}=r[0];const{getVal:a}=await this.getValAndTx(n,s,o,i);const c=a(e);return Et((e=>ft(e)&&e._rev&&e._rev===t))(c)[0]}async populateEnv(t){return Object.fromEntries(await Promise.all(Object.entries(t).map((async([t,e])=>{return[t,(r=e,"string"==typeof r&&H(r)?await this.read(e):e)];var r}))))}static async evaluate(t,e={},r=""){const n=r?await Ht.import(r):{};return new Compartment(Object.assign(Object.assign({Contract:Nt},e),n)).evaluate(t)}async getValAndTx(t,e={},r="",n){if(/ super(\[|\.)/.test(t))throw new Error("Super is not allowed in smart contracts");if(n&&!Object.keys(e).includes(n))throw new Error(`Root ${n} not found in env.`);const s=await this.populateEnv(e);const o=Ot(s);var i;i=s,xt(Rt)(i);const a=await Xt.evaluate(t,s,r);if(Qt(a)||Qt(s))throw new Error("Objects created inside smart contracts must inherit from Contract");const c=s[n];const u=c&&!ht(l=c)&&!Array.isArray(l)&&l._id&&l._rev&&l._root?null==c?void 0:c._root:void 0;var l;const p=t=>({_rev:"frame1",env:Object.assign({_rev:"frame2"},t)});const h=p(o);const f=p(s);"object"==typeof a&&(f.res=a);const d=Xt.updateWithRevImpure((()=>Math.random().toString()));if(xt(d)(f),w=o,g=s,Zt.eq(Zt.fromJson(w))(Zt.fromJson(g))&&"object"!=typeof a)return{getVal:()=>({res:a,env:s})};var w,g;Xt.markRootsImpure(o);const y=t=>ft(t)&&"_rev"in t?[t._rev]:[void 0];const b=St(y)(f.env).filter((t=>void 0!==t));const m=St(y)(f.res).filter((t=>void 0!==t));const v=t=>new Set(t).size!==t.length;if(v(b)||v(m))throw new Error("Cannot create a circular object");const O=Ot(f);const _=(t=>e=>{const r=Yt(t);if(void 0!==e&&!r.includes(e._rev))return bt((t=>!ft(t)||!r.includes(t._rev)))(e)})(s)(a);"object"==typeof a&&(O.res=_),void 0===_&&delete O.res;const{inputs:x,outputs:S}=(t=>e=>{const r=(t=>e=>{const r=(t=>e=>{const r=Zt.fromJson(t);const n=Zt.fromJson(e);const s=Zt.minus(n)(r);return Gt(it)(s)(n)})(t)(e);const n=Zt.toJson(r);return St(wt)(n)})(t)(e);return{inputs:r.map((t=>ft(t)&&"string"==typeof t._rev?t._rev:void 0)),outputs:r.map(gt(ot.concat("_rev")))}})(h)(O);const j=x.filter(H);const E=S.filter((t=>"frame1"!==t._rev&&"frame2"!==t._rev));const C=Object.fromEntries(E.map(((t,e)=>[t._rev,e])));const $=j.map((t=>C[t]));const T=E.map(gt(ot));T[0]=Object.assign(Object.assign({},T[0]),{exp:t,env:e,mod:r,root:n}),f.res=a;const I=(t=>e=>r=>n=>{ft(n)&&n._rev&&Object.keys(e).includes(n._rev.toString())&&Mt((()=>{n._rev=`${r}/${e[n._rev].toString()}`,n._id=n._id||n._rev,n._root=n._root||t||n._id}))})(u)(C);return{sendTx:async()=>this.db.update(j,T,$),getVal:t=>(xt(I(t))(f),f),ioMap:$}}}Xt.updateWithRevImpure=t=>e=>{ft(e)&&void 0===e._rev&&Mt((()=>{e._rev=t()}))},Xt.markRootsImpure=t=>{_t((t=>{ft(t)&&(t[Math.random()]=1)}))(t)};class te{constructor({db:t=new Bt}={}){this.db=t,this.reader=new Xt({db:t}),this.modules=new Ht({db:t}),te.proxyDepth=te.proxyDepth||0}async write(t,e={},r="",n){const{sendTx:s,getVal:o}=await this.reader.getValAndTx(t,e,r,n);if(s){const[t]=await s();const{txId:e}=q(t);return o(e)}return o("")}}class ee{constructor({db:t=new Bt}={}){this.writer=new te({db:t})}get(t,e){return"function"!=typeof t[e]?Reflect.get(t,e):async(...r)=>{const{argString:n,env:s}=z(r);const o=`__bc__.${String(e)}(${n})`;const i=Object.assign(Object.assign({},s),{__bc__:t._rev});const{res:a,env:c}=await this.writer.write(o,i,"","__bc__");const u=d(c,["_rev","_id","_root"]);return Object.entries(u).forEach((([e,n])=>{const s=parseInt(e.slice(4,-2),10);const o=Number.isNaN(s)?t:r[s];Object.entries(n).forEach((([t,e])=>{Mt((()=>{o[t]=e}))}))})),a}}}const{bitcore:re}=u.default;const{crypto:ne}=re;t.Computer=class{constructor(t={}){if(void 0!==t.seed)throw new Error('The constructor parameter "seed" has been renamed to "mnemonic".');this.db=new Bt(t)}async write(t,e,r){const n=new te({db:this.db});const{res:s}=await n.write(t,e,r);const o=new ee({db:this.db});return new Proxy(s,o)}async read(t){const e=new Xt({db:this.db});const r=await e.read(t);const n=new ee({db:this.db});return new Proxy(r,n)}async new(t,e,r=""){const{db:n}=this;const s=new te({db:n});const o=new ee({db:n});const{argString:i,env:a}=z(e||[]);const c=`${t} new ${t.name}(${i})`;const{res:u,env:l}=await s.write(c,a,r);const p=d(l,["_rev","_id","_root"]);return Object.values(p).forEach(((t,r)=>{const n=e[r];Object.entries(t).forEach((([t,e])=>{Mt((()=>{n[t]=e}))}))})),new Proxy(u,o)}async query(t){const{publicKey:e,contract:r,limit:n,offset:s,order:o}=t;let i={};if(e&&(i=Object.assign(Object.assign({},i),{publicKey:new re.PublicKey(e).toString()})),r){const t="string"==typeof r?r:r.toString();i=Object.assign(Object.assign({},i),{classHash:ne.Hash.sha256(Buffer.from(t)).toString("hex")})}if("number"==typeof n||"number"==typeof s){if("number"==typeof n&&n<0)throw new Error("LIMIT must not be negative.");if("number"==typeof s&&s<0)throw new Error("OFFSET must not be negative.");void 0!==n&&(i=Object.assign(Object.assign({},i),{limit:n.toString()})),void 0!==s&&(i=Object.assign(Object.assign({},i),{offset:s.toString()})),i=Object.assign(Object.assign({},i),{order:o||"ASC"})}return this.db.wallet.restClient.query(i)}async idsToRevs(t){return this.db.wallet.restClient.idsToRevs(t)}async deploy(t){return new Ht(this).deploy(t)}async import(t,e){return(await Ht.import(e))[t]}getChain(){return this.db.wallet.restClient.chain}getNetwork(){return this.db.wallet.restClient.network}getMnemonic(){return this.db.wallet.restClient.mnemonic.toString()}getPrivateKey(){return this.db.wallet.privateKey.toString()}getPublicKey(){return this.db.wallet.publicKey.toString()}getAddress(){return this.db.wallet.address.toString()}sign(t){t.sign(this.getPrivateKey(),1)}async getBalance(){return this.db.wallet.getBalance()}async getUtxos(){const t=new re.Address(this.getAddress());return this.db.wallet.restClient.getUtxosByAddress(t)}async broadcast(t){return this.db.wallet.restClient.sendTransaction(t)}async sendTx(t){return this.broadcast(t.toObject())}async queryRevs(t){return this.query(t)}getOwnedRevs(t=this.db.wallet.publicKey){return this.query({publicKey:t.toString()})}async getRevs(t=this.db.wallet.publicKey){return this.query({publicKey:t.toString()})}async getLatestRevs(t){return this.idsToRevs(t)}async getLatestRev(t){const[e]=await this.idsToRevs([t]);return e}async rpcCall(t,e){const r=await this.db.wallet.restClient.rpc(t,e);return r.result?r.result:{}}async sync(t){return this.read(t)}},t.Contract=Nt,Object.defineProperty(t,"__esModule",{value:!0})},"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("@bitcoin-computer/bitcore-mnemonic-ltc"),require("axios"),require("crypto"),require("crypto-js"),require("eciesjs"),require("@endo/static-module-record"),require("ses")):"function"==typeof define&&define.amd?define(["exports","@bitcoin-computer/bitcore-mnemonic-ltc","axios","crypto","crypto-js","eciesjs","@endo/static-module-record","ses"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).computer={},t.Mnemonic,t.axios,t.crypto,t.CryptoJS,t.eciesjs,t.endoStaticModuleRecord);
