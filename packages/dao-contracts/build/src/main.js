import{Contract as e}from"@bitcoin-computer/lib";class t extends e{constructor({voteMod:e,description:t}){super({voteMod:e,description:t})}intersect(e,t){let o=new Set(e),r=new Set;for(let e of t)o.has(e)&&r.add(e);return Array.from(r)}async validVotes(e){let t=new Set(e.map(e=>e.split(":")[0])),o=new Set(t);for(let e of t){let r=new Set(await computer.db.wallet.restClient.getAncestors(e));r.delete(e),[...r].some(t.has,t)&&o.delete(e)}return Array.from(o)}async acceptingVotes(){let e=await computer.query({mod:this.voteMod}),t=await this.validVotes(e);return[...(await Promise.all(t.map(e=>computer.sync(e)))).map(e=>e.res)].filter(e=>"accept"===e.vote&&e.electionId===this._id).reduce((e,t)=>e+t.tokensAmount,0n)}}class o extends e{constructor({electionId:e,tokens:t,vote:o}){super({electionId:e,tokensAmount:t.reduce((e,t)=>e+t.amount,0n),vote:o})}}export{t as Election,o as Vote};