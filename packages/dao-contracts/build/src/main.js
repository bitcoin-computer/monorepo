import{Contract as t}from"@bitcoin-computer/lib";class e extends t{constructor({proposalMod:t,tokenRoot:e,description:o}){super({proposalMod:t,tokenRoot:e,description:o})}async proposalVotes(){let t=new Set((await computer.getTXOs({mod:this.proposalMod})).map(t=>t.split(":")[0])),e=new Set(t);for(let o of t){let r=new Set(await computer.db.wallet.restClient.getAncestors(o));r.delete(o),[...r].some(t.has,t)&&e.delete(o)}return Array.from(e)}async validVotes(){let t=await this.proposalVotes();return[...(await Promise.all(t.map(t=>computer.sync(t)))).map(t=>t.res)].filter(t=>t.electionId===this._id&&t.tokenRoot===this.tokenRoot)}async accepted(){return(await this.validVotes()).filter(t=>"accept"===t.vote).reduce((t,e)=>t+e.tokensAmount,0n)}async rejected(){return(await this.validVotes()).filter(t=>"reject"===t.vote).reduce((t,e)=>t+e.tokensAmount,0n)}}class o extends t{constructor({electionId:t,tokens:e,vote:o}){if(super({electionId:t,tokensAmount:e.reduce((t,e)=>t+e.amount,0n),vote:o,tokenRoot:e[0]._root}),new Set(e.map(t=>t._root)).size>1)throw Error("All tokens must have the same root")}}export{e as Election,o as Vote};