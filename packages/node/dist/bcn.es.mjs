import t from"body-parser";import e from"cors";import s from"express";import a from"http";import*as r from"zeromq";import n from"express-rate-limit";import*as o from"@bitcoin-computer/secp256k1";import{crypto as i,networks as c,bufferUtils as u,script as l,address as p,payments as d,Psbt as m,initEccLib as h}from"@bitcoin-computer/nakamotojs";import g from"dotenv";import y from"winston";import w from"winston-daily-rotate-file";import f from"pg-promise";import v from"pg-monitor";import{backOff as E}from"exponential-backoff";import $ from"fs";import{ECPairFactory as T}from"ecpair";import{Transaction as O,Computer as S}from"@bitcoin-computer/lib";import R from"bitcoind-rpc";import I from"util";import b from"elliptic";import x from"hash.js";import N,{dirname as B}from"path";import{fileURLToPath as M}from"url";g.config();const C=process.env.BCN_CHAIN;const H=process.env.BCN_NETWORK;const{BCN_PORT:k}=process.env;const{BCN_ZMQ_URL:A}=process.env;const{BCN_ALLOWED_RPC_METHODS:L}=process.env;const{BCN_DEBUG_MODE:P}=process.env;const{BCN_LOG_MAX_FILES:j}=process.env;const{BCN_LOG_MAX_SIZE:_}=process.env;const{BCN_LOG_ZIP:U}=process.env;const{BCN_SHOW_CONSOLE_LOGS:F}=process.env;const{BCN_SHOW_DB_LOGS:D}=process.env;const{BCN_RATE_LIMIT_ENABLED:W}=process.env;const{BCN_RATE_LIMIT_WINDOW:K}=process.env;const{BCN_RATE_LIMIT_MAX:Y}=process.env;const{BCN_RATE_LIMIT_STANDARD_HEADERS:G}=process.env;const{BCN_RATE_LIMIT_LEGACY_HEADERS:q}=process.env;process.env,process.env;const{BCN_OFFCHAIN_PROTOCOL:J}=process.env;const V=process.env.BCN_QUERY_LIMIT||"1000";const z=process.env.BCN_URL||`http://127.0.0.1:${k}`;const Z=process.env.BCN_ENV||"dev";const{BITCOIN_RPC_USER:X}=process.env;const{BITCOIN_RPC_PASSWORD:Q}=process.env;const{BITCOIN_RPC_HOST:tt}=process.env;const{BITCOIN_RPC_PORT:et}=process.env;const{BITCOIN_RPC_PROTOCOL:st}=process.env;const{BITCOIN_DEFAULT_WALLET:at}=process.env;const{POSTGRES_USER:rt}=process.env;const{POSTGRES_PASSWORD:nt}=process.env;const{POSTGRES_DB:ot}=process.env;const{POSTGRES_HOST:it}=process.env;const{POSTGRES_PORT:ct}=process.env;y.addColors({error:"red",warn:"yellow",info:"green",http:"magenta",debug:"white"});const ut=y.format.combine(y.format.colorize(),y.format.timestamp({format:"YYYY-MM-DD HH:mm:ss:ms"}),y.format.json(),y.format.printf((t=>`${t.timestamp} [${t.level.slice(5).slice(0,-5)}] ${t.message}`)));const lt={zippedArchive:"true"===U,maxSize:_,maxFiles:j,dirname:"logs"};const pt=[];"true"===F&&pt.push(new y.transports.Console({format:y.format.combine(y.format.colorize(),y.format.timestamp({format:"MM-DD-YYYY HH:mm:ss"}),y.format.printf((t=>`${t.timestamp} ${t.level} ${t.message}`)))}));const dt=parseInt(P,10);dt>=0&&pt.push(new w({filename:"error-%DATE%.log",datePattern:"YYYY-MM-DD",level:"error",...lt})),dt>=1&&pt.push(new w({filename:"warn-%DATE%.log",datePattern:"YYYY-MM-DD",level:"warn",...lt})),dt>=2&&pt.push(new w({filename:"info-%DATE%.log",datePattern:"YYYY-MM-DD",level:"info",...lt})),dt>=3&&pt.push(new w({filename:"http-%DATE%.log",datePattern:"YYYY-MM-DD",level:"http",...lt})),dt>=4&&pt.push(new w({filename:"debug-%DATE%.log",datePattern:"YYYY-MM-DD",level:"debug",...lt}));const mt=y.createLogger({levels:{error:0,warn:1,info:2,http:3,debug:4},format:ut,transports:pt,exceptionHandlers:[new y.transports.File({filename:"logs/exceptions.log"})],rejectionHandlers:[new y.transports.File({filename:"logs/rejections.log"})]});g.config();const{version:ht}=JSON.parse($.readFileSync("package.json","utf8"));const gt=ht||process.env.BCN_SERVER_VERSION;const yt=parseInt(process.env.MWEB_HEIGHT||"",10)||432;const wt={error:(t,e)=>{if(e.cn){const{host:s,port:a,database:r,user:n,password:o}=e.cn;mt.debug(`Waiting for db to start { message:${t.message} host:${s}, port:${a}, database:${r}, user:${n}, password: ${o}`)}},noWarnings:!0};"true"===D&&(v.isAttached()?v.detach():(v.attach(wt),v.setTheme("matrix")));const ft=f(wt)({host:it,port:parseInt(ct,10),database:ot,user:rt,password:nt,allowExitOnIdle:!0,idleTimeoutMillis:100});const{PreparedStatement:vt}=f;class Et{static async select(t){const e=new vt({name:`OffChain.select.${Math.random()}`,text:'SELECT "data" FROM "OffChain" WHERE "id" = $1',values:[t]});return ft.oneOrNone(e)}static async insert({id:t,data:e}){const s=new vt({name:`OffChain.insert.${Math.random()}`,text:'INSERT INTO "OffChain" ("id", "data") VALUES ($1, $2) ON CONFLICT DO NOTHING',values:[t,e]});return ft.none(s)}static async delete(t){const e=new vt({name:`OffChain.delete.${Math.random()}`,text:'WITH deleted AS (DELETE FROM "OffChain" WHERE "id" = $1 RETURNING *) SELECT count(*) FROM deleted;',values:[t]});return(await ft.any(e))[0].count>0}}class $t{static async select(t){const e=await Et.select(t);return e?.data||null}static async insert(t){return Et.insert(t)}static async delete(t){return Et.delete(t)}}const Tt=s.Router();Tt.get("/:id",(async({params:{id:t},url:e},s)=>{try{const e=await $t.select(t);e?s.status(200).json(e):s.status(403).json({error:"No entry found."})}catch(t){mt.error(`GET ${e} failed with error '${t.message}'`),s.status(500).json({error:t.message})}})),Tt.post("/",(async(t,e)=>{const{body:{data:s},url:a}=t;try{const a=i.sha256(Buffer.from(s)).toString("hex");await $t.insert({id:a,data:s});const r=`${J||t.protocol}://${t.get("host")}/store/${a}`;e.status(201).json({_url:r})}catch(t){mt.error(`POST ${a} failed with error '${t.message}'`),e.status(500).json({error:t.message})}})),Tt.delete("/:id",(async(t,e)=>{e.status(500).json({error:"Deletions are not supported yet."})}));const{PreparedStatement:Ot}=f;class St{static async getBalance(t){const e=new Ot({name:`Utxos.getBalance.${Math.random()}`,text:'SELECT sum("satoshis") as "satoshis" FROM "Utxos" WHERE "address" = $1 and "blockHash" is not null',values:[t]});const s=await ft.oneOrNone(e);const a=new Ot({name:`Utxos.getBalance.${Math.random()}`,text:'SELECT sum("satoshis") as "satoshis" FROM "Utxos" WHERE "address" = $1 and "blockHash" is null',values:[t]});const r=await ft.oneOrNone(a);return{confirmed:parseInt(s.satoshis,10)||0,unconfirmed:parseInt(r.satoshis,10)||0,balance:(parseInt(s.satoshis,10)||0)+(parseInt(r.satoshis,10)||0)}}static async select(t){const e=new Ot({name:`Utxos.select.${Math.random()}`,text:'SELECT "address", "satoshis", "asm", "rev", split_part(rev, \':\', 1) AS "txId", cast(split_part(rev, \':\', 2) as INTEGER) AS "vout" FROM "Utxos" WHERE "address" = $1',values:[t]});return(await ft.any(e)).map((t=>({...t,satoshis:parseInt(t.satoshis,10)||0})))}static async selectByScriptASM(t){const e=new Ot({name:`Utxos.select.${Math.random()}`,text:'SELECT "address", "satoshis", "asm", "rev", split_part(rev, \':\', 1) AS "txId", cast(split_part(rev, \':\', 2) as INTEGER) AS "vout" FROM "Utxos" WHERE "asm" = $1',values:[t]});return(await ft.any(e)).map((t=>({...t,satoshis:parseInt(t.satoshis,10)||0})))}static async selectByPk(t){const e=new Ot({name:`Utxos.selectByPk.${Math.random()}`,text:`SELECT "address", "satoshis", "asm", "rev", split_part(rev, ':', 1) AS "txId", cast(split_part(rev, ':', 2) as INTEGER) AS "vout" FROM "Utxos" WHERE "asm" LIKE '%${t}%'`});return(await ft.any(e)).map((t=>({...t,satoshis:parseInt(t.satoshis,10)})))}}class Rt{static async getBalance(t){return St.getBalance(t)}static async select(t){return St.select(t)}static async selectByPk(t){return St.selectByPk(t)}static async selectByScriptASM(t){return St.selectByScriptASM(t)}}class It{static getBalance=async t=>Rt.getBalance(t);static selectByAddress=async t=>Rt.select(t);static selectByPk=async t=>Rt.selectByPk(t);static selectByScriptASM=async t=>Rt.selectByScriptASM(t)}const bt={protocol:st,user:X,pass:Q,host:tt,port:parseInt(et,10)};const xt=new R(bt);const Nt=I.promisify(R.prototype.createwallet.bind(xt));const Bt=I.promisify(R.prototype.generateToAddress.bind(xt));const Mt=I.promisify(R.prototype.getaddressinfo.bind(xt));const Ct=I.promisify(R.prototype.getBlock.bind(xt));const Ht=I.promisify(R.prototype.getBlockchainInfo.bind(xt));const kt=I.promisify(R.prototype.getBlockHash.bind(xt));const At=I.promisify(R.prototype.getRawTransaction.bind(xt));const Lt=I.promisify(R.prototype.getRawTransaction.bind(xt));const Pt=I.promisify(R.prototype.getTransaction.bind(xt));const jt=I.promisify(R.prototype.getNewAddress.bind(xt));const _t={createwallet:Nt,generateToAddress:Bt,getaddressinfo:Mt,getBlock:Ct,getBlockchainInfo:Ht,getBlockHash:kt,getRawTransaction:At,getTransaction:Pt,importaddress:I.promisify(R.prototype.importaddress.bind(xt)),invalidateBlock:I.promisify(R.prototype.invalidateBlock.bind(xt)),listunspent:I.promisify(R.prototype.listunspent.bind(xt)),sendRawTransaction:I.promisify(R.prototype.sendRawTransaction.bind(xt)),getNewAddress:jt,sendToAddress:I.promisify(R.prototype.sendToAddress.bind(xt)),getRawTransactionJSON:Lt};const Ut=(t,e)=>{const s=[];for(let a=0;a<t.length;a+=e){const r=Math.min(a+e,t.length);const n=t.slice(a,r);s.push(n)}return s};const Ft=t=>{const e=[];for(let s=1;s<=t;s+=3){const t=`($${s},$${s+1},$${s+2})`;e.push(t)}return e.join(",")};const Dt=t=>{const e=[];for(let s=1;s<=t;s+=9){const t=`($${s},$${s+1},$${s+2},$${s+3},$${s+4},$${s+5},$${s+6},$${s+7},$${s+8})`;e.push(t)}return e.join(",")};const Wt=t=>{try{return t()}catch{return null}};class Kt{static async getTransaction(t){const{result:e}=await _t.getTransaction(t);return e}static async getBulkTransactions(t){return(await Promise.all(t.map((t=>_t.getRawTransaction(t,0))))).map((t=>t.result))}static async getRawTransaction(t,e){const{result:s}=await _t.getRawTransaction(t,e);return s}static async getRawTransactionsJSON(t){return{txId:(e=(await _t.getRawTransactionJSON(t,1)).result).txid,txHex:e.hex,vsize:e.vsize,version:e.version,locktime:e.locktime,ins:e.vin.map((t=>t.coinbase?{coinbase:t.coinbase,sequence:t.sequence}:{txId:t.txid,vout:t.vout,script:t.scriptSig.hex,sequence:t.sequence})),outs:e.vout.map((t=>{let e;return t.scriptPubKey.addresses?[e]=t.scriptPubKey.addresses:e=t.scriptPubKey.address?t.scriptPubKey.address:void 0,{address:e,script:t.scriptPubKey.hex,value:Math.round(1e8*t.value)}}))};var e}static async sendRawTransaction(t){const{result:e,error:s}=await _t.sendRawTransaction(t);if(s)throw mt.error(s),new Error("Error sending transaction");return e}static getUtxos=async t=>(void 0===(await _t.getaddressinfo(t)).result.timestamp&&(mt.info(`Importing address: ${t}`),await _t.importaddress(t,!1)),(await _t.listunspent(0,999999,[t])).result);static waitForRpcBlockHash=async(t,e)=>(await E((async()=>{let s;try{s=await _t.getBlockHash(t)}catch(s){throw mt.info(`[wid ${e} pid: ${process.pid}]: waiting for RPC to get block ${t} ...`),s}return s}),{startingDelay:1e4,timeMultiple:1,numOfAttempts:720})).result;static getBlock=async(t,e)=>_t.getBlock(t,e);static walletSetup=async()=>{if("regtest"===H){if(mt.info(`Node is starting for chain ${C} and network ${H}, \n\n. Starting Wallet setup.`),"LTC"===C){const{result:t}=await _t.getBlockchainInfo();const e=t.blocks;if(e<yt){const{result:t}=await _t.getNewAddress("","legacy");const s=yt-e-1;s&&await _t.generateToAddress(s,t);const{result:a}=await _t.getNewAddress("mweb","mweb");await _t.sendToAddress(a,1),await _t.generateToAddress(1,t),mt.info("MWEB setup is complete")}}if("BTC"===C){const{result:t}=await _t.getNewAddress("","legacy");await _t.generateToAddress(200,t),mt.info("Wallet setup is complete")}if("PEPE"===C){const{result:t}=await _t.getNewAddress("");await _t.generateToAddress(200,t),mt.info("Wallet setup is complete")}}};static createWallet=async()=>{try{await _t.createwallet(at,!1,!1,"",!1,!1)}catch(t){if(t.message.includes("already exists"))return void mt.info(`Wallet ${at} already exists`);mt.error(`Wallet creation failed with error '${t.message}'`)}};static checkBlockchainProgress=async()=>{const t=await E((async()=>{const t=await _t.getBlockchainInfo();const e=(100*parseFloat(t.result.verificationprogress)).toFixed(4);const{blocks:s}=t.result;if(mt.info(`Zmq. Bitcoind { percentage:${e}%, blocks:${s} }`),parseFloat(t.result.verificationprogress)<=.7)throw new Error("Node not ready yet");return t}),{startingDelay:6e4,timeMultiple:1,numOfAttempts:8760});const e=(100*parseFloat(t.result.verificationprogress)).toFixed(4);const s=t.result.blocks;mt.info(`BCN reaches sync end...at { bitcoind.progress:${e}%, bitcoindSyncedHeight:${s} }`)}}const{PreparedStatement:Yt}=f;class Gt{static async select(t){const e=new Yt({name:`Input.select.${Math.random()}`,text:'SELECT "outputSpent", "spendingInput", "blockHash" FROM "Input" WHERE "outputSpent" = $1',values:[t]});return ft.any(e)}static async insert(t){await Promise.all(Ut(t,3333).map((t=>{const e=t.flatMap((({outputSpent:t,spendingInput:e,blockHash:s})=>[t,e,s]));return ft.none(new Yt({name:`Input.insert.${Math.random()}`,text:`INSERT INTO "Input"("outputSpent", "spendingInput", "blockHash") VALUES ${Ft(e.length)} ON CONFLICT DO NOTHING`,values:e}))})))}static async updateBlockHash(t,e){await Promise.all(Ut(t,1e4).map((t=>{const s=t.join("','");return ft.none(new Yt({name:`Input.updateBlockHash.${Math.random()}`,text:`UPDATE "Input" SET "blockHash" = $1 WHERE "spendingInput" IN ('${s}')`,values:[e]}))})))}static async eraseBlockHash(t){await Promise.all(Ut(t,1e4).map((t=>{const e=t.join("','");return ft.none(new Yt({name:`Input.eraseBlockHash.${Math.random()}`,text:`UPDATE "Input" SET "blockHash" = NULL WHERE "blockHash" IN ('${e}')`}))})))}static async count(t){const e=t.map((t=>t.outputSpent));const s=new Yt({name:`Input.belong.${Math.random()}`,text:'SELECT count(*) FROM "Input" WHERE "outputSpent" LIKE ANY ($1)',values:[[e]]});const a=await ft.oneOrNone(s);return parseInt(a?.count,10)||0}}class qt{static async select(t){return Gt.select(t)}static async insert(t){return Gt.insert(t)}static async updateBlockHash(t,e){return Gt.updateBlockHash(t,e)}static async eraseBlockHash(t){return Gt.eraseBlockHash(t)}}class Jt{static insert=async(t,e=null)=>{const s=t.flatMap((({ins:t,txId:e})=>t.map(((t,s)=>({input:t,index:s,txId:e}))))).filter((({input:t})=>!O.isCoinbaseHash(t.hash))).map((({input:t,index:e,txId:s})=>{return{outputSpent:`${a=t.hash,u.reverseBuffer(Buffer.from(a)).toString("hex")}:${t.index}`,spendingInput:`${s}:${e}`,blockHash:null};var a}));if(await qt.insert(s),e){const t=s.map((({spendingInput:t})=>t));await qt.updateBlockHash(t,e)}};static select=async t=>qt.select(t);static updateBlockHash=async(t,e)=>{await qt.updateBlockHash(t,e)};static eraseBlockHash=async t=>{await qt.eraseBlockHash(t)}}function Vt(t){return/^[0-9A-Fa-f]{64}:\d+$/.test(t)}function zt(t){if(!Vt(t))throw new Error("Invalid rev")}const{PreparedStatement:Zt}=f;class Xt{static async listSentOutputs(t){const e=new Zt({name:`Output.listSentTxs.${Math.random()}`,text:'SELECT "Input"."spendingInput" AS "output", "Output"."satoshis" AS "amount"\n        FROM "Output" INNER JOIN "Input" ON "Output".rev = "Input"."outputSpent" \n        WHERE "Output"."address" = $1',values:[t]});return(await ft.any(e)).map((t=>({...t,amount:parseInt(t.amount,10)||0})))}static async listReceivedOutputs(t){const e=new Zt({name:`Output.listReceivedTxs.${Math.random()}`,text:'SELECT "Output"."rev" as "output", "Output"."satoshis" as "amount" FROM "Output" WHERE "address" = $1',values:[t]});return(await ft.any(e)).map((t=>({...t,amount:parseInt(t.amount,10)||0})))}static async listTxs(t){const e=new Zt({name:`Output.listTxs.${Math.random()}`,text:'WITH\n              -- List all txs sent from a given address\n              SENT AS (\n                SELECT split_part("Input"."spendingInput",\':\',1) as "txId", SUM("Output".satoshis) as "satoshis"\n                FROM "Output" INNER JOIN "Input" ON "Output".rev = "Input"."outputSpent"  \n                WHERE "Output".address = $1\n                GROUP BY split_part("Input"."spendingInput",\':\',1)\n              ),\n              -- List all tx received from a given address\n              RECEIVED AS (\n                SELECT SPLIT_PART("Output"."rev",\':\',1) as "txId", SUM("Output"."satoshis") as "satoshis" \n                FROM "Output" \n                WHERE "address" = $1\n                GROUP BY "txId"\n              )\n\n            SELECT\n              RECEIVED."txId", \n              coalesce(SENT."satoshis", 0) as "inputsSatoshis", \n              coalesce(RECEIVED."satoshis", 0) as "outputsSatoshis", \n              coalesce(RECEIVED."satoshis",0) - coalesce(SENT."satoshis",0) as "satoshis"\n            FROM\n              SENT RIGHT JOIN RECEIVED ON SENT."txId" = RECEIVED."txId";',values:[t]});const s=(await ft.any(e)).map((t=>({...t,inputsSatoshis:parseInt(t.inputsSatoshis,10)||0,outputsSatoshis:parseInt(t.outputsSatoshis,10)||0,satoshis:parseInt(t.satoshis,10)||0})));return{sentTxs:s.filter((t=>t.satoshis<0)).map((t=>({...t,satoshis:Math.abs(t.satoshis)}))),receivedTxs:s.filter((t=>t.satoshis>=0))}}static async select(t){const e=new Zt({name:`Output.select.${Math.random()}`,text:'SELECT "address", "satoshis", "asm", "rev", "hash", "mod", "isTbcOutput", "previous", "blockHash" FROM "Output" WHERE "address" = $1',values:[t]});return ft.any(e)}static async insert(t){await Promise.all(Ut(t,1111).map((t=>{const e=t.flatMap((({rev:t,address:e,satoshis:s,asm:a,isTbcOutput:r,mod:n,previous:o,hash:i,blockHash:c})=>[t,e,s,a,r,n,o,i,c]));return ft.none(new Zt({name:`Output.insert.${Math.random()}`,text:`INSERT INTO "Output"("rev", "address", "satoshis", "asm", "isTbcOutput",\n              "mod", "previous", "hash", "blockHash") VALUES ${Dt(e.length)} ON CONFLICT DO NOTHING`,values:e}))})))}static async eraseBlockHash(t){await Promise.all(Ut(t,1e4).map((t=>{const e=t.join("','");return ft.none(new Zt({name:`Output.eraseBlockHash.${Math.random()}`,text:`UPDATE "Output" SET "blockHash" = NULL WHERE "blockHash" IN ('${e}')`}))})))}static async updateBlockHash(t,e){await Promise.all(Ut(t,1e4).map((t=>{const s=t.join("','");return ft.none(new Zt({name:`Output.updateBlockHash.${Math.random()}`,text:`UPDATE "Output" SET "blockHash" = $1 WHERE "rev" IN ('${s}')`,values:[e]}))})))}static async getIdByRev(t){const e=new Zt({name:`NonStandard.recursiveUpdates.${Math.random()}`,text:'WITH RECURSIVE revUpdates AS (\n        SELECT "rev", "previous" FROM "Output" WHERE "isTbcOutput" = true and "rev" = $1\n        UNION ALL\n        SELECT o."rev", o."previous" FROM "Output" o\n        INNER JOIN revUpdates r ON r."previous" = o."rev"\n      )\n      SELECT * FROM revUpdates',values:[t]});const s=(await ft.any(e)).filter((t=>null===t.previous));return s[0]?.rev}static async getIdsByRevs(t){return Promise.all(t.map((t=>this.getIdByRev(t))))}static async getLatestRev(t){const e=new Zt({name:`NonStandard.recursiveUpdates.${Math.random()}`,text:'WITH RECURSIVE revUpdates AS (\n        SELECT "rev", "previous" FROM "Output" WHERE "isTbcOutput" = true and "rev" = $1\n        UNION ALL\n        SELECT o."rev", o."previous" FROM "Output" o\n        INNER JOIN revUpdates r ON o."previous" = r."rev"\n      )\n      SELECT * FROM revUpdates',values:[t]});const s=await ft.any(e);const a=Object.fromEntries(s.map((t=>[t.previous,t.rev])));let r=t;for(;a[r];)r=a[r];return r}static async getLatestRevs(t){return Promise.all(t.map(this.getLatestRev))}static async getIdsByMod(t){const e=new Zt({name:`Output.getIdsByMod.${Math.random()}`,text:'SELECT "rev" FROM "Output" WHERE "mod" = $1',values:[t]});return(await ft.any(e)).map((t=>t.rev))}static sqlSuffix(t,e,s){let a="";return s&&(a+=` order by "timestamp" ${s}`),a+=` limit ${t||V}`,e&&(a+=` offset ${e}`),a}static async getUnspentRevsByMod(t,e,s,a){const r=await this.getIdsByMod(t);const n=await this.getLatestRevs(r);const o=new Zt({name:`Output.getUnspentRevsByMod.${Math.random()}`,text:`SELECT "rev" FROM "Output" WHERE "rev" = ANY($1) ${this.sqlSuffix(e,s,a)}`,values:[n]});return(await ft.any(o)).map((t=>t.rev))}static async getUnspentRevsByPublicKey(t,e,s,a){const r=new Zt({name:`Output.getUnspentRevsByPublicKey.${Math.random()}`,text:`SELECT "rev" FROM "Output" WHERE asm LIKE '%${t}%' AND "isTbcOutput" = true \n      AND NOT EXISTS (SELECT 1 FROM "Input" ip WHERE "ip"."outputSpent" = "Output"."rev") \n      ${this.sqlSuffix(e,s,a)}`});return(await ft.any(r)).map((t=>t.rev))}static async getUnspentRevsByModAndPublicKey(t,e,s,a,r){const n=await this.getUnspentRevsByPublicKey(e,s,a,r);const o=await this.getIdsByRevs(n);const i=new Zt({name:`Output.getLatestRevsByModAndPublicKey.${Math.random()}`,text:'SELECT "rev" FROM "Output" WHERE "mod" = $1 AND "rev" = ANY($2)',values:[t,o]});const c=(await ft.any(i)).map((t=>t.rev));const u=await this.getLatestRevs(c);const l=new Zt({name:`Output.getLatestRevsByModAndPublicKey.${Math.random()}`,text:`SELECT "rev" FROM "Output" WHERE "rev" = ANY($1) ${this.sqlSuffix(s,a,r)}`,values:[u]});return(await ft.any(l)).map((t=>t.rev))}static async getUnspentTbcOutputs(t,e,s){const a=new Zt({name:`Output.getUnspentTbcOutputs.${Math.random()}`,text:`SELECT "rev", "address", "satoshis", "asm", "timestamp"\n        FROM "Output" WHERE "isTbcOutput" = true AND NOT EXISTS\n        (SELECT 1 FROM "Input" ip WHERE "ip"."outputSpent" = "Output"."rev") ${this.sqlSuffix(t,e,s)}`});return(await ft.any(a)).map((t=>t.rev))}static async query(t){const{publicKey:e,limit:s,offset:a,ids:r,mod:n,order:o}=t;const i=parseInt(V||"",10);if(s&&parseInt(s||"",10)>i||r&&r.length>i)throw new Error(`Can't fetch more than ${V} revs.`);if(o&&"ASC"!==o&&"DESC"!==o)throw new Error("Invalid order. Should be ASC or DESC.");return r?(r.map(zt),this.getLatestRevs(r)):n&&!e?this.getUnspentRevsByMod(n,s,a,o):!n&&e?this.getUnspentRevsByPublicKey(e,s,a,o):n&&e?this.getUnspentRevsByModAndPublicKey(n,e,s,a,o):this.getUnspentTbcOutputs(s,a,o)}static async selectNext(t){const e=new Zt({name:`Output.selectNext.${Math.random()}`,text:'SELECT "rev" FROM "Output" WHERE "previous" = $1',values:[t]});return ft.any(e)}static async selectPrev(t){const e=new Zt({name:`Output.selectPrev.${Math.random()}`,text:'SELECT "previous" FROM "Output" WHERE "rev" = $1',values:[t]});return ft.any(e)}}class Qt{static async select(t){return Xt.select(t)}static async insert(t){return Xt.insert(t)}static async eraseBlockHash(t){return Xt.eraseBlockHash(t)}static async updateBlockHash(t,e){return Xt.updateBlockHash(t,e)}static async listSentOutputs(t){return Xt.listSentOutputs(t)}static async listReceivedOutputs(t){return Xt.listReceivedOutputs(t)}static async listTxs(t){return Xt.listTxs(t)}static async getLatestRev(t){return Xt.getLatestRev(t)}static async getLatestRevs(t){return Xt.getLatestRevs(t)}static async getIdByRev(t){return Xt.getIdByRev(t)}static async query(t){return Xt.query(t)}static async selectNext(t){return Xt.selectNext(t)}static async selectPrev(t){return Xt.selectPrev(t)}}class te{static insert=async(t,e=null)=>{const s=function(t=C,e=H){switch(t){case"BTC":switch(e){case"mainnet":return c.bitcoin;case"testnet":return c.testnet;case"regtest":return c.regtest;default:throw new Error(`Invalid network ${e}`)}case"LTC":switch(e){case"mainnet":return c.litecoin;case"testnet":return c.litecointestnet;case"regtest":return c.litecoinregtest;default:throw new Error(`Invalid network ${e}`)}case"PEPE":switch(e){case"mainnet":return c.pepecoin;case"testnet":return c.pepecointestnet;case"regtest":return c.pepecoinregtest;default:throw new Error(`Invalid network ${e}`)}default:throw new Error(`Invalid chain ${t}`)}}(C,H);const a=t.flatMap((({outs:t,txId:e,zip:a,onChainMetaData:r})=>{const{exp:n="",mod:o=""}=r;return t.map((({script:t,value:r},c)=>{const u=c<a.length;return{rev:`${e}:${c}`,address:Wt((()=>p.fromOutputScript(t,s))),satoshis:Math.round(r),asm:l.toASM(t),isTbcOutput:u,mod:u?o:"",previous:u?a[c][0]:null,hash:u?i.sha256(Buffer.from(n)).toString("hex"):null,blockHash:null}}))}));if(await Qt.insert(a),e){const t=a.map((({rev:t})=>t));await Qt.updateBlockHash(t,e)}};static eraseBlockHash=async t=>{await Qt.eraseBlockHash(t)};static listSentOutputs=async t=>Qt.listSentOutputs(t);static listReceivedOutputs=async t=>Qt.listReceivedOutputs(t);static listTxs=async t=>Qt.listTxs(t);static getLatestRev=async t=>Qt.getLatestRev(t);static getLatestRevs=async t=>Qt.getLatestRevs(t);static getIdByRev=async t=>Qt.getIdByRev(t);static query=async t=>Qt.query(t)}class ee{static get=async t=>Kt.getTransaction(t);static getRaw=async t=>Kt.getBulkTransactions(t);static getRawJSON=async t=>Kt.getRawTransactionsJSON(t);static sendRaw=async t=>Kt.sendRawTransaction(t);static getUtxos=async t=>Kt.getUtxos(t);static waitForRpcBlockHash=async(t,e)=>Kt.waitForRpcBlockHash(t,e);static insertRpcBlock=async(t,e,s="LTC")=>{const{result:a}=await Kt.getBlock(t,2);const{tx:r}=a;let n=r;"LTC"===s&&(n=r.filter((t=>"08"!==t.hex.slice(10,12))));const o=`[wid ${e} pid: ${process.pid}: backfilling height ${a.height} - backfilling ${n.length} txs `;"LTC"===s&&o.concat(`(${r.length-n.length} mweb tx's filtered)...`),mt.info(o);const i=[];for(const t of n)try{let{hex:e}=t;e||(e=(await Kt.getRawTransaction(t.txid,1)).hex);const s=S.txFromHex({hex:e});s&&i.push(s)}catch(s){mt.error(`[wid ${e} pid: ${process.pid}: failed to parse transaction in block ${a.height}\n          error message: ${s.message}\n          transaction: ${JSON.stringify(t)}`)}try{await te.insert(i,t),await Jt.insert(i,t)}catch(t){mt.error(`[wid ${e} pid: ${process.pid}: inserting inputs and outputs for block ${a.height} failed with error '${t.message}'`)}};static walletSetup=async()=>Kt.walletSetup()}const se={protocol:st,user:X,pass:Q,host:tt,port:parseInt(et,10)};const ae=new R(se);const re={};const ne=JSON.parse(JSON.stringify(R.callspec));Object.keys(ne).forEach((t=>{ne[t.toLowerCase()]=ne[t]}));const oe={str:t=>t.toString(),string:t=>t.toString(),int:t=>parseFloat(t),float:t=>parseFloat(t),bool:t=>!0===t||"1"===t||1===t||"true"===t||"true"===t.toString().toLowerCase(),obj:t=>"string"==typeof t?JSON.parse(t):t};try{Object.keys(R.prototype).forEach((t=>{if(t&&"function"==typeof R.prototype[t]){const e=t.toLowerCase();re[t]=I.promisify(R.prototype[t].bind(ae)),re[e]=I.promisify(R.prototype[e].bind(ae))}}))}catch(t){mt.error(`Error occurred while binding RPC methods: ${t.message}`)}const ie=t=>new Promise((e=>{setTimeout(e,t)}));const ce=T(o);const ue=c.regtest;class le{static rawTxSubscriber=async t=>{const e=t.toString("hex");if(mt.info(`ZMQ message { rawTx:${e} }`),"08"!==e.slice(10,12))try{const t=S.txFromHex({hex:e});await te.insert([t]),await Jt.insert([t])}catch(t){mt.error(`Error parsing transaction ${e}\n${t.stack}`)}};static sub=async t=>{try{mt.info(`Bitcoin Computer Node ${gt} is starting on ${H} ${C}.`),await Kt.createWallet(),"regtest"!==H&&await Kt.checkBlockchainProgress(),await Kt.walletSetup(),mt.info(`Bitcoin Computer Node ${gt} is ready. MAX_BLOCKCHAIN_HEIGHT: 2538171`);for await(const[,e]of t)await this.rawTxSubscriber(e)}catch(t){mt.error(`ZMQ subscription failed with error '${t.message}'`)}}}const{PreparedStatement:pe}=f;class de{static async select(t){const e=new pe({name:`User.select.${Math.random()}`,text:'SELECT "publicKey", "clientTimestamp" FROM "User" WHERE "publicKey" = $1',values:[t]});const s=await ft.oneOrNone(e);return s?{publicKey:s.publicKey,clientTimestamp:parseInt(s.clientTimestamp,10)||0}:null}static async insert({publicKey:t,clientTimestamp:e}){const s=new pe({name:`User.insert.${Math.random()}`,text:'INSERT INTO "User"("publicKey", "clientTimestamp") VALUES ($1, $2)',values:[t,e]});await ft.none(s)}static async update({publicKey:t,clientTimestamp:e}){const s=new pe({name:`User.update.${Math.random()}`,text:'UPDATE "User" SET "clientTimestamp"=$1 WHERE "publicKey"=$2',values:[e,t]});await ft.none(s)}}class me{static async select(t){return de.select(t)}static async insert(t){return de.insert(t)}static async update(t){return de.update(t)}}const{ec:he}=b;const ge=new he("secp256k1");const ye=s();const we=new class{configFile;loaded=!1;load=()=>{try{const t="dev"===Z?"bcn.test.config.json":"bcn.config.json";const e=B(M(import.meta.url));this.configFile=$.readFileSync(N.join(e,"..","..",t)),this.loaded=!0}catch(t){if(t.message.includes("ENOENT: no such file or directory"))return void(this.loaded=!0);throw mt.error(`Access-list failed with error '${t.message}'`),t}};middleware=({url:t},e,s)=>{if(void 0!==e.locals.authToken)if(this.loaded||(mt.warn("Access-list failed with error 'AccessList not loaded.'. Loading now."),this.load()),void 0!==this.configFile)try{const{blacklist:t,whitelist:a}=JSON.parse(this.configFile.toString());if(t&&a)return void e.status(403).json({error:"Cannot enforce blacklist and whitelist at the same time."});const{publicKey:r}=e.locals.authToken;if(a&&!a.includes(r)||t&&t.includes(r))return void e.status(403).json({error:`Public key ${r} is not allowed.`});s()}catch(s){mt.error(`Authorization failed at ${t} with error: '${s.message}'`),e.status(403).json({error:s.message})}else s();else s()}};let fe;h(o);try{fe=a.createServer(ye)}catch(t){throw mt.error(`Starting server failed with error '${t.message}'`),t}if(mt.info(`Server listening on port ${k}`),ye.use(e()),"true"===W){const t=n({windowMs:parseInt(K,10),max:parseInt(Y,10),standardHeaders:"true"===G,legacyHeaders:"true"===q});ye.use(t)}ye.use(t.json({limit:"100mb"})),ye.use(t.urlencoded({limit:"100mb",extended:!0})),ye.get("/",((t,e)=>e.status(200).send(`\n        <h2>Bitcoin Computer Node</h2>\n        <b>Status</b>: Healthy <br />\n        <b>Version</b>: ${gt} <br />\n        <b>Chain</b>: ${C} <br />\n        <b>Network</b>: ${H}\n    `))),we.loaded&&(ye.use((async(t,e,s)=>{try{const a=t.get("Authentication");if(!a){const{method:s,url:a}=t;const r=`Auth failed with error 'no Authentication key provided' ${s} ${t.get("Host")} ${a}`;return mt.error(r),void e.status(401).json({error:r})}const r=(t=>{const e=t.split(" ");if(2!==e.length||"Bearer"!==e[0])throw new Error("Authentication header is invalid.");const s=Buffer.from(e[1],"base64").toString().split(":");if(3!==s.length)throw new Error;return{signature:s[0],publicKey:s[1],timestamp:parseInt(s[2],10)}})(a);const{signature:n,publicKey:o,timestamp:i}=r;if(Date.now()-i>18e4)return void e.status(401).json({error:"Signature is too old."});const c=x.sha256().update(z+i).digest("hex");if(!ge.keyFromPublic(o,"hex").verify(c,n)){const t="The origin and public key pair doesn't match the signature.";return void e.status(401).json({error:t})}const u=await me.select(o);if(u){if(u.clientTimestamp>=i)return void e.status(401).json({error:"Please use a fresh authentication token."});await me.update({publicKey:o,clientTimestamp:i})}else await me.insert({publicKey:o,clientTimestamp:i});e.locals.authToken=r,s()}catch(t){mt.error(`Auth failed with error '${t.message}'`),e.status(401).json({error:t.message})}})),ye.use(we.middleware));const ve=(()=>{const t=s.Router();return t.get("/wallet/:address/utxos",(async({params:t,url:e},s)=>{try{const{address:e}=t;s.status(200).json(await It.selectByAddress(e))}catch(t){mt.error(`GET ${e} failed with error '${t.message}'`),s.status(500).json({error:t.message})}})),t.get("/wallet/:address/sent-outputs",(async({params:t,url:e},s)=>{try{const{address:e}=t;s.status(200).json(await te.listSentOutputs(e))}catch(t){mt.error(`GET ${e} failed with error '${t.message}'`),s.status(500).json({error:t.message})}})),t.get("/wallet/:address/received-outputs",(async({params:t,url:e},s)=>{try{const{address:e}=t;s.status(200).json(await te.listReceivedOutputs(e))}catch(t){mt.error(`GET ${e} failed with error '${t.message}'`),s.status(500).json({error:t.message})}})),t.get("/wallet/:address/list-txs",(async({params:t,url:e},s)=>{try{const{address:e}=t;s.status(200).json(await te.listTxs(e))}catch(t){mt.error(`GET ${e} failed with error '${t.message}'`),s.status(500).json({error:t.message})}})),t.get("/non-standard-utxos",(async(t,e)=>{try{const s=new URLSearchParams(t.url.split("?")[1]);const a={mod:s.get("mod"),publicKey:s.get("publicKey"),limit:s.get("limit"),order:s.get("order"),offset:s.get("offset"),ids:JSON.parse(s.get("ids"))};const r=await te.query(a);e.status(200).json(r)}catch(s){mt.error(`GET ${t.url} failed with error '${s.messages}'`),e.status(500).json({error:s.message})}})),t.get("/address/:address/balance",(async({params:t,url:e},s)=>{try{const{address:e}=t;s.status(200).json(await It.getBalance(e))}catch(t){mt.error(`GET ${e} failed with error '${t.message||t}'`),s.status(500).json({error:t.message})}})),t.post("/tx/bulk",(async({body:{txIds:t},url:e},s)=>{try{if(void 0===t||0===t.length)return void s.status(400).json({error:"Missing input txIds."});const e=await ee.getRaw(t);e?s.status(200).json(e):s.status(404).json({error:"Not found"})}catch(t){mt.error(`POST ${e} failed with error '${t.message}'`),s.status(500).json({error:t.message})}})),t.post("/tx/post",(async({body:{hex:t},url:e},s)=>{try{if(!t)return void s.status(400).json({error:"Missing input hex."});const e=await ee.sendRaw(t);e?s.status(200).json(e):s.status(404).json({error:"Error Occured"})}catch(a){mt.error(`POST ${e} failed with error '${a.message}\ntxHex: ${t}`),s.status(500).json({error:a.message})}})),t.get("/mine",(async({query:{count:t},url:e},s)=>{try{const{result:e}=await re.getnewaddress();if("string"!=typeof t)throw new Error("Please provide appropriate count");return await re.generatetoaddress(parseInt(t,10)||1,e),s.status(200).json({success:!0})}catch(t){return mt.error(`POST ${e} failed with error '${t.message}'`),s.status(500).json({error:t.message})}})),t.get("/:id/height",(async({params:{id:t},url:e},s)=>{try{let e=t;if("best"===t){const{result:t}=await re.getbestblockhash();e=t}const{result:a}=await re.getblockheader(e,!0);return s.status(200).json({height:a.height})}catch(t){return mt.error(`POST ${e} failed with error '${t.message}'`),s.status(500).json({error:t.message})}})),t.post("/faucet",(async({body:{address:t,value:e},url:s},a)=>{try{const s=parseInt(e,10)/1e8;const{result:r}=await re.sendtoaddress(t,s);await re.generateToAddress(1,"mvFeNF9DAR7WMuCpBPbKuTtheihLyxzj8i");const{result:n}=await re.getrawtransaction(r,1);const o=n.vout.findIndex((t=>1e8*t.value===parseInt(e,10)));return a.status(200).json({txId:r,vout:o,height:-1,satoshis:e})}catch(t){return mt.error(`POST ${s} failed with error '${t.message}'`),a.status(500).json({error:t.message})}})),t.post("/faucetScript",(async({body:{script:t,value:e},url:s},a)=>{try{const s=ce.makeRandom({network:ue});const r=d.p2pkh({pubkey:s.publicKey,network:ue});const{address:n}=r;const o=(await re.sendtoaddress(n,2*parseInt(e,10)/1e8,"","")).result;let i;let c=10;for(;!i;)if(i=(await It.selectByAddress(n)).filter((t=>t.txId===o))[0],!i){if(c-=1,c<=0)throw new Error("No outputs");await ie(10)}const u=(await re.getrawtransaction(i.txId,1)).result;const p=new m({network:ue});p.addInput({hash:i.txId,index:i.vout,nonWitnessUtxo:Buffer.from(u.hex,"hex")}),p.addOutput({script:Buffer.from(t,"hex"),value:parseInt(e,10)}),p.signInput(0,s),p.finalizeAllInputs();const h=p.extractTransaction();let g;for(await re.sendrawtransaction(h.toHex()),c=5;!g;){const e=l.toASM(Buffer.from(t,"hex"));if(g=(await It.selectByScriptASM(e)).filter((t=>t.txId===h.getId()))[0],!g){if(c-=1,c<=0)throw new Error("No outputs");await ie(10)}}return a.status(200).json({txId:h.getId(),vout:g.vout,height:-1,satoshis:g.satoshis})}catch(t){return mt.error(`POST ${s} failed with error '${t.message}'`),a.status(500).json({error:t.message})}})),t.get("/tx/:txId/json",(async({params:{txId:t},url:e},s)=>{try{if(!t)return void s.status(400).json({error:"Missing input txId."});const e=await ee.getRawJSON(t);e?s.status(200).json(e):s.status(404).json({error:"Not found"})}catch(t){mt.error(`GET ${e} failed with error '${t.message}'`),s.status(500).json({error:t.message})}})),t.post("/revs",(async({body:{ids:t},url:e},s)=>{try{if(void 0===t||0===t.length)return void s.status(400).json({error:"Missing input object ids."});const e=await te.getLatestRevs(t);s.status(200).json(e)}catch(t){mt.error(`POST ${e} failed with error '${t.message}'`),s.status(500).json({error:t.message})}})),t.post("/revToId",(async({body:{rev:t},url:e},s)=>{try{if(!Vt(t))return void s.status(400).json({error:"Invalid rev id"});const e=await te.getIdByRev(t);e&&s.status(200).json(e),s.status(404).json()}catch(t){mt.error(`POST ${e} failed with error '${t.message}'`),s.status(500).json({error:t.message})}})),t.post("/rpc",(async({body:t,url:e},s)=>{try{if(!t||!t.method)throw new Error("Please provide appropriate RPC method name");if(!new RegExp(L).test(t.method))throw new Error("Method is not allowed");const e=function(t,e){if(void 0===ne[t]||null===ne[t])throw new Error("This RPC method does not exist, or not supported");const s=e.trim().split(" ");const a=ne[t].trim().split(" ");if(0===e.trim().length&&0!==ne[t].trim().length)throw new Error(`Too few params provided. Expected ${a.length} Provided 0`);if(0!==e.trim().length&&0===ne[t].trim().length)throw new Error(`Too many params provided. Expected 0 Provided ${s.length}`);if(s.length<a.length)throw new Error(`Too few params provided. Expected ${a.length} Provided ${s.length}`);if(s.length>a.length)throw new Error(`Too many params provided. Expected ${a.length} Provided ${s.length}`);return 0===e.length?[]:s.map(((t,e)=>oe[a[e]](t)))}(t.method,t.params);const a=e.length?await re[t.method](...e):await re[t.method]();s.status(200).json({result:a})}catch(t){mt.error(`POST ${e} failed with error '${t.message}'`),s.status(500).json({error:t.message})}})),t.get("/next/:rev",(async({params:{rev:t},url:e},s)=>{try{if(!t)return void s.status(400).json({error:"Missing rev."});const e=await Qt.selectNext(t);e?s.status(200).json({rev:e&&e.length?e[0].rev:void 0}):s.status(404).json({error:"Not found"})}catch(t){mt.error(`GET ${e} failed with error '${t.message}'`),s.status(500).json({error:t.message})}})),t.get("/prev/:rev",(async({params:{rev:t},url:e},s)=>{try{if(!t)return void s.status(400).json({error:"Missing rev."});const e=await Qt.selectPrev(t);e?s.status(200).json({rev:e&&e.length?e[0].previous:void 0}):s.status(404).json({error:"Not found"})}catch(t){mt.error(`GET ${e} failed with error '${t.message}'`),s.status(500).json({error:t.message})}})),t.post("/non-standard-utxo",(async(t,e)=>{e.status(500).json({error:"Please upgrade to @bitcoin-computer/lib to the latest version."})})),t})();ye.use(`/v1/${C}/${H}`,ve),ye.use("/v1/store",Tt),fe.listen(k,(()=>{mt.info(`\nStarted Bitcoin Computer Node Version ${gt}\nPORT ${k} \n`)})).on("error",(t=>{mt.error(t.message),process.exit(1)}));const Ee=new r.Subscriber;Ee.connect(A),Ee.subscribe("rawtx"),mt.info(`ZMQ Subscriber connected to ${A}`),(async()=>{await(async()=>{await E((()=>ft.connect()),{startingDelay:500})})(),await le.sub(Ee)})();
