import t from"body-parser";import e from"cors";import s from"express";import r from"http";import*as n from"zeromq";import a from"express-rate-limit";import*as o from"@bitcoin-computer/secp256k1";import{crypto as i,networks as c,bufferUtils as u,script as l,address as d,initEccLib as p}from"@bitcoin-computer/nakamotojs";import m from"dotenv";import h from"winston";import E from"winston-daily-rotate-file";import v from"pg-promise";import f from"pg-monitor";import{backOff as w}from"exponential-backoff";import g from"fs";import{Transaction as y}from"@bitcoin-computer/lib";import O from"bitcoind-rpc";import S from"util";import b from"elliptic";import $ from"hash.js";import T,{dirname as I}from"path";import{fileURLToPath as x}from"url";m.config();const R=process.env.BCN_CHAIN||"LTC";const C=process.env.BCN_NETWORK||"regtest";const{BCN_PORT:N}=process.env;const{BCN_ZMQ_URL:M}=process.env;const{BCN_ALLOWED_RPC_METHODS:H}=process.env;const{BCN_LOG_LEVEL:A}=process.env;const{BCN_LOG_MAX_FILES:k}=process.env;const{BCN_LOG_MAX_SIZE:L}=process.env;const{BCN_LOG_ZIP:B}=process.env;const{BCN_SHOW_DB_LOGS:j}=process.env;const{BCN_RATE_LIMIT_ENABLED:P}=process.env;const{BCN_RATE_LIMIT_WINDOW:F}=process.env;const{BCN_RATE_LIMIT_MAX:U}=process.env;const{BCN_RATE_LIMIT_STANDARD_HEADERS:_}=process.env;const{BCN_RATE_LIMIT_LEGACY_HEADERS:D}=process.env;process.env,process.env,process.env;const{BCN_OFFCHAIN_PROTOCOL:W}=process.env;const K=process.env.BCN_QUERY_LIMIT?parseInt(process.env.BCN_QUERY_LIMIT):void 0;const G=process.env.BCN_STREAM_KEYS&&process.env.BCN_STREAM_KEYS.split(",")||["satoshis","asm","expHash","mod"];const Y=process.env.BCN_URL||`http://127.0.0.1:${N}`;const q=process.env.BCN_ENV||"dev";const X=process.env.BCN_ZMQ_ACTIVATION_HEIGHT||"1";const{BITCOIN_RPC_USER:J}=process.env;const{BITCOIN_RPC_PASSWORD:V}=process.env;const{BITCOIN_RPC_HOST:z}=process.env;const{BITCOIN_RPC_PORT:Q}=process.env;const{BITCOIN_RPC_PROTOCOL:Z}=process.env;const{BITCOIN_DEFAULT_WALLET:tt}=process.env;const{POSTGRES_USER:et}=process.env;const{POSTGRES_PASSWORD:st}=process.env;const{POSTGRES_DB:rt}=process.env;const{POSTGRES_HOST:nt}=process.env;const{POSTGRES_PORT:at}=process.env;const{POSTGRES_MAX_CONNECTIONS:ot}=process.env;const{POSTGRES_IDLE_TIMEOUT_MILLIS:it}=process.env;h.addColors({error:"red",warn:"yellow",info:"green",http:"magenta",debug:"blue"});const ct=h.format.combine(h.format.colorize(),h.format.timestamp({format:"YYYY-MM-DD HH:mm:ss:ms"}),h.format.json(),h.format.printf(t=>`${t.timestamp} [${t.level.slice(5).slice(0,-5)}] ${t.message}`));const ut=h.format.combine(h.format.colorize(),h.format.timestamp({format:"MM-DD-YYYY HH:mm:ss"}),h.format.printf(t=>`${t.timestamp} ${t.level} ${t.message}`));const lt={zippedArchive:"true"===B,maxSize:L,maxFiles:k,dirname:"logs"};const dt=[];const pt={0:"error",1:"warn",2:"info",3:"http",4:"debug"}[A];"dev"===q&&dt.push(new h.transports.Console({format:ut,level:pt})),dt.push(new E({filename:"logs/application-%DATE%.log",datePattern:"YYYY-MM-DD",level:pt,...lt})),dt.push(new E({filename:"logs/error-%DATE%.log",datePattern:"YYYY-MM-DD",level:"error",...lt}));const mt=h.createLogger({levels:{error:0,warn:1,info:2,http:3,debug:4},format:ct,transports:dt,exceptionHandlers:[new h.transports.File({filename:"logs/exceptions.log"})],rejectionHandlers:[new h.transports.File({filename:"logs/rejections.log"})]});m.config({path:"../../.env"});const{version:ht}=JSON.parse(g.readFileSync("package.json","utf8"));const Et=ht||process.env.BCN_SERVER_VERSION;const vt=parseInt(process.env.MWEB_HEIGHT||"",10)||432;const ft=[{txId:"e3bf3d07d4b0375638d5f1db5255fe07ba2c4cb067cd81b84ee974b6585fb468",height:91722},{txId:"d5d27987d2a3dfc724e359870c6644b40e497bdc0589a033220fe15429d88599",height:91812}];const wt=["satoshis","asm","expHash","mod","id"];const gt={error:(t,e)=>{if(e.cn){const{host:s,port:r,database:n,user:a,password:o}=e.cn;mt.debug(`Waiting for db to start { message:${t.message} host:${s}, port:${r}, database:${n}, user:${a}, password: ${o}`)}},noWarnings:!0};let yt;"true"===j&&(f.isAttached()?f.detach():(f.attach(gt),f.setTheme("matrix")));try{yt=v(gt)}catch(t){throw mt.error("pgPromise init error",t),t}const Ot=yt({host:nt,port:parseInt(at,10),database:rt,user:et,password:st,max:parseInt(ot,10),allowExitOnIdle:!0,idleTimeoutMillis:parseInt(it,10)});const{PreparedStatement:St}=v;class bt{static async select(t){const e=new St({name:`OffChain.select.${Math.random()}`,text:'SELECT "data" FROM "OffChain" WHERE "id" = $1',values:[t]});return Ot.oneOrNone(e)}static async insert({id:t,data:e}){const s=new St({name:`OffChain.insert.${Math.random()}`,text:'INSERT INTO "OffChain" ("id", "data") VALUES ($1, $2) ON CONFLICT DO NOTHING',values:[t,e]});return Ot.none(s)}static async delete(t){const e=new St({name:`OffChain.delete.${Math.random()}`,text:'WITH deleted AS (DELETE FROM "OffChain" WHERE "id" = $1 RETURNING *) SELECT count(*) FROM deleted;',values:[t]});return(await Ot.any(e))[0].count>0}}class $t{static async select(t){const e=await bt.select(t);return e?.data||null}static async insert(t){return bt.insert(t)}static async delete(t){return bt.delete(t)}}const Tt=s.Router();Tt.get("/:id",async({params:{id:t},url:e},s)=>{try{const e=await $t.select(t);e?s.status(200).json(e):s.status(403).json({error:"No entry found."})}catch(t){mt.error(`GET ${e} failed with error '${t.message}'`),s.status(500).json({error:t.message})}}),Tt.post("/",async(t,e)=>{const{body:{data:s},url:r}=t;try{const r=i.sha256(Buffer.from(s)).toString("hex");await $t.insert({id:r,data:s});const n=`${W||t.protocol}://${t.get("host")}/store/${r}`;e.status(201).json({_url:n})}catch(t){mt.error(`POST ${r} failed with error '${t.message}'`),e.status(500).json({error:t.message})}}),Tt.delete("/:id",async(t,e)=>{e.status(500).json({error:"Deletions are not supported yet."})});const{PreparedStatement:It}=v;class xt{static async getBalance(t){const e=new It({name:`Utxos.getBalance.${Math.random()}`,text:'SELECT COALESCE(sum("satoshis"),0) as "satoshis" FROM "Utxos" WHERE "address" = $1 and "blockHash" is not null',values:[t]});const s=new It({name:`Utxos.getBalance.${Math.random()}`,text:'SELECT COALESCE(sum("satoshis"),0) as "satoshis" FROM "Utxos" WHERE "address" = $1 and "blockHash" is null',values:[t]});const r=(await Ot.oneOrNone(e)).satoshis;const n=(await Ot.oneOrNone(s)).satoshis;return{confirmed:r,unconfirmed:n,balance:(BigInt(r)+BigInt(n)).toString()}}static async select(t){const e=new It({name:`Utxos.select.${Math.random()}`,text:'SELECT "address", COALESCE("satoshis",0) as "satoshis", "asm", "rev", split_part(rev, \':\', 1) AS "txId", cast(split_part(rev, \':\', 2) as INTEGER) AS "vout" FROM "Utxos" WHERE "address" = $1',values:[t]});return Ot.any(e)}static async selectByScriptASM(t){const e=new It({name:`Utxos.select.${Math.random()}`,text:'SELECT "address", COALESCE("satoshis",0) as "satoshis", "asm", "rev", split_part(rev, \':\', 1) AS "txId", cast(split_part(rev, \':\', 2) as INTEGER) AS "vout" FROM "Utxos" WHERE "asm" = $1',values:[t]});return Ot.any(e)}static async selectByPk(t){const e=new It({name:`Utxos.selectByPk.${Math.random()}`,text:`SELECT "address", COALESCE("satoshis",0) as "satoshis", "asm", "rev", split_part(rev, ':', 1) AS "txId", cast(split_part(rev, ':', 2) as INTEGER) AS "vout" FROM "Utxos" WHERE "asm" LIKE '%${t}%'`});return Ot.any(e)}}class Rt{static async getBalance(t){return xt.getBalance(t)}static async select(t){return xt.select(t)}static async selectByPk(t){return xt.selectByPk(t)}static async selectByScriptASM(t){return xt.selectByScriptASM(t)}}class Ct{static getBalance=async t=>Rt.getBalance(t)}const Nt={protocol:Z,user:J,pass:V,host:z,port:parseInt(Q,10)};const Mt=new O(Nt);const Ht=S.promisify(O.prototype.createwallet.bind(Mt));const At=S.promisify(O.prototype.generateToAddress.bind(Mt));const kt=S.promisify(O.prototype.getaddressinfo.bind(Mt));const Lt=S.promisify(O.prototype.getBlock.bind(Mt));const Bt=S.promisify(O.prototype.getBlockchainInfo.bind(Mt));const jt=S.promisify(O.prototype.getBlockHash.bind(Mt));const Pt=S.promisify(O.prototype.getRawTransaction.bind(Mt));const Ft=S.promisify(O.prototype.getRawTransaction.bind(Mt));const Ut=S.promisify(O.prototype.getTransaction.bind(Mt));const _t=S.promisify(O.prototype.getNewAddress.bind(Mt));const Dt={createwallet:Ht,generateToAddress:At,getaddressinfo:kt,getBlock:Lt,getBlockchainInfo:Bt,getBlockHash:jt,getRawTransaction:Pt,getTransaction:Ut,importaddress:S.promisify(O.prototype.importaddress.bind(Mt)),invalidateBlock:S.promisify(O.prototype.invalidateBlock.bind(Mt)),listunspent:S.promisify(O.prototype.listunspent.bind(Mt)),sendRawTransaction:S.promisify(O.prototype.sendRawTransaction.bind(Mt)),getNewAddress:_t,sendToAddress:S.promisify(O.prototype.sendToAddress.bind(Mt)),getRawTransactionJSON:Ft,validateaddress:S.promisify(O.prototype.validateaddress.bind(Mt))};const Wt=t=>"true"===t||"false"!==t&&void 0;const Kt=t=>void 0!==t?Number(t):void 0;const Gt=(t,e)=>{const s=[];for(let r=0;r<t.length;r+=e){const n=Math.min(r+e,t.length);const a=t.slice(r,n);s.push(a)}return s};const Yt=t=>{if(t<1)return"";let e="($1,$2)";for(let s=3;s<=t;s+=2)e+=`,($${s},$${s+1})`;return e};const qt=t=>{const e=[];for(let s=1;s<=t;s+=3){const t=`($${s},$${s+1},$${s+2})`;e.push(t)}return e.join(",")};const Xt=t=>{const e=[];for(let s=1;s<=t;s+=11){const t=`($${s},$${s+1},$${s+2},$${s+3},$${s+4},$${s+5},$${s+6},$${s+7},$${s+8},$${s+9},$${s+10})`;e.push(t)}return e.join(",")};const Jt=t=>{try{return t()}catch{return null}};function Vt(t){return/^[0-9a-fA-F]+$/.test(t)}class zt{static async getBulkTransactions(t){return(await Promise.all(t.map(t=>Dt.getRawTransaction(t,0)))).map(t=>t.result)}static async getRawTransaction(t,e){const{result:s}=await Dt.getRawTransaction(t,e);return"object"==typeof s&&s.vout.forEach(t=>{t.value=BigInt(Math.round(1e8*t.value))}),s}static async getRawTransactionsJSON(t){return{txId:(e=(await Dt.getRawTransactionJSON(t,1)).result).txid,txHex:e.hex,vsize:e.vsize,version:e.version,locktime:e.locktime,ins:e.vin.map(t=>t.coinbase?{coinbase:t.coinbase,sequence:t.sequence}:{txId:t.txid,vout:t.vout,script:t.scriptSig.hex,sequence:t.sequence}),outs:e.vout.map(t=>{let e;return t.scriptPubKey.addresses?[e]=t.scriptPubKey.addresses:e=t.scriptPubKey.address?t.scriptPubKey.address:void 0,{address:e,script:t.scriptPubKey.hex,value:BigInt(Math.round(1e8*t.value)).toString()}})};var e}static async sendRawTransaction(t){const{result:e,error:s}=await Dt.sendRawTransaction(t);if(s)throw mt.error(s),new Error("Error sending transaction");return e}static getUtxos=async t=>{let e;e="DOGE"===R||"PEPE"===R?await Dt.validateaddress(t):await Dt.getaddressinfo(t),void 0===e.result.timestamp&&(mt.info(`Importing address: ${t}`),await Dt.importaddress(t,!1));const s=await Dt.listunspent(0,999999,[t]);return s.result.forEach(t=>{t.amount=BigInt(t.amount)}),s.result};static walletSetup=async()=>{if("regtest"===C){if(mt.info(`Node is starting for chain ${R} and network ${C} \n\nStarting Wallet setup`),"LTC"===R){const{result:t}=await Dt.getBlockchainInfo();const e=t.blocks;if(e<vt){const{result:t}=await Dt.getNewAddress("","legacy");const s=vt-e-1;s&&await Dt.generateToAddress(s,t);const{result:r}=await Dt.getNewAddress("mweb","mweb");await Dt.sendToAddress(r,1),await Dt.generateToAddress(1,t),mt.info("MWEB setup is complete")}}if("BTC"===R){const{result:t}=await Dt.getNewAddress("","legacy");await Dt.generateToAddress(200,t),mt.info("Wallet setup is complete")}if("PEPE"===R||"DOGE"===R){const{result:t}=await Dt.getNewAddress("");await Dt.generateToAddress(200,t),mt.info("Wallet setup is complete")}}};static createWallet=async()=>{try{await Dt.createwallet(tt,!1,!1,"",!1,!1)}catch(t){if(t.message.includes("already exists"))return void mt.info(`Wallet ${tt} already exists`);mt.warn(`Wallet creation failed with error '${t.message}'`)}};static checkBlockchainProgress=async t=>{const e=await w(async()=>{const e=await Dt.getBlockchainInfo();const s=(100*parseFloat(e.result.verificationprogress)).toFixed(4);const{blocks:r}=e.result;if(mt.info(`Zmq. Bitcoind { percentage:${s}%, blocks:${r} }`),parseFloat(e.result.verificationprogress)<=t)throw new Error("Node not ready yet");return e},{startingDelay:6e4,timeMultiple:1,numOfAttempts:8760});const s=(100*parseFloat(e.result.verificationprogress)).toFixed(4);const r=e.result.blocks;mt.info(`BCN reaches sync end...at { bitcoind.progress:${s}%, bitcoindSyncedHeight:${r} }`)}}class Qt{static getRawHexs=async t=>zt.getBulkTransactions(t);static getRawHEX=async t=>zt.getRawTransaction(t,0);static getRawJSON=async t=>zt.getRawTransactionsJSON(t);static sendRaw=async t=>zt.sendRawTransaction(t);static getUtxos=async t=>zt.getUtxos(t);static parseTransactions=async(t,e,s,r,n)=>{let a=t;"LTC"===e&&(a=t.filter(t=>"08"!==t.hex.slice(10,12)));const o=[];for(const t of a)try{let{hex:a}=t;a||(a=(await zt.getRawTransaction(t.txid,1)).hex);const i=y.fromHex(a);i&&("BTC"===e&&"mainnet"===s&&ft.some(t=>t.height===n&&t.txId===i.txId)?mt.warn(`wid ${r} pid: ${process.pid}: skipping conflicting transaction ${i.txId} in block ${n}`):o.push(i))}catch(e){mt.error(`[wid ${r} pid: ${process.pid}: failed to parse transaction in block ${n}\n          error message: ${e.message}\n          transaction: ${JSON.stringify(t)}`)}return o};static walletSetup=async()=>zt.walletSetup()}const Zt={protocol:Z,user:J,pass:V,host:z,port:parseInt(Q,10)};const te=new O(Zt);const ee={};const se=JSON.parse(JSON.stringify(O.callspec));Object.keys(se).forEach(t=>{se[t.toLowerCase()]=se[t]});const re={str:t=>t.toString(),string:t=>t.toString(),int:t=>parseFloat(t),float:t=>parseFloat(t),bool:t=>!0===t||"1"===t||1===t||"true"===t||"true"===t.toString().toLowerCase(),obj:t=>"string"==typeof t?JSON.parse(t):t};try{Object.keys(O.prototype).forEach(t=>{if(t&&"function"==typeof O.prototype[t]){const e=t.toLowerCase();ee[t]=S.promisify(O.prototype[t].bind(te)),ee[e]=S.promisify(O.prototype[e].bind(te))}})}catch(t){mt.error(`Error occurred while binding RPC methods: ${t.message}`)}function ne(t){return/^[0-9A-Fa-f]{64}:\d+$/.test(t)}const{PreparedStatement:ae}=v;class oe{static async listSentOutputs(t){const e=new ae({name:`Output.listSentTxs.${Math.random()}`,text:'SELECT "Input"."spendingInput" AS "output", COALESCE("Output"."satoshis", 0) AS "satoshis"\n        FROM "Output" INNER JOIN "Input" ON "Output".rev = "Input"."outputSpent" \n        WHERE "Output"."address" = $1',values:[t]});return Ot.any(e)}static async listReceivedOutputs(t){const e=new ae({name:`Output.listReceivedTxs.${Math.random()}`,text:'SELECT "Output"."rev" as "output", COALESCE("Output"."satoshis", 0) as "satoshis" FROM "Output" WHERE "address" = $1',values:[t]});return Ot.any(e)}static async listTxs(t){const e=new ae({name:`Output.listTxs.${Math.random()}`,text:'\n        WITH \n          -- Outputs received by the address\n          received AS (\n            SELECT SPLIT_PART("rev", \':\', 1) AS "txId", SUM("satoshis") AS "satoshis"\n            FROM "Output"\n            WHERE "address" = $1\n            GROUP BY 1\n          ),\n          -- Total satoshis sent from the address\n          sent AS (\n            SELECT SPLIT_PART("Input"."spendingInput", \':\', 1) AS "txId", SUM("Output"."satoshis") AS "satoshis"\n            FROM "Input"\n            JOIN "Output" ON "Input"."outputSpent" = "Output"."rev"\n            WHERE "Output"."address" = $1\n            GROUP BY 1\n          ),\n          txs AS (\n            SELECT \n              COALESCE(r."txId", s."txId") AS "txId",\n              COALESCE(s."satoshis", 0) AS "inputsSatoshis",\n              COALESCE(r."satoshis", 0) AS "outputsSatoshis",\n              COALESCE(r."satoshis", 0) - COALESCE(s."satoshis", 0) AS "satoshis"\n            FROM received r\n            FULL OUTER JOIN sent s ON r."txId" = s."txId"\n          )\n        SELECT * FROM txs;\n      ',values:[t]});const s=await Ot.any(e);return{sentTxs:s.filter(t=>BigInt(t.satoshis)<0n).map(t=>({...t,satoshis:(-1n*BigInt(t.satoshis)).toString()})),receivedTxs:s.filter(t=>BigInt(t.satoshis)>=0n).map(t=>({...t,satoshis:BigInt(t.satoshis).toString()}))}}static async select(t){const e=new ae({name:`Output.select.${Math.random()}`,text:'SELECT "address", "satoshis", "asm", "rev", "expHash", "mod", "isObject", "previous", "blockHash" FROM "Output" WHERE "address" = $1',values:[t]});return Ot.any(e)}static async selectByRev(t){const e=new ae({name:`Output.selectByRev.${Math.random()}`,text:'SELECT "address", "satoshis", "asm", "rev", "expHash", "mod", "isObject", "previous", "blockHash" FROM "Output" WHERE "rev" = $1',values:[t]});return Ot.oneOrNone(e)}static async insert(t){await Promise.all(Gt(t,900).map(t=>{const e=t.flatMap(({rev:t,address:e,satoshis:s,asm:r,isObject:n,mod:a,previous:o,expHash:i,blockHash:c,blockHeight:u,blockIndex:l})=>[t,e,s,r,n,a,o,i,c,u,l]);return Ot.none(new ae({name:`Output.insert.${Math.random()}`,text:`INSERT INTO "Output"("rev", "address", "satoshis", "asm", "isObject",\n              "mod", "previous", "expHash", "blockHash", "blockHeight", "blockIndex") VALUES ${Xt(e.length)} ON CONFLICT  ("rev") \n              DO UPDATE SET "blockHash" = COALESCE("Output"."blockHash", EXCLUDED."blockHash"),\n                            "blockHeight" = EXCLUDED."blockHeight",\n                            "blockIndex"  = EXCLUDED."blockIndex"`,values:e}))}))}static async updateMods(t){await Promise.all(Gt(t,5e3).map(t=>{const e=t.flatMap(({rev:t,mod:e})=>[t,e]);return Ot.none(new ae({name:`Output.update.${Math.random()}`,text:`UPDATE "Output" AS o\n              SET "mod" = v.mod\n              FROM (\n                VALUES\n                  ${Yt(e.length)}\n              ) AS v(rev, mod)\n              WHERE o.rev = v.rev\n                AND o.mod is NULL`,values:e}))}))}static async eraseBlockHash(t){await Promise.all(Gt(t,1e4).map(t=>{const e=t.join("','");return Ot.none(new ae({name:`Output.eraseBlockHash.${Math.random()}`,text:`UPDATE "Output" SET "blockHash" = NULL WHERE "blockHash" IN ('${e}')`}))}))}static async getAncestorTxs(t){const e=new ae({name:`NonStandard.recursiveUpdates.${Math.random()}`,text:' WITH RECURSIVE RecursiveCTE AS (\n        SELECT SUBSTRING("rev" FROM 1 FOR 64) AS "rev", SUBSTRING(o."previous" FROM 1 FOR 64) as "previous"\n        FROM "Output" o\n        where o."isObject" = true and SUBSTRING(o."rev" FROM 1 FOR 64) = $1\n        UNION ALL\n        SELECT SUBSTRING(o."rev" FROM 1 FOR 64),  SUBSTRING(o.previous FROM 1 FOR 64)\n        FROM "Output" o\n        INNER JOIN RecursiveCTE r ON SUBSTRING(r."previous" FROM 1 FOR 64) = SUBSTRING(o."rev" FROM 1 FOR 64)\n      )\n      select distinct rev as "txId"\n      FROM RecursiveCTE;\n      ',values:[t]});return(await Ot.any(e)).map(t=>t.txId)}static async firstByMod(t){const e=new ae({name:`Output.getIdsByMod.${Math.random()}`,text:'SELECT "rev" FROM "Output" WHERE "mod" = $1',values:[t]});return(await Ot.any(e)).map(t=>t.rev)}static sqlSuffix(t,e,s){let r="";return s&&(r+=` order by "timestamp" ${s}`),(t||K)&&(r+=` limit ${t||K}`),e&&(r+=` offset ${e}`),r}static async unspentByMod(t,e,s,r){const n=await this.firstByMod(t);const a=await Promise.all(n.map(this.latest));const o=new ae({name:`Output.unspentByMod.${Math.random()}`,text:`SELECT "rev" FROM "Output" WHERE "rev" = ANY($1) \n      AND NOT EXISTS (SELECT 1 FROM "Input" ip WHERE "ip"."outputSpent" = "Output"."rev")\n      ${this.sqlSuffix(e,s,r)}`,values:[a]});return(await Ot.any(o)).map(t=>t.rev)}static async unspentByPublicKey(t,e,s,r){const n=new ae({name:`Output.unspentByPublicKey.${Math.random()}`,text:`SELECT "rev" FROM "Output" WHERE "isObject" = true AND asm LIKE '%' || $1 || '%' \n      AND NOT EXISTS (SELECT 1 FROM "Input" ip WHERE "ip"."outputSpent" = "Output"."rev") \n      ${this.sqlSuffix(e,s,r)}`,values:[t]});return(await Ot.any(n)).map(t=>t.rev)}static async unspentByModPublicKey(t,e,s,r,n){const a=await this.unspentByPublicKey(e,s,r,n);const o=await Promise.all(a.map(t=>this.first(t)));const i=new ae({name:`Output.unspentByModPublicKey1.${Math.random()}`,text:'SELECT "rev" FROM "Output" WHERE "mod" = $1 AND "rev" = ANY($2)',values:[t,o]});const c=(await Ot.any(i)).map(t=>t.rev);const u=await Promise.all(c.map(this.latest));const l=new ae({name:`Output.unspentByModPublicKey2.${Math.random()}`,text:`SELECT "rev" FROM "Output" WHERE "rev" = ANY($1) ${this.sqlSuffix(s,r,n)}`,values:[u]});return(await Ot.any(l)).map(t=>t.rev)}static async unspent(t,e,s){const r=new ae({name:`Output.getUnspentTbcOutputs.${Math.random()}`,text:`SELECT "rev", "address", "satoshis", "asm", "timestamp"\n        FROM "Output" WHERE "isObject" = true AND NOT EXISTS\n        (SELECT 1 FROM "Input" ip WHERE "ip"."outputSpent" = "Output"."rev") ${this.sqlSuffix(t,e,s)}`});return(await Ot.any(r)).map(t=>t.rev)}static async query(t){const{publicKey:e,limit:s,offset:r,mod:n,order:a}=t;if(s&&K&&parseInt(s||"",10)>K)throw new Error(`Can't fetch more than ${K} revs.`);if(a&&"ASC"!==a&&"DESC"!==a)throw new Error("Invalid order. Should be ASC or DESC.");return n&&!e?this.unspentByMod(n,s,r,a):!n&&e?this.unspentByPublicKey(e,s,r,a):n&&e?this.unspentByModPublicKey(n,e,s,r,a):this.unspent(s,r,a)}static async getTXOs(t){const{verbosity:e,rev:s,address:r,satoshis:n,asm:a,isObject:o,mod:i,previous:c,expHash:u,blockHash:l,blockHeight:d,blockIndex:p,isSpent:m,isConfirmed:h,publicKey:E,limit:v,order:f="ASC",offset:w=0}=t;const g=[];const y=[];let O=1;s&&(g.push('"rev" = $'+O++),y.push(s)),r&&(g.push('"address" = $'+O++),y.push(r)),n&&(g.push('"satoshis" = $'+O++),y.push(n.toString())),a&&(g.push('"asm" = $'+O++),y.push(`${a}`)),void 0!==o&&(g.push('"isObject" = $'+O++),y.push(o)),i&&(g.push('"mod" = $'+O++),y.push(i)),c&&(g.push('"previous" = $'+O++),y.push(c)),u&&(g.push('"expHash" = $'+O++),y.push(u)),l&&(g.push('"blockHash" = $'+O++),y.push(l)),d&&(g.push('"blockHeight" = $'+O++),y.push(d)),p&&(g.push('"blockIndex" = $'+O++),y.push(p)),void 0!==m&&(m?g.push('EXISTS (SELECT 1 FROM "Input" ip WHERE ip."outputSpent" = "Output"."rev")'):g.push('NOT EXISTS (SELECT 1 FROM "Input" ip WHERE ip."outputSpent" = "Output"."rev")')),void 0!==h&&(h?g.push('"blockHash" IS NOT NULL'):g.push('"blockHash" IS NULL')),E&&(g.push('"asm" LIKE $'+O++),y.push(`%${E}%`));const S=g.length>0?`WHERE ${g.join(" AND ")}`:"";let b="";void 0!==v?(y.push(v),y.push(w||0),b=`LIMIT $${O++} OFFSET $${O++}`):K&&(y.push(K),y.push(w||0),b=`LIMIT $${O++} OFFSET $${O++}`);const $="DESC"===f?"DESC":"ASC";const T=0===e?'"rev"':'"rev", "address", "satoshis", "asm", "isObject", "mod", "previous", "expHash", "blockHash", "blockHeight", "blockIndex"';const I=new ae({name:`Output.getTxos.${Math.random()}`,text:`\n        SELECT ${T}\n        FROM "Output"\n        ${S}\n        ORDER BY "rev" ${$}\n        ${b}\n      `,values:[...y]});const x=await Ot.any(I);return 0===e?x.map(t=>t.rev):x}static async first(t){const e=new ae({name:`NonStandard.first.${Math.random()}`,text:'WITH RECURSIVE revUpdates AS (\n        SELECT "rev", "previous" FROM "Output" WHERE "isObject" = true and "rev" = $1\n        UNION ALL\n        SELECT o."rev", o."previous" FROM "Output" o\n        INNER JOIN revUpdates r ON r."previous" = o."rev"\n      )\n      SELECT * FROM revUpdates',values:[t]});const s=await Ot.any(e);if(0===s.length)throw new Error("Rev not found");return s.filter(t=>null===t.previous)[0].rev}static async next(t){const e=new ae({name:`Output.next.${Math.random()}`,text:'SELECT "rev" FROM "Output" WHERE "previous" = $1',values:[t]});const s=await Ot.any(e);if(s.length>0)return s;const r=new ae({name:`Output.next2.${Math.random()}`,text:'SELECT "rev" FROM "Output" WHERE "rev" = $1 AND "isObject" = true',values:[t]});if(!((await Ot.any(r)).length>0))throw new Error("Rev not found")}static async prev(t){const e=new ae({name:`Output.prev.${Math.random()}`,text:'SELECT "previous" FROM "Output" WHERE "rev" = $1 and "isObject" = true',values:[t]});const s=await Ot.any(e);if(0===s.length)throw new Error("Rev not found");return s}static async descendants(t){const e=new ae({name:`NonStandard.descendants.${Math.random()}`,text:'WITH RECURSIVE descendants_cte AS (\n        SELECT "rev", "previous" FROM "Output" WHERE "isObject" = true and "rev" = $1\n        UNION ALL\n        SELECT o."rev", o."previous" FROM "Output" o\n        INNER JOIN descendants_cte d ON o."previous" = d."rev"\n      )\n      SELECT * FROM descendants_cte',values:[t]});return(await Ot.any(e)).map(t=>t.rev)}static async latest(t){const e=new ae({name:`NonStandard.latest.${Math.random()}`,text:'WITH RECURSIVE revUpdates AS (\n        SELECT "rev", "previous" FROM "Output" WHERE "isObject" = true and "rev" = $1\n        UNION ALL\n        SELECT o."rev", o."previous" FROM "Output" o\n        INNER JOIN revUpdates r ON o."previous" = r."rev"\n      )\n      SELECT * FROM revUpdates',values:[t]});const s=await Ot.any(e);if(0===s.length)throw new Error("Rev not found");const r=Object.fromEntries(s.map(t=>[t.previous,t.rev]));let n=t;for(;r[n];)n=r[n];return n}}class ie{static async select(t){return oe.select(t)}static async selectByRev(t){return oe.selectByRev(t)}static async insert(t){return oe.insert(t)}static async eraseBlockHash(t){return oe.eraseBlockHash(t)}static updateMods=async t=>{await oe.updateMods(t)};static async listSentOutputs(t){return oe.listSentOutputs(t)}static async listReceivedOutputs(t){return oe.listReceivedOutputs(t)}static async listTxs(t){return oe.listTxs(t)}static async getAncestorTxs(t){return oe.getAncestorTxs(t)}static async query(t){return oe.query(t)}static async getTXOs(t){return oe.getTXOs(t)}static async first(t){return oe.first(t)}static async prev(t){return oe.prev(t)}static async descendants(t){return oe.descendants(t)}static async next(t){return oe.next(t)}static async latest(t){return oe.latest(t)}}const{PreparedStatement:ce}=v;class ue{static async select(t){const e=new ce({name:`Input.select.${Math.random()}`,text:'SELECT "outputSpent", "spendingInput", "blockHash" FROM "Input" WHERE "outputSpent" = $1',values:[t]});return Ot.any(e)}static async insert(t){await Promise.all(Gt(t,3333).map(t=>{const e=t.flatMap(({outputSpent:t,spendingInput:e,blockHash:s})=>[t,e,s]);return Ot.none(new ce({name:`Input.insert.${Math.random()}`,text:`INSERT INTO "Input"("outputSpent", "spendingInput", "blockHash") VALUES ${qt(e.length)} \n              ON CONFLICT ("spendingInput") \n              DO UPDATE SET "blockHash" = COALESCE("Input"."blockHash", EXCLUDED."blockHash")`,values:e}))}))}static async eraseBlockHash(t){await Promise.all(Gt(t,1e4).map(t=>{const e=t.join("','");return Ot.none(new ce({name:`Input.eraseBlockHash.${Math.random()}`,text:`UPDATE "Input" SET "blockHash" = NULL WHERE "blockHash" IN ('${e}')`}))}))}static async count(t){const e=t.map(t=>t.outputSpent);const s=new ce({name:`Input.belong.${Math.random()}`,text:'SELECT count(*) FROM "Input" WHERE "outputSpent" LIKE ANY ($1)',values:[[e]]});const r=await Ot.oneOrNone(s);return parseInt(r?.count,10)||0}}class le{static async select(t){return ue.select(t)}static async insert(t){return ue.insert(t)}static async eraseBlockHash(t){return ue.eraseBlockHash(t)}}class de{static insert=async t=>{await le.insert(t)};static getInputs=(t,e=null)=>t.flatMap(({ins:t,txId:e})=>t.map((t,s)=>({input:t,index:s,txId:e}))).filter(({input:t})=>!y.isCoinbaseHash(t.hash)).map(({input:t,index:s,txId:r})=>{return{outputSpent:`${n=t.hash,u.reverseBuffer(Buffer.from(n)).toString("hex")}:${t.index}`,spendingInput:`${r}:${s}`,blockHash:e};var n});static select=async t=>le.select(t);static eraseBlockHash=async t=>{await le.eraseBlockHash(t)}}const pe=function(t=R,e=C){switch(t){case"BTC":switch(e){case"mainnet":return c.bitcoin;case"testnet":return c.testnet;case"regtest":return c.regtest;default:throw new Error(`Invalid network ${e}`)}case"LTC":switch(e){case"mainnet":return c.litecoin;case"testnet":return c.litecointestnet;case"regtest":return c.litecoinregtest;default:throw new Error(`Invalid network ${e}`)}case"PEPE":switch(e){case"mainnet":return c.pepecoin;case"testnet":return c.pepecointestnet;case"regtest":return c.pepecoinregtest;default:throw new Error(`Invalid network ${e}`)}case"DOGE":switch(e){case"mainnet":return c.dogecoin;case"testnet":return c.dogecointestnet;case"regtest":return c.dogecoinregtest;default:throw new Error(`Invalid network ${e}`)}default:throw new Error(`Invalid chain ${t}`)}}(R,C);class me{static insert(t){return ie.insert(t)}static buildQueryKey(t){return wt.filter(e=>void 0!==t[e]).map(e=>`${e}=${encodeURIComponent(t[e])}`).join("&")}static async getSubscriptionKeys(t){const e=new Set;const s={};void 0!==t.satoshis&&(s.satoshis=t.satoshis.toString()),t.asm&&(s.asm=t.asm),t.mod&&(s.mod=t.mod),t.expHash&&(s.expHash=t.expHash);const r=Object.keys(s);for(let t=1;t<1<<r.length;t++){const n={};for(let e=0;e<r.length;e++)if(t&1<<e){const t=r[e];n[t]=s[t]}e.add(this.buildQueryKey(n))}try{const s=await me.first(t.rev);s&&e.add(`id=${encodeURIComponent(s)}`)}catch{}return e}static insertAndUpdateMod=async(t,e)=>{await Promise.all([me.insert(t),de.insert(e)]);const s=await me.getModUpates(t);return await me.updateMods(s),t.map(t=>({...t,mod:s.find(e=>e.rev===t.rev)?.mod||t.mod}))};static getOutputs=(t,e=null,s=null)=>t.flatMap(({outs:t,txId:r,zip:n,onChainMetaData:a},o)=>{const{exp:c="",mod:u=null}=a;return t.map(({script:t,value:a},p)=>{const m=p<n.length;let h;try{h=l.toASM(t)}catch(t){h="[error]"}const E=m&&void 0===n[p][0];return{rev:`${r}:${p}`,address:Jt(()=>d.fromOutputScript(t,pe)),satoshis:a,asm:h,isObject:m,mod:E?u:null,previous:m?n[p][0]:null,expHash:m?i.sha256(Buffer.from(c)).toString("hex"):null,blockHash:s,blockHeight:e,blockIndex:o}})});static getModUpates=async t=>{const e=[];return await Promise.all(t.map(async t=>{const s=await me.getModUpdatesForOutput(t);s&&(await ie.descendants(t.rev)).forEach(t=>{e.push({rev:t,mod:s})})})),e};static async getModUpdatesForOutput({isObject:t,previous:e,rev:s,mod:r}){if(!t)return null;if(void 0===e)return r;const n=await ie.selectByRev(e);return n?.mod?.length>0?n.mod:null}static updateMods=async t=>{await ie.updateMods(t)};static getAncestorTxs=async t=>ie.getAncestorTxs(t);static select=async t=>ie.select(t);static eraseBlockHash=async t=>{await ie.eraseBlockHash(t)};static listSentOutputs=async t=>ie.listSentOutputs(t);static listReceivedOutputs=async t=>ie.listReceivedOutputs(t);static listTxs=async t=>ie.listTxs(t);static latest=async t=>ie.latest(t);static first=async t=>ie.first(t);static query=async t=>ie.query(t);static getTXOs=async t=>ie.getTXOs(t)}const he=new Map;class Ee{static has(t){return he.has(t)}static set(t,e){he.has(t)||he.set(t,new Set),he.get(t).add(e)}static get(t){return he.get(t)}static delete(t){return he.delete(t)}static close(t,e){const s=he.get(t);s&&(s.delete(e),0===s.size&&he.delete(t))}static closeAll(){he.forEach(t=>{t.forEach(t=>{t.end()}),t.clear()}),he.clear()}}class ve{static async emitFromOutputRows(t,e=null){await Promise.all(t.map(async t=>{const s=await me.getSubscriptionKeys(t);await Promise.all(Array.from(s).map(async s=>{const r=Ee.get(s)||new Set;for(const n of r)try{n.write(`data: ${JSON.stringify({rev:t.rev,hex:e})}\n\n`)}catch{Ee.close(s,n)}}))}))}}class fe{static rawTxSubscriber=async t=>{const e=t.toString("hex");mt.info(`ZMQ message { hex:${e} }`);const s=e.slice(10,12);if("08"!==s&&"09"!==s)try{const t=y.fromHex(e);const s=await me.insertAndUpdateMod(me.getOutputs([t]),de.getInputs([t]));await ve.emitFromOutputRows(s,e)}catch(t){mt.error(`[zmq] Error parsing transaction ${e}\n${t.stack}`)}};static sub=async t=>{try{mt.info(`Bitcoin Computer Node ${Et} is starting on ${C} ${R}.`),await zt.createWallet(),"regtest"!==C&&await zt.checkBlockchainProgress(.7),await zt.walletSetup(),mt.info(`Bitcoin Computer Node ${Et} is ready. ZQM activation height: ${X}`),await zt.checkBlockchainProgress(.9);for await(const[,e]of t)await this.rawTxSubscriber(e)}catch(t){mt.error(`ZMQ subscription failed with error '${t.message}'`)}}}const{PreparedStatement:we}=v;class ge{static async select(t){const e=new we({name:`User.select.${Math.random()}`,text:'SELECT "publicKey", "clientTimestamp" FROM "User" WHERE "publicKey" = $1',values:[t]});const s=await Ot.oneOrNone(e);return s?{publicKey:s.publicKey,clientTimestamp:parseInt(s.clientTimestamp,10)||0}:null}static async insert({publicKey:t,clientTimestamp:e}){const s=new we({name:`User.insert.${Math.random()}`,text:'INSERT INTO "User"("publicKey", "clientTimestamp") VALUES ($1, $2)',values:[t,e]});await Ot.none(s)}static async update({publicKey:t,clientTimestamp:e}){const s=new we({name:`User.update.${Math.random()}`,text:'UPDATE "User" SET "clientTimestamp"=$1 WHERE "publicKey"=$2',values:[e,t]});await Ot.none(s)}}class ye{static async select(t){return ge.select(t)}static async insert(t){return ge.insert(t)}static async update(t){return ge.update(t)}}const{ec:Oe}=b;const Se=new Oe("secp256k1");const be=s();const $e=new class{configFile;loaded=!1;load=()=>{try{const t="dev"===q?"bcn.test.config.json":"bcn.config.json";const e=I(x(import.meta.url));this.configFile=g.readFileSync(T.join(e,"..","..",t)),this.loaded=!0}catch(t){if(t.message.includes("ENOENT: no such file or directory"))return void(this.loaded=!0);throw mt.error(`Access-list failed with error '${t.message}'`),t}};middleware=({url:t},e,s)=>{if(void 0!==e.locals.authToken)if(this.loaded||(mt.warn("Access-list failed with error 'AccessList not loaded.'. Loading now."),this.load()),void 0!==this.configFile)try{const{blacklist:t,whitelist:r}=JSON.parse(this.configFile.toString());if(t&&r)return void e.status(403).json({error:"Cannot enforce blacklist and whitelist at the same time."});const{publicKey:n}=e.locals.authToken;if(r&&!r.includes(n)||t&&t.includes(n))return void e.status(403).json({error:`Public key ${n} is not allowed.`});s()}catch(s){mt.error(`Authorization failed at ${t} with error: '${s.message}'`),e.status(403).json({error:s.message})}else s();else s()}};let Te;p(o);try{Te=r.createServer(be)}catch(t){throw mt.error(`Starting server failed with error '${t.stack}'`),t}mt.info(`Server listening on port ${N}`),be.use(e()),"true"===P&&be.use(a({windowMs:parseInt(F,10)||9e5,max:parseInt(U,10)||100,standardHeaders:"true"===_,legacyHeaders:"true"===D})),be.use(t.json({limit:"100mb"})),be.use(t.urlencoded({limit:"100mb",extended:!0})),$e.loaded&&(be.use(async(t,e,s)=>{try{const r=t.get("Authentication");if(!r){const{method:s,url:r}=t;const n=`Auth failed with error 'no Authentication key provided' ${s} ${t.get("Host")} ${r}`;return mt.error(n),void e.status(401).json({error:n})}const n=(t=>{const e=t.split(" ");if(2!==e.length||"Bearer"!==e[0])throw new Error("Authentication header is invalid.");const s=Buffer.from(e[1],"base64").toString().split(":");if(3!==s.length)throw new Error;return{signature:s[0],publicKey:s[1],timestamp:parseInt(s[2],10)}})(r);const{signature:a,publicKey:o,timestamp:i}=n;if(Date.now()-i>18e4)return void e.status(401).json({error:"Signature is too old."});const c=$.sha256().update(Y+i).digest("hex");if(!Se.keyFromPublic(o,"hex").verify(c,a)){const t="The origin and public key pair doesn't match the signature.";return void e.status(401).json({error:t})}const u=await ye.select(o);if(u){if(u.clientTimestamp>=i)return void e.status(401).json({error:"Please use a fresh authentication token."});await ye.update({publicKey:o,clientTimestamp:i})}else await ye.insert({publicKey:o,clientTimestamp:i});e.locals.authToken=n,s()}catch(t){mt.error(`Auth failed with error '${t.message}'`),e.status(401).json({error:t.message})}}),be.use($e.middleware)),be.use(async function(t,e,s){const r=Date.now();mt.http(`${t.method} ${t.originalUrl}`),e.on("finish",()=>{const{method:s,originalUrl:n}=t;const{statusCode:a}=e;const o=Date.now()-r;mt.http(`${s} ${n} ${a} - ${o}ms`)}),s()});const Ie=`\n  <h2>Bitcoin Computer Node</h2>\n  <b>Status</b>: Healthy <br />\n  <b>Version</b>: ${Et} <br />\n  <b>Chain</b>: ${R} <br />\n  <b>Network</b>: ${C}\n`;be.get("/",(t,e)=>e.status(200).send(Ie)),be.use(`/v1/${R}/${C}`,(()=>{const t=s.Router();function e(t){if(0===Object.keys(t).length)return"No subscription parameters provided";const e=[...G,"id"];for(const s of Object.keys(t))if(!e.includes(s))return`Invalid subscription parameter: ${s}`;return t.id&&!ne(t.id)?"id must be a valid revision":t.expHash&&!Vt(t.expHash)?"expHash must be a valid hex string":t.asm&&!l.fromASM(t.asm)?"asm must be a valid script ASM":t.mod&&!ne(t.mod)?"mod must be a valid revision":t.satoshis&&!(t=>{try{return BigInt(t),!0}catch{return!1}})(t.satoshis)?"satoshis must be a valid bigint string":null}return t.get("/wallet/:address/sent-outputs",async({params:t,url:e},s)=>{try{const{address:e}=t;s.status(200).json(await me.listSentOutputs(e))}catch(t){mt.error(`GET ${e} failed with error '${t.message}'`),s.status(500).json({error:t.message})}}),t.get("/wallet/:address/received-outputs",async({params:t,url:e},s)=>{try{const{address:e}=t;s.status(200).json(await me.listReceivedOutputs(e))}catch(t){mt.error(`GET ${e} failed with error '${t.message}'`),s.status(500).json({error:t.message})}}),t.get("/wallet/:address/list-txs",async({params:t,url:e},s)=>{try{const{address:e}=t;s.status(200).json(await me.listTxs(e))}catch(t){mt.error(`GET ${e} failed with error '${t.message}'`),s.status(500).json({error:t.message})}}),t.get("/address/:address/balance",async({params:t,url:e},s)=>{try{const{address:e}=t;s.status(200).json(await Ct.getBalance(e))}catch(t){mt.error(`GET ${e} failed with error '${t.message||t}'`),s.status(500).json({error:t.message})}}),t.get("/non-standard-utxos",async(t,e)=>{try{const s=new URLSearchParams(t.url.split("?")[1]);const r={mod:s.get("mod"),publicKey:s.get("publicKey"),limit:s.get("limit"),order:s.get("order"),offset:s.get("offset")};const n=await me.query(r);e.status(200).json(n)}catch(s){mt.error(`GET ${t.url} failed with error '${s.messages}'`),e.status(500).json({error:s.message})}}),t.get("/get-txos",async(t,e)=>{try{const r=t.query;const n=["verbosity","rev","address","satoshis","asm","isObject","mod","previous","expHash","blockHash","blockHeight","blockIndex","isSpent","isConfirmed","publicKey","limit","offset","order"];if(Object.keys(r).forEach(t=>{if(!n.includes(t))throw new Error(`Unexpected parameter '${t}'`)}),0===Object.keys(r).filter(t=>"verbosity"!==t&&void 0!==r[t]).length)throw new Error("At least one query parameter must be provided");const a=Kt(r.verbosity)??0;if(![0,1].includes(a))throw new Error("verbosity must be 0 or 1");const o=Kt(r.limit);if(void 0!==o){if(isNaN(o)||K&&o>K)throw new Error(`limit must be a number not exceeding ${K}`);if(o<0)throw new Error("limit must be a positive number")}const i=Kt(r.offset)??0;if(isNaN(i)||i<0)throw new Error("offset must be a number");const c=r.satoshis&&void 0!==(s=r.satoshis)?BigInt(s):void 0;if(r.rev&&!ne(r.rev))throw new Error("rev must be valid");if(r.previous&&!ne(r.previous))throw new Error("previous must be valid");if(r.publicKey&&!Vt(r.publicKey))throw new Error("publicKey must be hex");if(r.expHash&&!Vt(r.expHash))throw new Error("exp must be hex");if(r.blockHash&&!Vt(r.blockHash))throw new Error("blockHash must be hex");if(r.blockHeight&&(isNaN(parseInt(r.blockHeight))||parseInt(r.blockHeight)<0))throw new Error("blockHeight must be a valid number");if(r.blockIndex&&(isNaN(parseInt(r.blockIndex))||parseInt(r.blockIndex)<0))throw new Error("blockIndex must be a valid number");if(r.asm&&!l.fromASM(r.asm))throw new Error("asm is not valid");if(r.isSpent&&void 0===Wt(r.isSpent))throw new Error("isSpent must be true or false");if(r.isConfirmed&&void 0===Wt(r.isConfirmed))throw new Error("isConfirmed must be true or false");if(r.isObject&&void 0===Wt(r.isObject))throw new Error("isObject must be true or false");if(r.order&&!["ASC","DESC"].includes(r.order))throw new Error("order must be 'ASC' or 'DESC'");if(r.mod&&!ne(r.mod))throw new Error("mod must be a valid revision");const u={verbosity:a,rev:r.rev,address:r.address,satoshis:c,asm:r.asm,isObject:Wt(r.isObject),mod:r.mod,previous:r.previous,expHash:r.expHash,blockHash:r.blockHash,blockHeight:r.blockHeight?parseInt(r.blockHeight):void 0,blockIndex:r.blockIndex?parseInt(r.blockIndex):void 0,isSpent:Wt(r.isSpent),isConfirmed:Wt(r.isConfirmed),publicKey:r.publicKey,limit:o,offset:i,order:r.order};const d=await me.getTXOs(u);e.status(200).json(d)}catch(s){mt.error(`GET ${t.url} failed`,{error:s}),e.status(500).json({error:s instanceof Error?s.message:"Unknown error"})}var s}),t.get("/tx/:txId/hex",async({params:{txId:t},url:e},s)=>{try{if(!t)return void s.status(400).json({error:"Missing input txId."});const e=await Qt.getRawHEX(t);e?s.set("Cache-Control","public, max-age=31536000").status(200).json(e):s.status(404).json({error:"Not found"})}catch(t){mt.error(`GET ${e} failed with error '${t.message}'`),s.status(500).json({error:t.message})}}),t.get("/tx/:txId/json",async({params:{txId:t},url:e},s)=>{try{if(!t)return void s.status(400).json({error:"Missing input txId."});const e=await Qt.getRawJSON(t);e?s.set("Cache-Control","public, max-age=31536000").status(200).json(e):s.status(404).json({error:"Not found"})}catch(t){mt.error(`GET ${e} failed with error '${t.message}'`),s.status(500).json({error:t.message})}}),t.post("/tx/bulk",async({body:{txIds:t},url:e},s)=>{try{if(void 0===t||0===t.length)return void s.status(400).json({error:"Missing input txIds."});const e=await Qt.getRawHexs(t);e?s.set("Cache-Control","public, max-age=31536000").status(200).json(e):s.status(404).json({error:"Not found"})}catch(t){mt.error(`POST ${e} failed with error '${t.message}'`),s.status(500).json({error:t.message})}}),t.post("/tx/post",async({body:{hex:t},url:e},s)=>{try{if(!t)return void s.status(400).json({error:"Missing input hex."});const e=await Qt.sendRaw(t);e?s.status(200).json(e):s.status(404).json({error:"Error Occured"})}catch(r){mt.error(`POST ${e} failed with error '${r.message}\ntxHex: ${t}`),s.status(500).json({error:r.message})}}),t.get("/tx/:txId/ancestors",async({params:t,url:e},s)=>{try{const{txId:e}=t;if(e.includes(":"))return void s.status(400).json({error:"Invalid txId, did you provide a revision instead?"});if(!e)return void s.status(400).json({error:"Missing input txIds."});const r=await me.getAncestorTxs(e);r?s.set("Cache-Control","public, max-age=31536000").status(200).json(r):s.status(404).json({error:"Not found"})}catch(t){mt.error(`POST ${e} failed with error '${t.message}'`),s.status(500).json({error:t.message})}}),t.post("/revToId",async({body:{rev:t},url:e},s)=>{try{if(!ne(t))return void s.status(400).json({error:"Invalid revision"});const e=await me.first(t);s.set("Cache-Control","public, max-age=31536000").status(200).json(e)}catch(t){mt.error(`POST ${e} failed with error '${t.message}'`),s.status(500).json({error:t.message})}}),t.post("/rpc",async({body:t,url:e},s)=>{try{if(!t||!t.method)throw new Error("Please provide appropriate RPC method name");if(!new RegExp(H).test(t.method))throw new Error("Method is not allowed");const e=function(t,e){if(void 0===se[t]||null===se[t])throw new Error("This RPC method does not exist, or not supported");const s=e.trim().split(" ");const r=se[t].trim().split(" ");if(0===e.trim().length&&0!==se[t].trim().length)throw new Error(`Too few params provided. Expected ${r.length} Provided 0`);if(0!==e.trim().length&&0===se[t].trim().length)throw new Error(`Too many params provided. Expected 0 Provided ${s.length}`);if(s.length<r.length)throw new Error(`Too few params provided. Expected ${r.length} Provided ${s.length}`);if(s.length>r.length)throw new Error(`Too many params provided. Expected ${r.length} Provided ${s.length}`);return 0===e.length?[]:s.map((t,e)=>re[r[e]](t))}(t.method,t.params);const r=e.length?await ee[t.method](...e):await ee[t.method]();s.status(200).json({result:r})}catch(t){mt.error(`POST ${e} failed with error '${t.message}'`),s.status(500).json({error:t.message})}}),t.get("/next/:rev",async({params:{rev:t},url:e},s)=>{try{if(!t)return void s.status(400).json({error:"Missing rev."});const e=await ie.next(t);s.status(200).json({rev:e&&e.length?e[0].rev:void 0})}catch(t){mt.error(`GET ${e} failed with error '${t.message}'`),s.status(500).json({error:t.message})}}),t.get("/prev/:rev",async({params:{rev:t},url:e},s)=>{try{if(!t)return void s.status(400).json({error:"Missing rev."});const e=await ie.prev(t);e?s.set("Cache-Control","public, max-age=31536000").status(200).json({rev:e&&e.length?e[0].previous:void 0}):s.status(404).json({error:"Not found"})}catch(t){mt.error(`GET ${e} failed with error '${t.message}'`),s.status(500).json({error:t.message})}}),t.get("/latest/:rev",async({params:{rev:t},url:e},s)=>{try{if(!t)return void s.status(400).json({error:"Missing rev."});const e=await me.latest(t);e?s.status(200).json({rev:e}):s.status(404).json({error:"Not found"})}catch(t){mt.error(`GET ${e} failed with error '${t.message}'`),s.status(500).json({error:t.message})}}),t.get("/subscribe-check",(t,s)=>{const r=e(t.query);return r?s.status(400).send(r):s.status(200).send("Subscription parameters are valid")}),t.get("/subscribe",(t,s)=>{try{const r=e(t.query);if(r)return s.status(400).send(r);const n=t.url.split("?")[1]||"";if(!n)return s.status(400).send("No valid subscription parameters provided");s.writeHead(200,{"Content-Type":"text/event-stream","Cache-Control":"no-cache",Connection:"keep-alive"}),Ee.set(n,s);const a=setInterval(()=>{s.write("data: \n\n")},3e4);t.on("close",()=>{clearInterval(a),Ee.close(n,s),s.end()})}catch(t){mt.error("Error in /subscribe:",t.message),s.status(500).json({error:t.message})}}),t.post("/non-standard-utxo",async(t,e)=>{e.status(500).json({error:"Please upgrade to @bitcoin-computer/lib to the latest version."})}),t})()),be.use("/v1/store",Tt);const xe=`\n\n----------------------------------\n  [1mStarting Bitcoin Computer Node[0m\n\n  Chain [2m${R}[0m\n  Network [2m${C}[0m\n  Version [2m${Et}[0m\n  URL [2m${Y}[0m\n----------------------------------\n`;Te.listen(N,()=>{mt.info(xe)}).on("error",t=>{mt.error(t.message),process.exit(1)});const Re=new n.Subscriber;Re.connect(M),Re.subscribe("rawtx"),mt.info(`ZMQ Subscriber connected to ${M}`),(async()=>{try{await(async()=>{await w(async()=>{await Ot.one("SELECT 1"),mt.info("Database connection established")},{startingDelay:500})})(),await fe.sub(Re)}catch(t){mt.error(`Error in connectAndSub: ${t.stack}`),process.exit(1)}})(),process.on("SIGINT",async()=>{try{mt.info("Shutting down server..."),Ee.closeAll(),Te.close(()=>{mt.info("Server closed."),process.exit(0)}),await Re.close()}catch(t){mt.error(`Error shutting down: ${t.stack}`)}});
