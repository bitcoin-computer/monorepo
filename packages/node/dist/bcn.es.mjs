import t from"body-parser";import e from"cors";import s from"express";import r from"http";import*as a from"zeromq";import n from"express-rate-limit";import o from"dotenv";import i from"fs";import c,{Transaction as d}from"@bitcoin-computer/nakamotojs-lib";import l from"winston";import u from"winston-daily-rotate-file";import p from"pg-promise";import m from"pg-monitor";import{backOff as h}from"exponential-backoff";import{ECPairFactory as w}from"ecpair";import*as g from"@bitcoin-computer/tiny-secp256k1";import f from"bitcoind-rpc";import y from"util";import{Computer as E}from"@bitcoin-computer/lib";import $ from"elliptic";import T from"hash.js";import v,{dirname as S}from"path";import{fileURLToPath as b}from"url";o.config();const R=JSON.parse(i.readFileSync("package.json","utf8"));const{PORT:x,ZMQ_URL:I,CHAIN:O,NETWORK:N,BCN_ENV:M,BCN_URL:C,DEBUG_MODE:A,POSTGRES_USER:P,POSTGRES_PASSWORD:_,POSTGRES_DB:j,POSTGRES_HOST:H,POSTGRES_PORT:B,RPC_PROTOCOL:D,RPC_USER:k,RPC_PASSWORD:L,RPC_HOST:K,RPC_PORT:Y,SERVER_VERSION:U,DEFAULT_WALLET:F,SYNC_INTERVAL_CHECK:W,POSTGRES_MAX_PARAM_NUM:G,DB_CONNECTION_RETRY_TIME:q,SIGNATURE_FRESHNESS_MINUTES:J,ALLOWED_RPC_METHODS:z,NODE_MAX_PROGRESS:V,SYNC_MAX_PROGRESS:Z,MAX_BLOCKCHAIN_HEIGHT:X,MWEB_HEIGHT:Q,BC_START_HEIGHT:tt,WORKER_ID:et,NUM_WORKERS:st,SYNC_NON_STANDARD:rt,ZMQ_WAIT_PERCENTAGE:at,QUERY_LIMIT:nt,LOG_MAX_FILE_SIZE:ot,LOG_MAX_FILE_NUM:it,LOG_ZIP:ct,RPC_URL:dt,RPC_BATCHSIZE:lt,RPC_CONCURRENT:ut,INDEXDB:pt,KEYDB:mt}=process.env;const ht=parseInt(x,10)||"3000";const wt=I||"tcp://node:28332";const gt=O||"LTC";const ft=N||"regtest";const yt=M||"dev";const Et=C||"http://127.0.0.1:3000";const $t=parseInt(A,10)||1;const Tt=P||"bcn";const vt=_||"bcn";const St=j||"bcn";const bt=H||"127.0.0.1";const Rt=parseInt(B,10)||"5432";const xt=D||"http";const It=k||"bcn-admin";const Ot=L||"kH4nU5Okm6-uyC0_mA5ztVNacJqZbYd_KGLl6mx722A=";const Nt=K||"node";const Mt=parseInt(Y,10)||19332;const Ct=R.version||U;const At=F||"defaultwallet";const Pt=parseInt(G,10)||1e4;const _t=parseInt(q,10)||500;const jt=parseInt(J,10)||3;const Ht=z?z.split(",").map((t=>new RegExp(t))):[];const Bt=parseInt(X||"",10)||2538171;const Dt=parseInt(Q||"",10)||432;const kt=parseInt(tt||"",10)||25e5;const Lt=parseInt(at||"",10)||.7;const Kt=parseInt(nt||"",10)||100;const Yt=ot||"20m";const Ut=it||"14d";const Ft=!!ct;l.addColors({error:"red",warn:"yellow",info:"green",http:"magenta",debug:"white"});const Wt=l.format.combine(l.format.colorize(),l.format.timestamp({format:"YYYY-MM-DD HH:mm:ss:ms"}),l.format.json(),l.format.printf((t=>`${t.timestamp} [${t.level.slice(5).slice(0,-5)}] ${t.message}`)));const Gt={zippedArchive:Ft,maxSize:Yt,maxFiles:Ut,dirname:"logs"};const qt=[];"dev"===yt&&qt.push(new l.transports.Console({format:l.format.combine(l.format.colorize(),l.format.timestamp({format:"MM-DD-YYYY HH:mm:ss"}),l.format.printf((t=>`${t.timestamp} ${t.level} ${t.message}`)))})),$t>=0&&qt.push(new u({filename:"error-%DATE%.log",datePattern:"YYYY-MM-DD",level:"error",...Gt})),$t>=1&&qt.push(new u({filename:"warn-%DATE%.log",datePattern:"YYYY-MM-DD",level:"warn",...Gt})),$t>=2&&qt.push(new u({filename:"info-%DATE%.log",datePattern:"YYYY-MM-DD",level:"info",...Gt})),$t>=3&&qt.push(new u({filename:"http-%DATE%.log",datePattern:"YYYY-MM-DD",level:"http",...Gt})),$t>=4&&qt.push(new u({filename:"debug-%DATE%.log",datePattern:"YYYY-MM-DD",level:"debug",...Gt})),qt.push(new u({filename:"logs-%DATE%.log",datePattern:"YYYY-MM-DD"}));const Jt=l.createLogger({levels:{error:0,warn:1,info:2,http:3,debug:4},format:Wt,transports:qt,exceptionHandlers:[new l.transports.File({filename:"logs/exceptions.log"})],rejectionHandlers:[new l.transports.File({filename:"logs/rejections.log"})]});const zt=()=>"dev"===yt;const Vt={error:(t,e)=>{if(e.cn){const{host:s,port:r,database:a,user:n,password:o}=e.cn;Jt.debug(`Waiting for db to start { message:${t.message} host:${s}, port:${r}, database:${a}, user:${n}, password: ${o}`)}},noWarnings:!0};zt()&&$t>0&&(m.isAttached()?m.detach():(m.attach(Vt),m.setTheme("matrix")));const Zt=p(Vt)({host:bt,port:Rt,database:St,user:Tt,password:vt,allowExitOnIdle:!0,idleTimeoutMillis:100});const{PreparedStatement:Xt}=p;class Qt{static async select(t){const e=new Xt({name:`OffChain.select.${Math.random()}`,text:'SELECT "data" FROM "OffChain" WHERE "id" = $1',values:[t]});return Zt.oneOrNone(e)}static async insert({id:t,data:e}){const s=new Xt({name:`OffChain.insert.${Math.random()}`,text:'INSERT INTO "OffChain" ("id", "data") VALUES ($1, $2) ON CONFLICT DO NOTHING',values:[t,e]});return Zt.none(s)}static async delete(t){const e=new Xt({name:`OffChain.delete.${Math.random()}`,text:'WITH deleted AS (DELETE FROM "OffChain" WHERE "id" = $1 RETURNING *) SELECT count(*) FROM deleted;',values:[t]});return(await Zt.any(e))[0].count>0}}class te{static async select(t){const e=await Qt.select(t);return e?.data||null}static async insert(t){return Qt.insert(t)}static async delete(t){return Qt.delete(t)}}const{crypto:ee}=c;const se=s.Router();se.get("/:id",(async({params:{id:t},url:e},s)=>{try{const e=await te.select(t);e?s.status(200).json(e):s.status(403).json({error:"No entry found."})}catch(t){Jt.error(`GET ${e} failed with error '${t.message}'`),s.status(500).json({error:t.message})}})),se.post("/",(async(t,e)=>{const{body:{data:s},url:r}=t;try{const a=ee.sha256(Buffer.from(s)).toString("hex");await te.insert({id:a,data:s});const n=`${["localhost","127.0.0.1"].includes(t.host)?"http":"https"}://${t.get("host")}/store/${a}`;Jt.info(`Off-chain POST ${r} succeeded with url '${n}'`),e.status(201).json({_url:n})}catch(t){Jt.error(`POST ${r} failed with error '${t.message}'`),e.status(500).json({error:t.message})}})),se.delete("/:id",(async(t,e)=>{e.status(500).json({error:"Deletions are not supported yet."})}));const{PreparedStatement:re}=p;class ae{static async getBalance(t){const e=new re({name:`Utxos.getBalance.${Math.random()}`,text:'SELECT sum("satoshis") as "satoshis" FROM "Utxos" WHERE "address" = $1',values:[t]});const s=await Zt.oneOrNone(e);return parseInt(s?.satoshis,10)||0}static async select(t){const e=new re({name:`Utxos.select.${Math.random()}`,text:'SELECT "address", "satoshis", "scriptPubKey", "rev", split_part(rev, \':\', 1) AS "txId", cast(split_part(rev, \':\', 2) as INTEGER) AS "vout" FROM "Utxos" WHERE "address" = $1',values:[t]});return(await Zt.any(e)).map((t=>({...t,satoshis:parseInt(t.satoshis,10)||0,value:parseInt(t.satoshis,10)||0})))}static async selectByScriptHex(t){const e=new re({name:`Utxos.select.${Math.random()}`,text:'SELECT "address", "satoshis", "scriptPubKey", "rev", split_part(rev, \':\', 1) AS "txId", cast(split_part(rev, \':\', 2) as INTEGER) AS "vout" FROM "Utxos" WHERE "scriptPubKey" = $1',values:[t]});return(await Zt.any(e)).map((t=>({...t,satoshis:parseInt(t.satoshis,10)||0,value:parseInt(t.satoshis,10)||0})))}}class ne{static async getBalance(t){return ae.getBalance(t)}static async select(t){return ae.select(t)}static async selectByScriptHex(t){return ae.selectByScriptHex(t)}}class oe{static getBalance=async t=>ne.getBalance(t);static select=async t=>ne.select(t);static selectByScriptHex=async t=>ne.selectByScriptHex(t)}function ie(t){if(!/^[0-9A-Fa-f]{64}:\d+$/.test(t))throw new Error("Invalid rev")}const{PreparedStatement:ce}=p;class de{static async query(t){const{publicKey:e,hash:s,limit:r,offset:a,order:n,ids:o,mod:i}=t;if(r&&parseInt(r||"",10)>Kt||o&&o.length>Kt)throw new Error(`Can't fetch more than ${Kt} revs.`);if(n&&"ASC"!==n&&"DESC"!==n)throw new Error("Invalid order");let c='SELECT "rev"\n      FROM "NonStandard"\n      WHERE true ';const d=[];e&&(d.push(e),c+=` AND $${d.length} = ANY ("publicKeys")`),s&&(d.push(s),c+=` AND "hash" = $${d.length}`),i&&(d.push(i),c+=` AND "mod" = $${d.length}`),o&&o.length&&(o.map(ie),d.push(o),c+=` AND "id" = ANY ($${d.length})`),n&&(c+=` order by "lastUpdated" ${n}`),d.push(r||Kt),c+=` limit $${d.length}`,a&&(d.push(a),c+=` offset $${d.length}`);const l=new ce({name:`NonStandard.query.${Math.random()}`,text:c,values:d});return(await Zt.any(l)).map((t=>t.rev))}static async insert({id:t,rev:e,publicKeys:s,hash:r,mod:a}){const n=new ce({name:`NonStandard.insert.${Math.random()}`,text:'INSERT INTO "NonStandard"("id", "rev", "publicKeys", "hash", "mod") VALUES ($1, $2, $3, $4, $5) ON CONFLICT DO NOTHING',values:[t,e,s,r,a]});await Zt.none(n)}static async update({id:t,rev:e,publicKeys:s}){const r=new ce({name:`NonStandard.update.${Math.random()}`,text:'UPDATE "NonStandard" SET "rev"=$2, "publicKeys"=$3 WHERE "id" = $1',values:[t,e,s]});return Zt.none(r)}static async delete({rev:t}){const e=new ce({name:`NonStandard.delete.${Math.random()}`,text:'DELETE FROM "NonStandard" WHERE "rev" = $1',values:[t]});await Zt.none(e)}static async getRevsByIds(t){if(t&&t.length>Kt)throw new Error(`Can't fetch more than ${Kt} revs.`);const e=new ce({name:`NonStandard.getRevsByIds.${Math.random()}`,text:'SELECT "rev" FROM "NonStandard" WHERE "id" LIKE ANY($1)',values:[[t]]});return Zt.any(e)}static async select(t){const e=new ce({name:`NonStandard.select.${Math.random()}`,text:'SELECT "id", "hash", "mod" FROM "NonStandard" WHERE "rev" = $1',values:[t]});return Zt.oneOrNone(e)}}class le{static async select(t){return de.select(t)}static async query(t){return de.query(t)}static async getRevsByIds(t){return de.getRevsByIds(t)}static async insert(t){return de.insert(t)}static async update(t){return de.update(t)}static async delete(t){return de.delete({rev:t})}}class ue{static add=async t=>{const{zip:e,outData:s}=t;e.sort((([t],[e])=>!t&&e?-1:t&&e?0:t&&!e?1:0));for(let t=0;t<e.length;t+=1){const[r,a]=e[t];const{exp:n="",_owners:o=[],mod:i=""}=s[t]||{};if(!r&&a)ie(a),await le.insert({id:a,rev:a,publicKeys:o,hash:c.crypto.sha256(Buffer.from(n)).toString("hex"),mod:i});else if(r&&a){const{id:t,hash:e,mod:s}=await le.select(r)||{};await le.update({id:t,rev:a,publicKeys:o,hash:e,mod:s})}else r&&!a&&await le.delete(r)}};static query=async t=>le.query(t);static getRevsByIds=async t=>(await le.getRevsByIds(t)).map((t=>t.rev))}const pe=new f({protocol:xt,user:It,pass:Ot,host:Nt,port:Mt});const me=y.promisify(f.prototype.createwallet.bind(pe));const he=y.promisify(f.prototype.generateToAddress.bind(pe));const we=y.promisify(f.prototype.getaddressinfo.bind(pe));const ge=y.promisify(f.prototype.getBlock.bind(pe));const fe=y.promisify(f.prototype.getBlockchainInfo.bind(pe));const ye=y.promisify(f.prototype.getBlockHash.bind(pe));const Ee=y.promisify(f.prototype.getRawTransaction.bind(pe));const $e=y.promisify(f.prototype.getRawTransaction.bind(pe));const Te=y.promisify(f.prototype.getTransaction.bind(pe));const ve=y.promisify(f.prototype.getNewAddress.bind(pe));const Se={createwallet:me,generateToAddress:he,getaddressinfo:we,getBlock:ge,getBlockchainInfo:fe,getBlockHash:ye,getRawTransaction:Ee,getTransaction:Te,importaddress:y.promisify(f.prototype.importaddress.bind(pe)),listunspent:y.promisify(f.prototype.listunspent.bind(pe)),sendRawTransaction:y.promisify(f.prototype.sendRawTransaction.bind(pe)),getNewAddress:ve,sendToAddress:y.promisify(f.prototype.sendToAddress.bind(pe)),getRawTransactionJSON:$e};class be{static async getTransaction(t){const{result:e}=await Se.getTransaction(t);return e}static async getBulkTransactions(t){return(await Promise.all(t.map((t=>Se.getRawTransaction(t))))).map((t=>t.result))}static async getRawTransactionsJSON(t){return{txId:(e=(await Se.getRawTransactionJSON(t,1)).result).txid,txHex:e.hex,vsize:e.vsize,version:e.version,locktime:e.locktime,ins:e.vin.map((t=>({txId:t.txid,vout:t.vout,script:t.scriptSig.hex,sequence:t.sequence}))),outs:e.vout.map((t=>{let e;return t.scriptPubKey.addresses?[e]=t.scriptPubKey.addresses:e=t.scriptPubKey.address?t.scriptPubKey.address:void 0,{address:e,script:t.scriptPubKey.hex,value:Math.round(1e8*t.value)}}))};var e}static async sendRawTransaction(t){const{result:e,error:s}=await Se.sendRawTransaction(t);if(s)throw Jt.error(s),new Error("Error sending transaction");return e}static getUtxos=async t=>(void 0===(await Se.getaddressinfo(t)).result.timestamp&&(Jt.info(`Importing address: ${t}`),await Se.importaddress(t,!1)),(await Se.listunspent(0,999999,[t])).result)}class Re{static get=async t=>be.getTransaction(t);static getRaw=async t=>be.getBulkTransactions(t);static getRawJSON=async t=>be.getRawTransactionsJSON(t);static sendRaw=async t=>be.sendRawTransaction(t);static getUtxos=async t=>be.getUtxos(t)}const xe=new f({protocol:xt,user:It,pass:Ot,host:Nt,port:Mt});const Ie={};const Oe=JSON.parse(JSON.stringify(f.callspec));Object.keys(Oe).forEach((t=>{Oe[t.toLowerCase()]=Oe[t]}));const Ne={str:t=>t.toString(),string:t=>t.toString(),int:t=>parseFloat(t),float:t=>parseFloat(t),bool:t=>!0===t||"1"===t||1===t||"true"===t||"true"===t.toString().toLowerCase(),obj:t=>"string"==typeof t?JSON.parse(t):t};try{Object.keys(f.prototype).forEach((t=>{if(t&&"function"==typeof f.prototype[t]){const e=t.toLowerCase();Ie[t]=y.promisify(f.prototype[t].bind(xe)),Ie[e]=y.promisify(f.prototype[e].bind(xe))}}))}catch(t){Jt.error(`Error occurred while binding RPC methods: ${t.message}`)}const Me=t=>new Promise((e=>setTimeout(e,t)));const Ce=w(g);const Ae=c.networks.regtest;const{PreparedStatement:Pe}=p;class _e{static async select(t){const e=new Pe({name:`Input.select.${Math.random()}`,text:'SELECT "rev" FROM "Input" WHERE "rev" = $1',values:[t]});return Zt.any(e)}static async insert(t){const e=t.flatMap((t=>[t.rev]));for(;e.length;){const t=e.splice(0,Pt);const s=[];for(let e=1;e<=t.length;e+=1)s.push(`($${e})`);const r=s.join(",");const a=new Pe({name:`Input.insert.${Math.random()}`,text:`INSERT INTO "Input"("rev") VALUES ${r} ON CONFLICT DO NOTHING`,values:t});await Zt.none(a)}}static async count(t){const e=t.map((t=>t.rev));const s=new Pe({name:`Input.belong.${Math.random()}`,text:'SELECT count(*) FROM "Input" WHERE "rev" LIKE ANY ($1)',values:[[e]]});const r=await Zt.oneOrNone(s);return parseInt(r?.count,10)||0}}class je{static async select(t){return _e.select(t)}static async insert(t){return _e.insert(t)}}class He{static getNonCoinbaseRevs=t=>{const e=t.filter((t=>!d.isCoinbaseHash(t.hash))).map((({hash:t,index:e})=>({rev:`${c.bufferUtils.reverseBuffer(Buffer.from(t)).toString("hex")}:${e}`})));return e};static insert=async t=>je.insert(this.getNonCoinbaseRevs(t))}const{PreparedStatement:Be}=p;class De{static async select(t){const e=new Be({name:`Output.select.${Math.random()}`,text:'SELECT "address", "satoshis", "scriptPubKey", "rev" FROM "Output" WHERE "address" = $1',values:[t]});return Zt.any(e)}static async insert(t){const e=t.flatMap((t=>[t.rev,t.address,t.satoshis,t.scriptPubKey]));for(;e.length;){const t=e.splice(0,Pt);const s=[];for(let e=1;e<=t.length;e+=4)s.push(`($${e}, $${e+1}, $${e+2}, $${e+3})`);const r=s.join(",");const a=new Be({name:`Output.insert.${Math.random()}`,text:`INSERT INTO "Output"("rev", "address", "satoshis", "scriptPubKey") VALUES ${r}  ON CONFLICT DO NOTHING`,values:t});await Zt.none(a)}}}class ke{static async select(t){return De.select(t)}static async insert(t){return De.insert(t)}}class Le{static insert=async t=>{const e=t.flatMap((t=>t.tx.outs.map(((e,s)=>{const{script:r}=e;let a;try{a=c.address.fromOutputScript(r,function(t,e){switch(gt){case"BTC":return"mainnet"===e?c.networks.bitcoin:c.networks.testnet;case"LTC":return"mainnet"===e?c.networks.litecoin:c.networks.litecoinregtest;default:throw new Error("We currently only support BTC and LTC, support for other currencies will be added soon.")}}(0,ft))}catch(t){a=null}const n=r.toString("hex");const o=Math.round(e.value);return{address:a,rev:`${t.txId}:${s}`,scriptPubKey:n,satoshis:o}}))));return ke.insert(e)}}let Ke;try{Ke=new E({chain:gt,network:ft,url:Et})}catch(t){Jt.error(`Error creating computer, ${t.message}`),process.exit(1)}class Ye{static syncTx=async t=>{await Le.insert([t]),await He.insert(t.tx.ins),t.isBcTx(gt,ft)&&await ue.add(t)};static rawTxSubscriber=async t=>{try{const e=t.toString("hex");Jt.info(`ZMQ message { rawTx:${e} }`);const s=await Ke.txFromHex({hex:e});try{await this.syncTx(s)}catch(t){Jt.error(`Error parsing transaction ${t.message} ${t.stack}`)}}catch(t){Jt.error(`RawTxSubscriber failed with error '${t.message} ${t.stack}'`)}};static checkSyncStatus=async()=>{const t=await h((async()=>{const t=await Se.getBlockchainInfo();const e=(100*parseFloat(t.result.verificationprogress)).toFixed(4);const{blocks:s}=t.result;if(Jt.info(`Zmq. Bitcoind { percentage:${e}%, blocks:${s} }`),parseFloat(t.result.verificationprogress)<=Lt)throw new Error("Node not ready yet");return t}),{startingDelay:6e4,timeMultiple:1,numOfAttempts:8760});const e=(100*parseFloat(t.result.verificationprogress)).toFixed(4);const s=t.result.blocks;Jt.info(`BCN reaches sync end...at { bitcoind.progress:${e}%, bitcoindSyncedHeight:${s} }`)};static createWallet=async()=>{try{await Se.createwallet(At)}catch(t){Jt.debug(`Wallet creation failed with error '${t.message}'`)}};static sub=async t=>{try{await this.createWallet(),"regtest"!==ft&&await this.checkSyncStatus(),await(async()=>{if("LTC"===gt&&"regtest"===ft){Jt.info(`Node is starting for chain ${gt} and network ${ft}, \n\n Starting MWEB setup.`);const{result:t}=await Se.getBlockchainInfo();const e=t.blocks;if(e<Dt){const{result:t}=await Se.getNewAddress("","legacy");const s=Dt-e-1;s&&await Se.generateToAddress(s,t);const{result:r}=await Se.getNewAddress("mweb","mweb");await Se.sendToAddress(r,1),await Se.generateToAddress(1,t)}Jt.info("MWEB setup is complete")}})(),Jt.info(`Bitcoin Computer Node ${Ct} is ready. MAX_BLOCKCHAIN_HEIGHT: ${Bt}`);for await(const[,e]of t)await this.rawTxSubscriber(e)}catch(t){Jt.error(`ZMQ subscription failed with error '${t.message}'`)}}}const{PreparedStatement:Ue}=p;class Fe{static async select(t){const e=new Ue({name:`User.select.${Math.random()}`,text:'SELECT "publicKey", "clientTimestamp" FROM "User" WHERE "publicKey" = $1',values:[t]});const s=await Zt.oneOrNone(e);return s?{publicKey:s.publicKey,clientTimestamp:parseInt(s.clientTimestamp,10)||0}:null}static async insert({publicKey:t,clientTimestamp:e}){const s=new Ue({name:`User.insert.${Math.random()}`,text:'INSERT INTO "User"("publicKey", "clientTimestamp") VALUES ($1, $2)',values:[t,e]});await Zt.none(s)}static async update({publicKey:t,clientTimestamp:e}){const s=new Ue({name:`User.update.${Math.random()}`,text:'UPDATE "User" SET "clientTimestamp"=$1 WHERE "publicKey"=$2',values:[e,t]});await Zt.none(s)}}class We{static async select(t){return Fe.select(t)}static async insert(t){return Fe.insert(t)}static async update(t){return Fe.update(t)}}const{ec:Ge}=$;const qe=new Ge("secp256k1");const Je=s();const ze=new class{configFile;loaded=!1;load=()=>{try{const t=zt()?"bcn.test.config.json":"bcn.config.json";const e=S(b(import.meta.url));this.configFile=i.readFileSync(v.join(e,"..","..",t)),this.loaded=!0}catch(t){if(t.message.includes("ENOENT: no such file or directory"))return void(this.loaded=!0);throw Jt.error(`Access-list failed with error '${t.message}'`),t}};middleware=({url:t},e,s)=>{if(void 0!==e.locals.authToken)if(this.loaded||(Jt.warn("Access-list failed with error 'AccessList not loaded.'. Loading now."),this.load()),void 0!==this.configFile)try{const{blacklist:t,whitelist:r}=JSON.parse(this.configFile.toString());if(t&&r)return void e.status(403).json({error:"Cannot enforce blacklist and whitelist at the same time."});const{publicKey:a}=e.locals.authToken;if(r&&!r.includes(a)||t&&t.includes(a))return void e.status(403).json({error:`Public key ${a} is not allowed.`});s()}catch(s){Jt.error(`Authorization failed at ${t} with error: '${s.message}'`),e.status(403).json({error:s.message})}else s();else s()}};let Ve;try{Ve=r.createServer(Je)}catch(t){throw Jt.error(`Starting server failed with error '${t.message}'`),t}if(Jt.info(`Server listening on port ${ht}`),Je.use(e()),"dev"!==yt){const t=n({windowMs:9e5,max:300,standardHeaders:!0,legacyHeaders:!1});Je.use(t)}Je.use(t.json({limit:"100mb"})),Je.use(t.urlencoded({limit:"100mb",extended:!0})),Je.get("/",((t,e)=>e.status(200).send(`<h2>Bitcoin Computer Node</h2> <b>Status</b> healthy <br /><b>Version</b> ${Ct}`))),ze.loaded&&(Je.use((async(t,e,s)=>{try{const r=t.get("Authentication");if(!r){const{method:s,url:r}=t;const a=`Auth failed with error 'no Authentication key provided' ${s} ${t.get("Host")} ${r}`;return Jt.error(a),void e.status(401).json({error:a})}const a=(t=>{const e=t.split(" ");if(2!==e.length||"Bearer"!==e[0])throw new Error("Authentication header is invalid.");const s=Buffer.from(e[1],"base64").toString().split(":");if(3!==s.length)throw new Error;return{signature:s[0],publicKey:s[1],timestamp:parseInt(s[2],10)}})(r);const{signature:n,publicKey:o,timestamp:i}=a;if(Date.now()-i>1e3*jt*60)return void e.status(401).json({error:"Signature is too old."});const c=T.sha256().update(Et+i).digest("hex");if(!qe.keyFromPublic(o,"hex").verify(c,n)){const t="The origin and public key pair doesn't match the signature.";return void e.status(401).json({error:t})}const d=await We.select(o);if(d){if(d.clientTimestamp>=i)return void e.status(401).json({error:"Please use a fresh authentication token."});await We.update({publicKey:o,clientTimestamp:i})}else await We.insert({publicKey:o,clientTimestamp:i});e.locals.authToken=a,s()}catch(t){Jt.error(`Auth failed with error '${t.message}'`),e.status(401).json({error:t.message})}})),Je.use(ze.middleware));const Ze=(()=>{const t=s.Router();return t.get("/wallet/:address/utxos",(async({params:t,url:e},s)=>{try{const{address:e}=t;s.status(200).json(await oe.select(e))}catch(t){Jt.error(`GET ${e} failed with error '${t.message}'`),s.status(404).json({error:t.message})}})),t.get("/non-standard-utxos",(async(t,e)=>{try{const s=new URLSearchParams(t.url.split("?")[1]);const r={mod:s.get("mod"),publicKey:s.get("publicKey"),hash:s.get("hash"),limit:s.get("limit"),order:s.get("order"),offset:s.get("offset"),ids:JSON.parse(s.get("ids")?.toString()||"[]")};const a=await ue.query(r);e.status(200).json(a)}catch(s){Jt.error(`GET ${t.url} failed with error '${s.messages}'`),e.status(404).json({error:s.message})}})),t.get("/address/:address/balance",(async({params:t,url:e},s)=>{try{const{address:e}=t;s.status(200).json(await oe.getBalance(e))}catch(t){Jt.error(`GET ${e} failed with error '${t.message}'`),s.status(404).json({error:t.message})}})),t.post("/tx/bulk",(async({body:{txIds:t},url:e},s)=>{try{if(void 0===t||0===t.length)return void s.status(500).json({error:"Missing input txIds."});const e=await Re.getRaw(t);e?s.status(200).json(e):s.status(404).json({error:"Not found"})}catch(t){Jt.error(`POST ${e} failed with error '${t.message}'`),s.status(500).json({error:t.message})}})),t.post("/tx/post",(async({body:{hex:t},url:e},s)=>{try{if(!t)return void s.status(500).json({error:"Missing input hex."});const e=await Re.sendRaw(t);e?s.status(200).json(e):s.status(404).json({error:"Error Occured"})}catch(t){Jt.error(`GET ${e} failed with error '${t.message}'`),s.status(500).json({error:t.message})}})),t.get("/mine",(async({query:{count:t},url:e},s)=>{try{const{result:e}=await Ie.getnewaddress();if("string"!=typeof t)throw new Error("Please provide appropriate count");return await Ie.generatetoaddress(parseInt(t,10)||1,e),s.status(200).json({success:!0})}catch(t){return Jt.error(`POST ${e} failed with error '${t.message}'`),s.status(500).json({error:t.message})}})),t.get("/:id/height",(async({params:{id:t},url:e},s)=>{try{let e=t;if("best"===t){const{result:t}=await Ie.getbestblockhash();e=t}const{result:r}=await Ie.getblockheader(e,!0);return s.status(200).json({height:r.height})}catch(t){return Jt.error(`POST ${e} failed with error '${t.message}'`),s.status(500).json({error:t.message})}})),t.post("/faucet",(async({body:{address:t,value:e},url:s},r)=>{try{const s=(await Ie.sendtoaddress(t,parseInt(e,10)/1e8,"","")).result;const a=(await Ie.getrawtransaction(s,1)).result.vout.findIndex((t=>1e8*t.value===parseInt(e,10)));return r.status(200).json({txId:s,vout:a,height:-1,value:e})}catch(t){return Jt.error(`POST ${s} failed with error '${t.message}'`),r.status(500).json({error:t.message})}})),t.post("/faucetScript",(async({body:{script:t,value:e},url:s},r)=>{try{const s=Ce.makeRandom({network:Ae});const a=c.payments.p2pkh({pubkey:s.publicKey,network:Ae});const{address:n}=a;const o=(await Ie.sendtoaddress(n,2*parseInt(e,10)/1e8,"","")).result;let i;let d=10;for(;!i;)if(i=(await oe.select(n)).filter((t=>t.txId===o))[0],!i){if(d-=1,d<=0)throw new Error("No outputs");await Me(10)}const l=(await Ie.getrawtransaction(i.txId,1)).result;const u=new c.Psbt({network:Ae});u.addInput({hash:i.txId,index:i.vout,nonWitnessUtxo:Buffer.from(l.hex,"hex")}),u.addOutput({script:Buffer.from(t,"hex"),value:parseInt(e,10)}),u.signInput(0,s),u.finalizeAllInputs();const p=u.extractTransaction();let m;for(await Ie.sendrawtransaction(p.toHex()),d=5;!m;)if(m=(await oe.selectByScriptHex(t)).filter((t=>t.txId===p.getId()))[0],!m){if(d-=1,d<=0)throw new Error("No outputs");await Me(10)}return r.status(200).json({txId:p.getId(),vout:m.vout,height:-1,value:m.value})}catch(t){return Jt.error(`POST ${s} failed with error '${t.message}'`),r.status(500).json({error:t.message})}})),t.get("/tx/:txId/json",(async({params:{txId:t},url:e},s)=>{try{if(!t)return void s.status(500).json({error:"Missing input txId."});const e=await Re.getRawJSON(t);e?s.status(200).json(e):s.status(404).json({error:"Not found"})}catch(t){Jt.error(`GET ${e} failed with error '${t.message}'`),s.status(500).json({error:t.message})}})),t.post("/revs",(async({body:{ids:t},url:e},s)=>{try{if(void 0===t||0===t.length)return void s.status(404).json({error:"Missing input object ids."});const e=await ue.getRevsByIds(t);s.status(200).json(e)}catch(t){Jt.error(`POST ${e} failed with error '${t.message}'`),s.status(404).json({error:t.message})}})),t.post("/rpc",(async({body:t,url:e},s)=>{try{if(!t||!t.method)throw new Error("Please provide appropriate RPC method name");if(!Ht.some((e=>e.test(t.method))))throw new Error("Method is not allowed");const e=function(t,e){if(void 0===Oe[t]||null===Oe[t])throw new Error("This RPC method does not exist, or not supported");const s=e.trim().split(" ");const r=Oe[t].trim().split(" ");if(0===e.trim().length&&0!==Oe[t].trim().length)throw new Error(`Too few params provided. Expected ${r.length} Provided 0`);if(0!==e.trim().length&&0===Oe[t].trim().length)throw new Error(`Too many params provided. Expected 0 Provided ${s.length}`);if(s.length<r.length)throw new Error(`Too few params provided. Expected ${r.length} Provided ${s.length}`);if(s.length>r.length)throw new Error(`Too many params provided. Expected ${r.length} Provided ${s.length}`);return 0===e.length?[]:s.map(((t,e)=>Ne[r[e]](t)))}(t.method,t.params);const r=e.length?await Ie[t.method](...e):await Ie[t.method]();s.status(200).json({result:r})}catch(t){Jt.error(`POST ${e} failed with error '${t.message}'`),s.status(404).json({error:t.message})}})),t.post("/non-standard-utxo",(async(t,e)=>{e.status(500).json({error:"Please upgrade to @bitcoin-computer/lib to the latest version."})})),t})();Je.use(`/v1/${gt}/${ft}`,Ze),Je.use("/v1/store",se),Ve.listen(ht,(()=>{Jt.info(`Rev ${Ct} Started web server on port ${ht} BC_START_HEIGHT ${kt}`)})).on("error",(t=>{Jt.error(t.message),process.exit(1)}));const Xe=new a.Subscriber;Xe.connect(wt),Xe.subscribe("rawtx"),Jt.info(`ZMQ Subscriber connected to ${wt}`),(async()=>{await(async()=>{await h((()=>Zt.connect()),{startingDelay:_t})})(),await Ye.sub(Xe)})();
