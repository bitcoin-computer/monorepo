import{backOff as t}from"exponential-backoff";import{Computer as e}from"@bitcoin-computer/lib";import s from"dotenv";import n from"fs";import a,{Transaction as r}from"@bitcoin-computer/nakamotojs-lib";import o from"winston";import i from"winston-daily-rotate-file";import c from"bitcoind-rpc";import d from"util";import l from"pg-promise";import p from"pg-monitor";s.config();const m=JSON.parse(n.readFileSync("package.json","utf8"));const{PORT:y,ZMQ_URL:u,CHAIN:h,NETWORK:f,BCN_ENV:g,BCN_URL:w,DEBUG_MODE:E,POSTGRES_USER:S,POSTGRES_PASSWORD:$,POSTGRES_DB:R,POSTGRES_HOST:T,POSTGRES_PORT:N,RPC_PROTOCOL:I,RPC_USER:O,RPC_PASSWORD:v,RPC_HOST:M,RPC_PORT:b,SERVER_VERSION:C,DEFAULT_WALLET:_,SYNC_INTERVAL_CHECK:A,POSTGRES_MAX_PARAM_NUM:H,DB_CONNECTION_RETRY_TIME:D,SIGNATURE_FRESHNESS_MINUTES:k,ALLOWED_RPC_METHODS:x,NODE_MAX_PROGRESS:P,SYNC_MAX_PROGRESS:Y,MAX_BLOCKCHAIN_HEIGHT:B,MWEB_HEIGHT:L,BC_START_HEIGHT:F,WORKER_ID:W,NUM_WORKERS:U,SYNC_NON_STANDARD:G,ZMQ_WAIT_PERCENTAGE:K,QUERY_LIMIT:j,LOG_MAX_FILE_SIZE:V,LOG_MAX_FILE_NUM:z,LOG_ZIP:q,RPC_URL:X,RPC_BATCHSIZE:Z,RPC_CONCURRENT:J,INDEXDB:Q,KEYDB:tt}=process.env;const et=h||"LTC";const st=f||"regtest";const nt=g||"dev";const at=w||"http://127.0.0.1:3000";const rt=parseInt(E,10)||1;const ot=S||"bcn";const it=$||"bcn";const ct=R||"bcn";const dt=T||"127.0.0.1";const lt=parseInt(N,10)||"5432";const pt=I||"http";const mt=O||"bcn-admin";const yt=v||"kH4nU5Okm6-uyC0_mA5ztVNacJqZbYd_KGLl6mx722A=";const ut=M||"node";const ht=parseInt(b,10)||19332;m.version;const ft=parseInt(H,10)||1e4;const gt=parseInt(D,10)||500;!x||x.split(",").map((t=>new RegExp(t)));const wt=parseInt(F||"",10)||25e5;const Et=parseInt(W,10)||1;const St=parseInt(U||"",10)||1;const $t="true"===G||!1;const Rt=parseInt(j||"",10)||100;const Tt=V||"20m";const Nt=z||"14d";const It=!!q;o.addColors({error:"red",warn:"yellow",info:"green",http:"magenta",debug:"white"});const Ot=o.format.combine(o.format.colorize(),o.format.timestamp({format:"YYYY-MM-DD HH:mm:ss:ms"}),o.format.json(),o.format.printf((t=>`${t.timestamp} [${t.level.slice(5).slice(0,-5)}] ${t.message}`)));const vt={zippedArchive:It,maxSize:Tt,maxFiles:Nt,dirname:"logs"};const Mt=[];"dev"===nt&&Mt.push(new o.transports.Console({format:o.format.combine(o.format.colorize(),o.format.timestamp({format:"MM-DD-YYYY HH:mm:ss"}),o.format.printf((t=>`${t.timestamp} ${t.level} ${t.message}`)))})),rt>=0&&Mt.push(new i({filename:"error-%DATE%.log",datePattern:"YYYY-MM-DD",level:"error",...vt})),rt>=1&&Mt.push(new i({filename:"warn-%DATE%.log",datePattern:"YYYY-MM-DD",level:"warn",...vt})),rt>=2&&Mt.push(new i({filename:"info-%DATE%.log",datePattern:"YYYY-MM-DD",level:"info",...vt})),rt>=3&&Mt.push(new i({filename:"http-%DATE%.log",datePattern:"YYYY-MM-DD",level:"http",...vt})),rt>=4&&Mt.push(new i({filename:"debug-%DATE%.log",datePattern:"YYYY-MM-DD",level:"debug",...vt})),Mt.push(new i({filename:"logs-%DATE%.log",datePattern:"YYYY-MM-DD"}));const bt=o.createLogger({levels:{error:0,warn:1,info:2,http:3,debug:4},format:Ot,transports:Mt,exceptionHandlers:[new o.transports.File({filename:"logs/exceptions.log"})],rejectionHandlers:[new o.transports.File({filename:"logs/rejections.log"})]});const Ct=new c({protocol:pt,user:mt,pass:yt,host:ut,port:ht});const _t=d.promisify(c.prototype.createwallet.bind(Ct));const At=d.promisify(c.prototype.generateToAddress.bind(Ct));const Ht=d.promisify(c.prototype.getaddressinfo.bind(Ct));const Dt=d.promisify(c.prototype.getBlock.bind(Ct));const kt=d.promisify(c.prototype.getBlockchainInfo.bind(Ct));const xt=d.promisify(c.prototype.getBlockHash.bind(Ct));const Pt=d.promisify(c.prototype.getRawTransaction.bind(Ct));const Yt=d.promisify(c.prototype.getRawTransaction.bind(Ct));const Bt=d.promisify(c.prototype.getTransaction.bind(Ct));const Lt=d.promisify(c.prototype.getNewAddress.bind(Ct));const Ft={createwallet:_t,generateToAddress:At,getaddressinfo:Ht,getBlock:Dt,getBlockchainInfo:kt,getBlockHash:xt,getRawTransaction:Pt,getTransaction:Bt,importaddress:d.promisify(c.prototype.importaddress.bind(Ct)),listunspent:d.promisify(c.prototype.listunspent.bind(Ct)),sendRawTransaction:d.promisify(c.prototype.sendRawTransaction.bind(Ct)),getNewAddress:Lt,sendToAddress:d.promisify(c.prototype.sendToAddress.bind(Ct)),getRawTransactionJSON:Yt};const Wt={error:(t,e)=>{if(e.cn){const{host:s,port:n,database:a,user:r,password:o}=e.cn;bt.debug(`Waiting for db to start { message:${t.message} host:${s}, port:${n}, database:${a}, user:${r}, password: ${o}`)}},noWarnings:!0};"dev"===nt&&rt>0&&(p.isAttached()?p.detach():(p.attach(Wt),p.setTheme("matrix")));const Ut=l(Wt)({host:dt,port:lt,database:ct,user:ot,password:it,allowExitOnIdle:!0,idleTimeoutMillis:100});const{PreparedStatement:Gt}=l;class Kt{static async select(t){const e=new Gt({name:`SyncStatus.select.${Math.random()}`,text:'SELECT "syncedHeight" FROM "SyncStatus" WHERE "workerId" = $1',values:[t]});return Ut.one(e)}static async update({syncedHeight:t,workerId:e}){const s=new Gt({name:`SyncStatus.update.${Math.random()}`,text:'UPDATE "SyncStatus" SET "syncedHeight" = $1 WHERE "workerId" = $2',values:[t,e]});await Ut.any(s)}static async insert({syncedHeight:t,workerId:e}){const s=new Gt({name:`SyncStatus.insert.${Math.random()}`,text:'INSERT INTO  "SyncStatus"("syncedHeight","workerId") VALUES ($1, $2) ON CONFLICT DO NOTHING',values:[t,e]});await Ut.any(s)}}class jt{static async select(t){return Kt.select(t)}static async update(t){await Kt.update(t)}static async insert(t){await Kt.insert(t)}}class Vt{static updateSync=async t=>jt.update(t);static selectSync=async t=>jt.select(t);static insertSync=async t=>jt.insert(t)}function zt(t){if(!/^[0-9A-Fa-f]{64}:\d+$/.test(t))throw new Error("Invalid rev")}const{PreparedStatement:qt}=l;class Xt{static async query(t){const{publicKey:e,hash:s,limit:n,offset:a,order:r,ids:o,mod:i}=t;if(n&&parseInt(n||"",10)>Rt||o&&o.length>Rt)throw new Error(`Can't fetch more than ${Rt} revs.`);if(r&&"ASC"!==r&&"DESC"!==r)throw new Error("Invalid order");let c='SELECT "rev"\n      FROM "NonStandard"\n      WHERE true ';const d=[];e&&(d.push(e),c+=` AND $${d.length} = ANY ("publicKeys")`),s&&(d.push(s),c+=` AND "hash" = $${d.length}`),i&&(d.push(i),c+=` AND "mod" = $${d.length}`),o&&o.length&&(o.map(zt),d.push(o),c+=` AND "id" = ANY ($${d.length})`),r&&(c+=` order by "lastUpdated" ${r}`),d.push(n||Rt),c+=` limit $${d.length}`,a&&(d.push(a),c+=` offset $${d.length}`);const l=new qt({name:`NonStandard.query.${Math.random()}`,text:c,values:d});return(await Ut.any(l)).map((t=>t.rev))}static async insert({id:t,rev:e,publicKeys:s,hash:n,mod:a}){const r=new qt({name:`NonStandard.insert.${Math.random()}`,text:'INSERT INTO "NonStandard"("id", "rev", "publicKeys", "hash", "mod") VALUES ($1, $2, $3, $4, $5) ON CONFLICT DO NOTHING',values:[t,e,s,n,a]});await Ut.none(r)}static async update({id:t,rev:e,publicKeys:s}){const n=new qt({name:`NonStandard.update.${Math.random()}`,text:'UPDATE "NonStandard" SET "rev"=$2, "publicKeys"=$3 WHERE "id" = $1',values:[t,e,s]});return Ut.none(n)}static async delete({rev:t}){const e=new qt({name:`NonStandard.delete.${Math.random()}`,text:'DELETE FROM "NonStandard" WHERE "rev" = $1',values:[t]});await Ut.none(e)}static async getRevsByIds(t){if(t&&t.length>Rt)throw new Error(`Can't fetch more than ${Rt} revs.`);const e=new qt({name:`NonStandard.getRevsByIds.${Math.random()}`,text:'SELECT "rev" FROM "NonStandard" WHERE "id" LIKE ANY($1)',values:[[t]]});return Ut.any(e)}static async select(t){const e=new qt({name:`NonStandard.select.${Math.random()}`,text:'SELECT "id", "hash", "mod" FROM "NonStandard" WHERE "rev" = $1',values:[t]});return Ut.oneOrNone(e)}}class Zt{static async select(t){return Xt.select(t)}static async query(t){return Xt.query(t)}static async getRevsByIds(t){return Xt.getRevsByIds(t)}static async insert(t){return Xt.insert(t)}static async update(t){return Xt.update(t)}static async delete(t){return Xt.delete({rev:t})}}class Jt{static add=async t=>{const{zip:e,outData:s}=t;e.sort((([t],[e])=>!t&&e?-1:t&&e?0:t&&!e?1:0));for(let t=0;t<e.length;t+=1){const[n,r]=e[t];const{exp:o="",_owners:i=[],mod:c=""}=s[t]||{};if(!n&&r)zt(r),await Zt.insert({id:r,rev:r,publicKeys:i,hash:a.crypto.sha256(Buffer.from(o)).toString("hex"),mod:c});else if(n&&r){const{id:t,hash:e,mod:s}=await Zt.select(n)||{};await Zt.update({id:t,rev:r,publicKeys:i,hash:e,mod:s})}else n&&!r&&await Zt.delete(n)}};static query=async t=>Zt.query(t);static getRevsByIds=async t=>(await Zt.getRevsByIds(t)).map((t=>t.rev))}const{PreparedStatement:Qt}=l;class te{static async select(t){const e=new Qt({name:`Input.select.${Math.random()}`,text:'SELECT "rev" FROM "Input" WHERE "rev" = $1',values:[t]});return Ut.any(e)}static async insert(t){const e=t.flatMap((t=>[t.rev]));for(;e.length;){const t=e.splice(0,ft);const s=[];for(let e=1;e<=t.length;e+=1)s.push(`($${e})`);const n=s.join(",");const a=new Qt({name:`Input.insert.${Math.random()}`,text:`INSERT INTO "Input"("rev") VALUES ${n} ON CONFLICT DO NOTHING`,values:t});await Ut.none(a)}}static async count(t){const e=t.map((t=>t.rev));const s=new Qt({name:`Input.belong.${Math.random()}`,text:'SELECT count(*) FROM "Input" WHERE "rev" LIKE ANY ($1)',values:[[e]]});const n=await Ut.oneOrNone(s);return parseInt(n?.count,10)||0}}class ee{static async select(t){return te.select(t)}static async insert(t){return te.insert(t)}}class se{static getNonCoinbaseRevs=t=>t.filter((t=>!r.isCoinbaseHash(t.hash))).map((({hash:t,index:e})=>({rev:`${a.bufferUtils.reverseBuffer(Buffer.from(t)).toString("hex")}:${e}`})));static insert=async t=>ee.insert(this.getNonCoinbaseRevs(t))}const{PreparedStatement:ne}=l;class ae{static async select(t){const e=new ne({name:`Output.select.${Math.random()}`,text:'SELECT "address", "satoshis", "scriptPubKey", "rev" FROM "Output" WHERE "address" = $1',values:[t]});return Ut.any(e)}static async insert(t){const e=t.flatMap((t=>[t.rev,t.address,t.satoshis,t.scriptPubKey]));for(;e.length;){const t=e.splice(0,ft);const s=[];for(let e=1;e<=t.length;e+=4)s.push(`($${e}, $${e+1}, $${e+2}, $${e+3})`);const n=s.join(",");const a=new ne({name:`Output.insert.${Math.random()}`,text:`INSERT INTO "Output"("rev", "address", "satoshis", "scriptPubKey") VALUES ${n}  ON CONFLICT DO NOTHING`,values:t});await Ut.none(a)}}}class re{static async select(t){return ae.select(t)}static async insert(t){return ae.insert(t)}}class oe{static insert=async t=>{const e=t.flatMap((t=>t.tx.outs.map(((e,s)=>{const{script:n}=e;let r;try{r=a.address.fromOutputScript(n,function(t,e){switch(et){case"BTC":return"mainnet"===e?a.networks.bitcoin:a.networks.testnet;case"LTC":return"mainnet"===e?a.networks.litecoin:a.networks.litecoinregtest;default:throw new Error("We currently only support BTC and LTC, support for other currencies will be added soon.")}}(0,st))}catch(t){r=null}const o=n.toString("hex");const i=Math.round(e.value);return{address:r,rev:`${t.txId}:${s}`,scriptPubKey:o,satoshis:i}}))));return re.insert(e)}}const ie=new e({chain:et,network:st,url:at});class ce{static waitForBlock=async e=>{await t((async()=>{bt.info(`Sync workerId ${Et}: waiting for block ${e} ...`),await Ft.getBlockHash(e)}),{startingDelay:3e4,timeMultiple:1,numOfAttempts:720}),bt.info(`Node is ready. Starting Sync actions for worker ${Et}`)};static syncBlock=async t=>{const{result:e}=await Ft.getBlockHash(t);const{result:s}=await Ft.getBlock(e,2);const{tx:n}=s;bt.info(`Backfilling progress ${t} Backfilling ${n.length} transactions...`);const a=await Promise.allSettled(n.map((t=>ie.txFromHex({hex:t.hex}))));const r=a.filter((t=>"fulfilled"===t.status)).map((t=>t.value));const o=a.filter((t=>"rejected"===t.status)).map((t=>t.reason));var i,c;o.length&&bt.error(`Failed to parse ${o.length} transactions of block num ${t}: ${o.map((t=>t)).join(", ")}\n        Failed txs: ${i=n.map((t=>t.id)),c=r.map((t=>t.tx.getId())),i.filter((t=>-1===c.indexOf(t)))}`),await this.syncTxs(r,t)};static sync=async(t,e,s,n)=>{try{let a=e;const r=await Vt.selectSync(t);for(r.syncedHeight>e&&(a=r.syncedHeight+s),bt.info(`Starting sync process { initialBlock: ${e} increment: ${s} nonStandard: ${n} syncedHeight:${r.syncedHeight}, currentBlockHeight:${a} }`);n||a<wt;)try{await this.syncBlock(a),await Vt.updateSync({syncedHeight:a,workerId:t}),a+=s}catch(t){t.message.includes("out of range")||bt.error(`Syncing block num ${a} failed with error '${t.message}'`)}}catch(t){bt.error(`Sync action failed with error '${t.message}'`)}};static syncTxs=async(t,e)=>{try{await oe.insert(t),await se.insert(t.flatMap((t=>t.tx.ins))),e>=wt&&t.map((async t=>{try{t.isBcTx(et,st)&&await Jt.add(t)}catch(e){bt.error(`Failed to add non-standard tx ${t.tx.getId()} ${e.message}`)}}))}catch(t){bt.error(`Processing block ${e} failed with error '${t.message}'`)}};static register=async t=>{try{await Vt.insertSync({syncedHeight:-1,workerId:t}),bt.info(`Register workerId: '${t}'`)}catch(t){bt.error(`Register action failed with error '${t.message}'`)}}}!function(){try{const e=`Synchronizing { nonStandard:${$t} url: ${at}, chain:${et} network:${st} numWorkers: ${St} workerId: ${Et} }`;bt.info(e),"regtest"!==st&&(async()=>{if(await(async()=>{await t((()=>Ut.connect()),{startingDelay:gt})})(),await ce.register(Et),$t)await ce.waitForBlock(wt),await ce.sync(Et,wt,1,$t);else{const t=await Vt.selectSync(Et);const e=t.syncedHeight>0?t.syncedHeight+1:Et;bt.info(`Worker ${Et} waiting for block ${e}...`),await ce.waitForBlock(e),bt.info(`Worker ${Et} starting sync on block ${e}...`),await ce.sync(Et,e,St,!1)}})()}catch(t){bt.error(`Synchronizing failed with error '${t.message}'`)}}();
