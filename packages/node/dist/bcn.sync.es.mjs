import*as t from"@bitcoin-computer/secp256k1";import{bufferUtils as e,networks as s,Transaction as n,crypto as a,address as r,initEccLib as o}from"@bitcoin-computer/nakamotojs";import i from"node:cluster";import{availableParallelism as c}from"node:os";import{backOff as p}from"exponential-backoff";import{Computer as u}from"@bitcoin-computer/lib";import d from"dotenv";import l from"fs";import m from"winston";import y from"winston-daily-rotate-file";import h from"bitcoind-rpc";import v from"util";import E from"pg-promise";import w from"pg-monitor";d.config();const $=process.env.CHAIN;const S=process.env.NETWORK;const{PORT:f}=process.env;const{POSTGRES_USER:O}=process.env;const{POSTGRES_PASSWORD:g}=process.env;const{POSTGRES_DB:R}=process.env;const{POSTGRES_HOST:I}=process.env;const{POSTGRES_PORT:T}=process.env;const{RPC_USER:M}=process.env;const{RPC_PASSWORD:b}=process.env;process.env;const{RPC_HOST:x}=process.env;const{RPC_PORT:N}=process.env;const{RPC_PROTOCOL:L}=process.env;process.env,process.env,process.env;const{DEBUG_MODE:C}=process.env;const{LOG_MAX_FILES:k}=process.env;const{LOG_MAX_SIZE:P}=process.env;const{LOG_ZIP:A}=process.env;const{SHOW_CONSOLE_LOGS:B}=process.env;const{SHOW_DB_LOGS:D}=process.env;process.env,process.env,process.env,process.env,process.env;const{THREADS:H}=process.env;process.env,process.env;const Y=process.env.QUERY_LIMIT||"1000";const F=process.env.BCN_URL||`http://127.0.0.1:${f}`;process.env.BCN_ENV,d.config();const{version:U}=JSON.parse(l.readFileSync("package.json","utf8"));U||process.env.SERVER_VERSION,parseInt(process.env.MWEB_HEIGHT||"",10),m.addColors({error:"red",warn:"yellow",info:"green",http:"magenta",debug:"white"});const W=m.format.combine(m.format.colorize(),m.format.timestamp({format:"YYYY-MM-DD HH:mm:ss:ms"}),m.format.json(),m.format.printf((t=>`${t.timestamp} [${t.level.slice(5).slice(0,-5)}] ${t.message}`)));const _={zippedArchive:"true"===A,maxSize:P,maxFiles:k,dirname:"logs"};const K=[];"true"===B&&K.push(new m.transports.Console({format:m.format.combine(m.format.colorize(),m.format.timestamp({format:"MM-DD-YYYY HH:mm:ss"}),m.format.printf((t=>`${t.timestamp} ${t.level} ${t.message}`)))}));const G=parseInt(C,10);G>=0&&K.push(new y({filename:"error-%DATE%.log",datePattern:"YYYY-MM-DD",level:"error",..._})),G>=1&&K.push(new y({filename:"warn-%DATE%.log",datePattern:"YYYY-MM-DD",level:"warn",..._})),G>=2&&K.push(new y({filename:"info-%DATE%.log",datePattern:"YYYY-MM-DD",level:"info",..._})),G>=3&&K.push(new y({filename:"http-%DATE%.log",datePattern:"YYYY-MM-DD",level:"http",..._})),G>=4&&K.push(new y({filename:"debug-%DATE%.log",datePattern:"YYYY-MM-DD",level:"debug",..._}));const V=m.createLogger({levels:{error:0,warn:1,info:2,http:3,debug:4},format:W,transports:K,exceptionHandlers:[new m.transports.File({filename:"logs/exceptions.log"})],rejectionHandlers:[new m.transports.File({filename:"logs/rejections.log"})]});const j=new h({protocol:L,user:M,pass:b,host:x,port:parseInt(N,10)});const q=v.promisify(h.prototype.createwallet.bind(j));const J=v.promisify(h.prototype.generateToAddress.bind(j));const z=v.promisify(h.prototype.getaddressinfo.bind(j));const X=v.promisify(h.prototype.getBlock.bind(j));const Z=v.promisify(h.prototype.getBlockchainInfo.bind(j));const Q=v.promisify(h.prototype.getBlockHash.bind(j));const tt=v.promisify(h.prototype.getRawTransaction.bind(j));const et=v.promisify(h.prototype.getRawTransaction.bind(j));const st=v.promisify(h.prototype.getTransaction.bind(j));const nt=v.promisify(h.prototype.getNewAddress.bind(j));const at={createwallet:q,generateToAddress:J,getaddressinfo:z,getBlock:X,getBlockchainInfo:Z,getBlockHash:Q,getRawTransaction:tt,getTransaction:st,importaddress:v.promisify(h.prototype.importaddress.bind(j)),listunspent:v.promisify(h.prototype.listunspent.bind(j)),sendRawTransaction:v.promisify(h.prototype.sendRawTransaction.bind(j)),getNewAddress:nt,sendToAddress:v.promisify(h.prototype.sendToAddress.bind(j)),getRawTransactionJSON:et};const rt={error:(t,e)=>{if(e.cn){const{host:s,port:n,database:a,user:r,password:o}=e.cn;V.debug(`Waiting for db to start { message:${t.message} host:${s}, port:${n}, database:${a}, user:${r}, password: ${o}`)}},noWarnings:!0};"true"===D&&(w.isAttached()?w.detach():(w.attach(rt),w.setTheme("matrix")));const ot=E(rt)({host:I,port:parseInt(T,10),database:R,user:O,password:g,allowExitOnIdle:!0,idleTimeoutMillis:100});const{PreparedStatement:it}=E;class ct{static async select(t){const e=new it({name:`SyncStatus.select.${Math.random()}`,text:'SELECT "blockToSync", "workerId" FROM "SyncStatus" WHERE "workerId" = $1',values:[t]});return ot.oneOrNone(e)}static async update({blockToSync:t,workerId:e}){const s=new it({name:`SyncStatus.update.${Math.random()}`,text:'UPDATE "SyncStatus" SET "blockToSync" = $1 WHERE "workerId" = $2',values:[t,e]});await ot.any(s)}static async count(){const t=new it({name:`SyncStatus.count.${Math.random()}`,text:'SELECT COUNT(*) FROM "SyncStatus"'});const e=await ot.oneOrNone(t);return parseInt(e?.count,10)||0}static async min(){const t=new it({name:`SyncStatus.min.${Math.random()}`,text:'SELECT MIN("blockToSync") FROM "SyncStatus"'});const e=await ot.oneOrNone(t);return parseInt(e?.min,10)||0}static async delete(){const t=new it({name:`SyncStatus.delete.${Math.random()}`,text:'DELETE FROM "SyncStatus"'});await ot.any(t)}static async insertBatch(t){const e=[];for(let s=1;s<=t.length;s+=2)e.push(`($${s}, $${s+1})`);const s=e.join(",");const n=new it({name:`SyncStatus.reorg.${Math.random()}`,text:`INSERT INTO "SyncStatus"("workerId", "blockToSync") VALUES ${s}`,values:t});await ot.any(n)}}class pt{static async select(t){return ct.select(t)}static async update(t){await ct.update(t)}static async count(){return ct.count()}static async insertBatch(t){await ct.insertBatch(t)}static async min(){return ct.min()}static async delete(){await ct.delete()}}class ut{static update=async t=>pt.update(t);static select=async t=>pt.select(t);static setup=async t=>{if(await pt.count()===t)return void V.info(`[wid 1 pid: ${process.pid}: all ${t} workers have already registered.`);const e=[];let s=Math.max(1,await pt.min());for(let n=1;n<=t;n+=1,s+=1)e.push(n,s);V.info(`[wid 1 pid: ${process.pid}: reorging sync status for ${t} workers...${e}`),await pt.delete(),await pt.insertBatch(e)}}const dt=(t,e)=>{const s=[];for(let n=0;n<t.length;n+=e){const a=Math.min(n+e,t.length);const r=t.slice(n,a);s.push(r)}return s};const lt=t=>{const e=[];for(let s=1;s<=t;s+=2){const t=`($${s},$${s+1})`;e.push(t)}return e.join(",")};const mt=t=>{const e=[];for(let s=1;s<=t;s+=9){const t=`($${s},$${s+1},$${s+2},$${s+3},$${s+4},$${s+5},$${s+6},$${s+7},$${s+8})`;e.push(t)}return e.join(",")};const yt=t=>{try{return t()}catch{return null}};const{PreparedStatement:ht}=E;class vt{static async select(t){const e=new ht({name:`Input.select.${Math.random()}`,text:'SELECT "outputSpent" FROM "Input" WHERE "outputSpent" = $1',values:[t]});return ot.any(e)}static async insert(t){await Promise.all(dt(t,5e3).map((t=>{const e=t.flatMap((({outputSpent:t,spendingInput:e})=>[t,e]));return ot.none(new ht({name:`Input.insert.${Math.random()}`,text:`INSERT INTO "Input"("outputSpent", "spendingInput") VALUES ${lt(e.length)} ON CONFLICT DO NOTHING`,values:e}))})))}static async count(t){const e=t.map((t=>t.outputSpent));const s=new ht({name:`Input.belong.${Math.random()}`,text:'SELECT count(*) FROM "Input" WHERE "outputSpent" LIKE ANY ($1)',values:[[e]]});const n=await ot.oneOrNone(s);return parseInt(n?.count,10)||0}}class Et{static async select(t){return vt.select(t)}static async insert(t){return vt.insert(t)}}class wt{static insert=async t=>{const s=t.flatMap((t=>t.tx.ins.map((e=>({input:e,txId:t.txId}))))).filter((({input:t})=>!n.isCoinbaseHash(t.hash))).map((({input:t,txId:s},n)=>{return{outputSpent:`${a=t.hash,e.reverseBuffer(Buffer.from(a)).toString("hex")}:${t.index}`,spendingInput:`${s}:${n}`};var a}));Et.insert(s)}}function $t(t){if(!function(t){return/^[0-9A-Fa-f]{64}:\d+$/.test(t)}(t))throw new Error("Invalid rev")}const{PreparedStatement:St}=E;class ft{static async listSentOutputs(t){const e=new St({name:`Output.listSentTxs.${Math.random()}`,text:'SELECT "Input"."spendingInput" AS "output", "Output"."satoshis" AS "amount"\n        FROM "Output" INNER JOIN "Input" ON "Output".rev = "Input"."outputSpent" \n        WHERE "Output"."address" = $1',values:[t]});return(await ot.any(e)).map((t=>({...t,amount:parseInt(t.amount,10)||0})))}static async listReceivedOutputs(t){const e=new St({name:`Output.listReceivedTxs.${Math.random()}`,text:'SELECT "Output"."rev" as "output", "Output"."satoshis" as "amount" FROM "Output" WHERE "address" = $1',values:[t]});return(await ot.any(e)).map((t=>({...t,amount:parseInt(t.amount,10)||0})))}static async listTxs(t){const e=new St({name:`Output.listTxs.${Math.random()}`,text:'WITH\n              -- List all txs sent from a given address\n              SENT AS (\n                SELECT split_part("Input"."spendingInput",\':\',1) as "txId", SUM("Output".satoshis) as "satoshis"\n                FROM "Output" INNER JOIN "Input" ON "Output".rev = "Input"."outputSpent"  \n                WHERE "Output".address = $1\n                GROUP BY split_part("Input"."spendingInput",\':\',1)\n              ),\n              -- List all tx received from a given address\n              RECEIVED AS (\n                SELECT SPLIT_PART("Output"."rev",\':\',1) as "txId", SUM("Output"."satoshis") as "satoshis" \n                FROM "Output" \n                WHERE "address" = $1\n                GROUP BY "txId"\n              )\n\n            SELECT\n              RECEIVED."txId", \n              coalesce(SENT."satoshis", 0) as "inputsSatoshis", \n              coalesce(RECEIVED."satoshis", 0) as "outputsSatoshis", \n              coalesce(RECEIVED."satoshis",0) - coalesce(SENT."satoshis",0) as "satoshis"\n            FROM\n              SENT RIGHT JOIN RECEIVED ON SENT."txId" = RECEIVED."txId";',values:[t]});const s=(await ot.any(e)).map((t=>({...t,inputsSatoshis:parseInt(t.inputsSatoshis,10)||0,outputsSatoshis:parseInt(t.outputsSatoshis,10)||0,satoshis:parseInt(t.satoshis,10)||0})));return{sentTxs:s.filter((t=>t.satoshis<0)).map((t=>({...t,satoshis:Math.abs(t.satoshis)}))),receivedTxs:s.filter((t=>t.satoshis>=0))}}static async select(t){const e=new St({name:`Output.select.${Math.random()}`,text:'SELECT "address", "satoshis", "scriptPubKey", "rev", "publicKeys", "hash", "mod", "isTbcOutput", "previous" FROM "Output" WHERE "address" = $1',values:[t]});return ot.any(e)}static async insert(t){await Promise.all(dt(t,1111).map((t=>{const e=t.flatMap((({rev:t,address:e,satoshis:s,scriptPubKey:n,isTbcOutput:a,publicKeys:r,mod:o,previous:i,hash:c})=>[t,e,s,n,a,r,o,i,c]));return ot.none(new St({name:`Output.insert.${Math.random()}`,text:`INSERT INTO "Output"("rev", "address", "satoshis", "scriptPubKey", "isTbcOutput", "publicKeys", "mod", "previous", "hash") VALUES ${mt(e.length)} ON CONFLICT DO NOTHING`,values:e}))})))}static async getIdByRev(t){const e=new St({name:`NonStandard.recursiveUpdates.${Math.random()}`,text:'WITH RECURSIVE revUpdates AS (\n        SELECT "rev", "previous" FROM "Output" WHERE "isTbcOutput" = true and "rev" = $1\n        UNION ALL\n        SELECT o."rev", o."previous" FROM "Output" o\n        INNER JOIN revUpdates r ON r."previous" = o."rev"\n      )\n      SELECT * FROM revUpdates',values:[t]});const s=(await ot.any(e)).filter((t=>null===t.previous));return s[0]?.rev}static async getIdsByRevs(t){return Promise.all(t.map((t=>this.getIdByRev(t))))}static async getLatestRev(t){const e=new St({name:`NonStandard.recursiveUpdates.${Math.random()}`,text:'WITH RECURSIVE revUpdates AS (\n        SELECT "rev", "previous" FROM "Output" WHERE "isTbcOutput" = true and "rev" = $1\n        UNION ALL\n        SELECT o."rev", o."previous" FROM "Output" o\n        INNER JOIN revUpdates r ON o."previous" = r."rev"\n      )\n      SELECT * FROM revUpdates',values:[t]});const s=await ot.any(e);const n=Object.fromEntries(s.map((t=>[t.previous,t.rev])));let a=t;for(;n[a];)a=n[a];return a}static async getLatestRevs(t){return Promise.all(t.map(this.getLatestRev))}static async getIdsByMod(t){const e=new St({name:`Output.getIdsByMod.${Math.random()}`,text:'SELECT "rev" FROM "Output" WHERE "mod" = $1',values:[t]});return(await ot.any(e)).map((t=>t.rev))}static sqlSuffix(t,e,s){let n="";return s&&(n+=` order by "timestamp" ${s}`),n+=` limit ${t||Y}`,e&&(n+=` offset ${e}`),n}static async getRevsByPublicKey(t){const e=new St({name:`Output.getRevsByPublicKey.${Math.random()}`,text:'SELECT "rev" FROM "Output" WHERE $1 = ANY("publicKeys")',values:[t]});return(await ot.any(e)).map((t=>t.rev))}static async getUnspentRevsByMod(t,e,s,n){const a=await this.getIdsByMod(t);const r=await this.getLatestRevs(a);const o=new St({name:`Output.getUnspentRevsByMod.${Math.random()}`,text:`SELECT "rev" FROM "Output" WHERE "rev" = ANY($1) ${this.sqlSuffix(e,s,n)}`,values:[r]});return(await ot.any(o)).map((t=>t.rev))}static async getUnspentRevsByPublicKey(t,e,s,n){const a=new St({name:`Output.getUnspentRevsByPublicKey.${Math.random()}`,text:`SELECT "rev" FROM "Output" WHERE $1 = ANY("publicKeys") AND "isTbcOutput" = true \n      AND NOT EXISTS (SELECT 1 FROM "Input" ip WHERE "ip"."outputSpent" = "Output"."rev") \n      ${this.sqlSuffix(e,s,n)}`,values:[t]});return(await ot.any(a)).map((t=>t.rev))}static async getUnspentRevsByModAndPublicKey(t,e,s,n,a){const r=await this.getUnspentRevsByPublicKey(e,s,n,a);const o=await this.getIdsByRevs(r);const i=new St({name:`Output.getLatestRevsByModAndPublicKey.${Math.random()}`,text:'SELECT "rev" FROM "Output" WHERE "mod" = $1 AND "rev" = ANY($2)',values:[t,o]});const c=(await ot.any(i)).map((t=>t.rev));const p=await this.getLatestRevs(c);const u=new St({name:`Output.getLatestRevsByModAndPublicKey.${Math.random()}`,text:`SELECT "rev" FROM "Output" WHERE "rev" = ANY($1) ${this.sqlSuffix(s,n,a)}`,values:[p]});return(await ot.any(u)).map((t=>t.rev))}static async query(t){const{publicKey:e,limit:s,offset:n,ids:a,mod:r,order:o}=t;const i=parseInt(Y||"",10);if(s&&parseInt(s||"",10)>i||a&&a.length>i)throw new Error(`Can't fetch more than ${Y} revs.`);if(o&&"ASC"!==o&&"DESC"!==o)throw new Error("Invalid order. Should be ASC or DESC.");return a?.length?(a.map($t),this.getLatestRevs(a)):r&&!e?this.getUnspentRevsByMod(r,s,n,o):!r&&e?this.getUnspentRevsByPublicKey(e,s,n,o):r&&e?this.getUnspentRevsByModAndPublicKey(r,e,s,n,o):[]}}class Ot{static async select(t){return ft.select(t)}static async insert(t){return ft.insert(t)}static async listSentOutputs(t){return ft.listSentOutputs(t)}static async listReceivedOutputs(t){return ft.listReceivedOutputs(t)}static async listTxs(t){return ft.listTxs(t)}static async getLatestRev(t){return ft.getLatestRev(t)}static async query(t){return ft.query(t)}}class gt{static insert=async t=>{const e=function(t=$,e=S){switch(t){case"BTC":switch(e){case"mainnet":return s.bitcoin;case"testnet":return s.testnet;case"regtest":return s.regtest;default:throw new Error(`Invalid network ${e}`)}case"LTC":switch(e){case"mainnet":return s.litecoin;case"testnet":return s.litecointestnet;case"regtest":return s.litecoinregtest;default:throw new Error(`Invalid network ${e}`)}case"PEPE":switch(e){case"mainnet":return s.pepecoin;case"testnet":return s.pepecointestnet;case"regtest":return s.pepecoinregtest;default:throw new Error(`Invalid network ${e}`)}default:throw new Error(`Invalid chain ${t}`)}}($,S);const n=t.flatMap((t=>{const{zip:s,ownerData:n,onChainMetaData:o}=t;const{exp:i="",mod:c=""}=o;return t.tx.outs.map((({script:o,value:p},u)=>{const d=u<s.length;return{rev:`${t.txId}:${u}`,address:yt((()=>r.fromOutputScript(o,e))),satoshis:Math.round(p),scriptPubKey:o.toString("hex"),isTbcOutput:d,publicKeys:d?n[u]._owners:[],mod:d?c:"",previous:d?s[u][0]:null,hash:d?a.sha256(Buffer.from(i||"")).toString("hex"):null}}))}));return Ot.insert(n)};static listSentOutputs=async t=>Ot.listSentOutputs(t);static listReceivedOutputs=async t=>Ot.listReceivedOutputs(t);static listTxs=async t=>Ot.listTxs(t);static getLatestRev=async t=>Ot.getLatestRev(t);static query=async t=>Ot.query(t)}class Rt{static waitForBlockHash=async(t,e)=>(await p((async()=>{let s;try{s=await at.getBlockHash(t)}catch(s){throw V.info(`[wid ${e} pid: ${process.pid}]: waiting for block ${t} ...`),s}return s}),{startingDelay:3e4,timeMultiple:1,numOfAttempts:720})).result;static syncBlock=async(t,e,s="LTC")=>{const n=await Rt.waitForBlockHash(t,e);const{result:a}=await at.getBlock(n,2);const{tx:r}=a;let o=r;"LTC"===s&&(o=r.filter((t=>"08"!==t.hex.slice(10,12))));const i=`[wid ${e} pid: ${process.pid}: backfilling height ${t} - backfilling ${o.length} txs `;"LTC"===s&&i.concat(`(${r.length-o.length} mweb tx's filtered)...`),V.info(i);const c=o.map((s=>{try{return u.txFromHex({hex:s.hex})}catch(n){n instanceof Error&&V.error(`[wid ${e} pid: ${process.pid}: failed to parse transaction in block ${t}\n            error message: ${n.message}\n            transaction: ${JSON.stringify(s)}`)}return null})).filter((t=>null!==t));try{await gt.insert(c),await wt.insert(c)}catch(s){V.error(`[wid ${e} pid: ${process.pid}: processing block ${t} failed with error '${s.message}'`)}};static sync=async(t,e,s)=>{for(;;){try{await this.syncBlock(e,t,$)}catch(s){V.error(`[wid ${t} pid: ${process.pid}: syncing block num ${e} failed with error '${s.message}'`)}e+=s,await ut.update({blockToSync:e,workerId:t})}}}o(t);let It=c();H&&parseInt(H,10)>0&&(It=parseInt(H,10));const Tt=i.worker?i.worker.id:0;V.info(`[wid ${Tt} pid: ${process.pid}]: starting with ${It} threads`);try{if(await(async()=>{await p((()=>ot.connect()),{startingDelay:500})})(),V.info(`[wid ${Tt} pid: ${process.pid}]: connected to the database successfully`),i.isPrimary){V.info(`[wid ${Tt} pid: ${process.pid}]: parameters { url: ${F}, chain:${$} network:${S} numWorkers: ${It}}`),await ut.setup(It);for(let t=1;t<=It;t+=1)V.info(`[wid ${Tt} pid: ${process.pid}: launching worker ${t}`),i.fork();i.on("exit",((t,e,s)=>{V.info(`[wid ${Tt} pid: ${process.pid}]: worker ${t.process.pid} died with code ${e} and signal ${s}`),V.error(`[wid ${Tt} pid: ${process.pid}]: aborting`),process.exit(0)}))}else"regtest"!==S&&(async(t,e)=>{const s=await ut.select(t);V.info(`[wid ${s.workerId} pid: ${process.pid}]: starting to sync block: ${s.blockToSync} - numWorkers: ${e}`),await Rt.sync(s.workerId,s.blockToSync,e)})(Tt,It)}catch(t){V.error(`[wid ${Tt} pid: ${process.pid}]: synchronizing failed with error '${t.message}'`)}
