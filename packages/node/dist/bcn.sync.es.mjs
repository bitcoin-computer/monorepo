import*as t from"@bitcoin-computer/secp256k1";import{networks as e,bufferUtils as s,script as a,crypto as n,address as r,initEccLib as o}from"@bitcoin-computer/nakamotojs";import{availableParallelism as i}from"node:os";import{spawn as c}from"node:child_process";import{exit as p}from"node:process";import u from"dotenv";import l from"winston";import d from"winston-daily-rotate-file";import{backOff as h}from"exponential-backoff";import m from"pg-promise";import w from"pg-monitor";import y from"fs";import{Transaction as E}from"@bitcoin-computer/lib";import $ from"bitcoind-rpc";import g from"util";u.config();const S=process.env.BCN_CHAIN||"LTC";const O=process.env.BCN_NETWORK||"regtest";const{BCN_PORT:v}=process.env;process.env,process.env;const{BCN_LOG_LEVEL:T}=process.env;const{BCN_LOG_MAX_FILES:f}=process.env;const{BCN_LOG_MAX_SIZE:I}=process.env;const{BCN_LOG_ZIP:R}=process.env;const{BCN_SHOW_DB_LOGS:k}=process.env;process.env,process.env,process.env,process.env,process.env;const{BCN_NUM_WORKERS:b}=process.env;const{BCN_WORKER_ID:B}=process.env;process.env,process.env;const M=process.env.BCN_QUERY_LIMIT?parseInt(process.env.BCN_QUERY_LIMIT):void 0;!process.env.BCN_STREAM_KEYS||process.env.BCN_STREAM_KEYS.split(",");const x=process.env.BCN_URL||`http://127.0.0.1:${v}`;const H=process.env.BCN_ENV||"dev";const N=process.env.BCN_ZMQ_ACTIVATION_HEIGHT||"1";const{BITCOIN_RPC_USER:C}=process.env;const{BITCOIN_RPC_PASSWORD:A}=process.env;const{BITCOIN_RPC_HOST:L}=process.env;const{BITCOIN_RPC_PORT:F}=process.env;const{BITCOIN_RPC_PROTOCOL:U}=process.env;const{BITCOIN_DEFAULT_WALLET:P}=process.env;const{POSTGRES_USER:W}=process.env;const{POSTGRES_PASSWORD:D}=process.env;const{POSTGRES_DB:_}=process.env;const{POSTGRES_HOST:j}=process.env;const{POSTGRES_PORT:G}=process.env;const{POSTGRES_MAX_CONNECTIONS:K}=process.env;const{POSTGRES_IDLE_TIMEOUT_MILLIS:Y}=process.env;l.addColors({error:"red",warn:"yellow",info:"green",http:"magenta",debug:"blue"});const X=l.format.combine(l.format.colorize(),l.format.timestamp({format:"YYYY-MM-DD HH:mm:ss:ms"}),l.format.json(),l.format.printf(t=>`${t.timestamp} [${t.level.slice(5).slice(0,-5)}] ${t.message}`));const V=l.format.combine(l.format.colorize(),l.format.timestamp({format:"MM-DD-YYYY HH:mm:ss"}),l.format.printf(t=>`${t.timestamp} ${t.level} ${t.message}`));const q={zippedArchive:"true"===R,maxSize:I,maxFiles:f,dirname:"logs"};const J=[];const z={0:"error",1:"warn",2:"info",3:"http",4:"debug"}[T];"dev"===H&&J.push(new l.transports.Console({format:V,level:z})),J.push(new d({filename:"logs/application-%DATE%.log",datePattern:"YYYY-MM-DD",level:z,...q})),J.push(new d({filename:"logs/error-%DATE%.log",datePattern:"YYYY-MM-DD",level:"error",...q}));const Q=l.createLogger({levels:{error:0,warn:1,info:2,http:3,debug:4},format:X,transports:J,exceptionHandlers:[new l.transports.File({filename:"logs/exceptions.log"})],rejectionHandlers:[new l.transports.File({filename:"logs/rejections.log"})]});u.config({path:"../../.env"});const{version:Z}=JSON.parse(y.readFileSync("package.json","utf8"));Z||process.env.BCN_SERVER_VERSION;const tt=parseInt(process.env.MWEB_HEIGHT||"",10)||432;const et=[{txId:"e3bf3d07d4b0375638d5f1db5255fe07ba2c4cb067cd81b84ee974b6585fb468",height:91722},{txId:"d5d27987d2a3dfc724e359870c6644b40e497bdc0589a033220fe15429d88599",height:91812}];const st=["satoshis","asm","expHash","mod","id"];const at={error:(t,e)=>{if(e.cn){const{host:s,port:a,database:n,user:r,password:o}=e.cn;Q.debug(`Waiting for db to start { message:${t.message} host:${s}, port:${a}, database:${n}, user:${r}, password: ${o}`)}},noWarnings:!0};let nt;"true"===k&&(w.isAttached()?w.detach():(w.attach(at),w.setTheme("matrix")));try{nt=m(at)}catch(t){throw Q.error("pgPromise init error",t),t}const rt=nt({host:j,port:parseInt(G,10),database:_,user:W,password:D,max:parseInt(K,10),allowExitOnIdle:!0,idleTimeoutMillis:parseInt(Y,10)});const{PreparedStatement:ot}=m;class it{static async selectByWorkerId(t){const e=new ot({name:`TxStatus.select.${Math.random()}`,text:'SELECT "blockToSync", "workerId" FROM "TxStatus" WHERE "workerId" = $1',values:[t]});return rt.oneOrNone(e)}static async update({blockToSync:t,workerId:e}){const s=new ot({name:`TxStatus.update.${Math.random()}`,text:'UPDATE "TxStatus" SET "blockToSync" = $1 WHERE "workerId" = $2',values:[t,e]});await rt.any(s)}static async count(){const t=new ot({name:`TxStatus.count.${Math.random()}`,text:'SELECT COUNT(*) FROM "TxStatus"'});const e=await rt.oneOrNone(t);return parseInt(e?.count,10)||0}static async min(){const t=new ot({name:`TxStatus.min.${Math.random()}`,text:'SELECT MIN("blockToSync") FROM "TxStatus"'});const e=await rt.oneOrNone(t);return parseInt(e?.min,10)||0}static async deleteAll(){const t=new ot({name:`TxStatus.delete.${Math.random()}`,text:'DELETE FROM "TxStatus"'});await rt.any(t)}static async insertBatch(t){const e=[];for(let s=1;s<=t.length;s+=2)e.push(`($${s}, $${s+1})`);const s=e.join(",");const a=new ot({name:`TxStatus.reorg.${Math.random()}`,text:`INSERT INTO "TxStatus"("workerId", "blockToSync") VALUES ${s}`,values:t});await rt.any(a)}}class ct{static async selectByWorkerId(t){return it.selectByWorkerId(t)}static async update(t){await it.update(t)}static async count(){return it.count()}static async insertBatch(t){await it.insertBatch(t)}static async min(){return it.min()}static async deleteAll(){await it.deleteAll()}}const{PreparedStatement:pt}=m;class ut{static async select(){const t=new pt({name:`BlockStatus.select.${Math.random()}`,text:'SELECT "blockToSync" FROM "BlockStatus"'});const e=await rt.oneOrNone(t);return parseInt(e?.blockToSync,10)||null}static async update(t){const e=new pt({name:`BlockStatus.update.${Math.random()}`,text:'UPDATE "BlockStatus" SET "blockToSync" = $1',values:[t]});await rt.any(e)}static async insert(t){const e=new pt({name:`BlockStatus.insert.${Math.random()}`,text:'INSERT INTO "BlockStatus"("blockToSync") VALUES ($1)',values:[t]});await rt.any(e)}static async count(){const t=new pt({name:`BlockStatus.count.${Math.random()}`,text:'SELECT COUNT(*) FROM "BlockStatus"'});const e=await rt.oneOrNone(t);return parseInt(e?.count,10)||0}static async delete(){const t=new pt({name:`BlockStatus.delete.${Math.random()}`,text:'DELETE FROM "BlockStatus"'});await rt.any(t)}}class lt{static async select(){return ut.select()}static async update(t){await ut.update(t)}static async insert(t){await ut.insert(t)}static async count(){return ut.count()}static async delete(){await ut.delete()}}class dt{static update=async t=>lt.update(t);static select=async()=>lt.select();static insert=async t=>lt.insert(t);static count=async()=>lt.count();static delete=async()=>lt.delete()}function ht(t){t.forEach(t=>{Q.info(`[wid 0 pid: ${process.pid}]: killing worker ${t}`);try{Q.info(`[wid 0 pid: ${process.pid}]: killing worker (SIGTERM) ${t}: ${process.kill(t,"SIGTERM")}`),process.kill(t,"SIGTERM")}catch(e){Q.info(`[wid 0 pid: ${process.pid}]: killing worker ${t}: ${process.kill(t)}`),process.kill(t,"SIGKILL")}})}const mt=t=>new Promise(e=>{setTimeout(e,t)});const wt=(t,e)=>{const s=[];for(let a=0;a<t.length;a+=e){const n=Math.min(a+e,t.length);const r=t.slice(a,n);s.push(r)}return s};const yt=t=>{if(t<1)return"";let e="($1,$2)";for(let s=3;s<=t;s+=2)e+=`,($${s},$${s+1})`;return e};const Et=t=>{const e=[];for(let s=1;s<=t;s+=3){const t=`($${s},$${s+1},$${s+2})`;e.push(t)}return e.join(",")};const $t=t=>{const e=[];for(let s=1;s<=t;s+=11){const t=`($${s},$${s+1},$${s+2},$${s+3},$${s+4},$${s+5},$${s+6},$${s+7},$${s+8},$${s+9},$${s+10})`;e.push(t)}return e.join(",")};const gt=t=>{try{return t()}catch{return null}};const{PreparedStatement:St}=m;class Ot{static async selectByHeight(t){const e=new St({name:`Block.select.${Math.random()}`,text:'SELECT "hash", "height", "previousHash" FROM "Block" WHERE "height" = $1',values:[t]});return rt.oneOrNone(e)}static async insert(t){const e=new St({name:`Block.insert.${Math.random()}`,text:'INSERT INTO "Block" ("hash", "height", "previousHash") VALUES ($1, $2, $3)',values:[t.hash,t.height,t.previousHash]});await rt.none(e)}static async insertBatch(t){const e=t.flatMap(({hash:t,height:e,previousHash:s})=>[t,e,s]);const s=new St({name:`Block.insertBatch.${Math.random()}`,text:`INSERT INTO "Block" ("hash", "height", "previousHash") VALUES ${Et(e.length)}`,values:e});await rt.none(s)}static async deleteAll(){const t=new St({name:`Block.delete.${Math.random()}`,text:'DELETE FROM "Block"',values:[]});await rt.none(t)}static async deleteByHash(t){const e=t.map(t=>t).join("', '");const s=new St({name:`Block.deleteByHash.${Math.random()}`,text:`DELETE FROM "Block" WHERE "hash" IN ('${e}')`});await rt.none(s)}}class vt{static selectByHeight=async t=>Ot.selectByHeight(t);static insert=async t=>Ot.insert(t);static insertBatch=async t=>Ot.insertBatch(t);static deleteAll=async()=>Ot.deleteAll();static deleteByHash=async t=>Ot.deleteByHash(t);static waitForDbBlockHash=async(t,e)=>(await h(async()=>{let s;try{s=await Ot.selectByHeight(t)}catch(s){throw Q.debug(`[wid ${e} pid: ${process.pid}]: waiting for DB to get block ${t} ...`),s}return s},{startingDelay:1e4,timeMultiple:1,numOfAttempts:720})).hash}class Tt{static selectByHeight=async t=>vt.selectByHeight(t);static insert=async t=>vt.insert(t);static insertBatch=async t=>vt.insertBatch(t);static deleteAll=async()=>vt.deleteAll();static deleteByHash=async t=>vt.deleteByHash(t);static waitForDbBlockHash=async(t,e)=>vt.waitForDbBlockHash(t,e)}const{PreparedStatement:ft}=m;class It{static async selectAll(){const t=new ft({name:`Orphan.select.${Math.random()}`,text:'SELECT * FROM "Orphan"'});return rt.any(t)}static async insertAll(t){const e=t.map(t=>`('${t.hash}',${t.height}, ${t.processed})`).join(",");const s=new ft({name:`Orphan.insert.${Math.random()}`,text:`INSERT INTO "Orphan" (hash, height, processed) VALUES ${e}`});await rt.none(s)}static async process(t){const e=t.map(t=>t.height).join(",");const s=new ft({name:`Orphan.process.${Math.random()}`,text:`UPDATE "Orphan" SET processed = true WHERE height IN (${e})`});await rt.none(s)}}class Rt{static selectAll=async()=>It.selectAll();static insertAll=async t=>It.insertAll(t);static process=async t=>It.process(t)}class kt{static selectAll=async()=>Rt.selectAll();static insertAll=async t=>Rt.insertAll(t);static process=async t=>Rt.process(t)}const{PreparedStatement:bt}=m;class Bt{static async select(t){const e=new bt({name:`Input.select.${Math.random()}`,text:'SELECT "outputSpent", "spendingInput", "blockHash" FROM "Input" WHERE "outputSpent" = $1',values:[t]});return rt.any(e)}static async insert(t){await Promise.all(wt(t,3333).map(t=>{const e=t.flatMap(({outputSpent:t,spendingInput:e,blockHash:s})=>[t,e,s]);return rt.none(new bt({name:`Input.insert.${Math.random()}`,text:`INSERT INTO "Input"("outputSpent", "spendingInput", "blockHash") VALUES ${Et(e.length)} \n              ON CONFLICT ("spendingInput") \n              DO UPDATE SET "blockHash" = COALESCE("Input"."blockHash", EXCLUDED."blockHash")`,values:e}))}))}static async eraseBlockHash(t){await Promise.all(wt(t,1e4).map(t=>{const e=t.join("','");return rt.none(new bt({name:`Input.eraseBlockHash.${Math.random()}`,text:`UPDATE "Input" SET "blockHash" = NULL WHERE "blockHash" IN ('${e}')`}))}))}static async count(t){const e=t.map(t=>t.outputSpent);const s=new bt({name:`Input.belong.${Math.random()}`,text:'SELECT count(*) FROM "Input" WHERE "outputSpent" LIKE ANY ($1)',values:[[e]]});const a=await rt.oneOrNone(s);return parseInt(a?.count,10)||0}}class Mt{static async select(t){return Bt.select(t)}static async insert(t){return Bt.insert(t)}static async eraseBlockHash(t){return Bt.eraseBlockHash(t)}}class xt{static insert=async t=>{await Mt.insert(t)};static getInputs=(t,e=null)=>t.flatMap(({ins:t,txId:e})=>t.map((t,s)=>({input:t,index:s,txId:e}))).filter(({input:t})=>!E.isCoinbaseHash(t.hash)).map(({input:t,index:a,txId:n})=>{return{outputSpent:`${r=t.hash,s.reverseBuffer(Buffer.from(r)).toString("hex")}:${t.index}`,spendingInput:`${n}:${a}`,blockHash:e};var r});static select=async t=>Mt.select(t);static eraseBlockHash=async t=>{await Mt.eraseBlockHash(t)}}const{PreparedStatement:Ht}=m;class Nt{static async listSentOutputs(t){const e=new Ht({name:`Output.listSentTxs.${Math.random()}`,text:'SELECT "Input"."spendingInput" AS "output", COALESCE("Output"."satoshis", 0) AS "satoshis"\n        FROM "Output" INNER JOIN "Input" ON "Output".rev = "Input"."outputSpent" \n        WHERE "Output"."address" = $1',values:[t]});return rt.any(e)}static async listReceivedOutputs(t){const e=new Ht({name:`Output.listReceivedTxs.${Math.random()}`,text:'SELECT "Output"."rev" as "output", COALESCE("Output"."satoshis", 0) as "satoshis" FROM "Output" WHERE "address" = $1',values:[t]});return rt.any(e)}static async listTxs(t){const e=new Ht({name:`Output.listTxs.${Math.random()}`,text:'\n        WITH \n          -- Outputs received by the address\n          received AS (\n            SELECT SPLIT_PART("rev", \':\', 1) AS "txId", SUM("satoshis") AS "satoshis"\n            FROM "Output"\n            WHERE "address" = $1\n            GROUP BY 1\n          ),\n          -- Total satoshis sent from the address\n          sent AS (\n            SELECT SPLIT_PART("Input"."spendingInput", \':\', 1) AS "txId", SUM("Output"."satoshis") AS "satoshis"\n            FROM "Input"\n            JOIN "Output" ON "Input"."outputSpent" = "Output"."rev"\n            WHERE "Output"."address" = $1\n            GROUP BY 1\n          ),\n          txs AS (\n            SELECT \n              COALESCE(r."txId", s."txId") AS "txId",\n              COALESCE(s."satoshis", 0) AS "inputsSatoshis",\n              COALESCE(r."satoshis", 0) AS "outputsSatoshis",\n              COALESCE(r."satoshis", 0) - COALESCE(s."satoshis", 0) AS "satoshis"\n            FROM received r\n            FULL OUTER JOIN sent s ON r."txId" = s."txId"\n          )\n        SELECT * FROM txs;\n      ',values:[t]});const s=await rt.any(e);return{sentTxs:s.filter(t=>BigInt(t.satoshis)<0n).map(t=>({...t,satoshis:(-1n*BigInt(t.satoshis)).toString()})),receivedTxs:s.filter(t=>BigInt(t.satoshis)>=0n).map(t=>({...t,satoshis:BigInt(t.satoshis).toString()}))}}static async select(t){const e=new Ht({name:`Output.select.${Math.random()}`,text:'SELECT "address", "satoshis", "asm", "rev", "expHash", "mod", "isObject", "previous", "blockHash" FROM "Output" WHERE "address" = $1',values:[t]});return rt.any(e)}static async selectByRev(t){const e=new Ht({name:`Output.selectByRev.${Math.random()}`,text:'SELECT "address", "satoshis", "asm", "rev", "expHash", "mod", "isObject", "previous", "blockHash" FROM "Output" WHERE "rev" = $1',values:[t]});return rt.oneOrNone(e)}static async insert(t){await Promise.all(wt(t,900).map(t=>{const e=t.flatMap(({rev:t,address:e,satoshis:s,asm:a,isObject:n,mod:r,previous:o,expHash:i,blockHash:c,blockHeight:p,blockIndex:u})=>[t,e,s,a,n,r,o,i,c,p,u]);return rt.none(new Ht({name:`Output.insert.${Math.random()}`,text:`INSERT INTO "Output"("rev", "address", "satoshis", "asm", "isObject",\n              "mod", "previous", "expHash", "blockHash", "blockHeight", "blockIndex") VALUES ${$t(e.length)} ON CONFLICT  ("rev") \n              DO UPDATE SET "blockHash" = COALESCE("Output"."blockHash", EXCLUDED."blockHash"),\n                            "blockHeight" = EXCLUDED."blockHeight",\n                            "blockIndex"  = EXCLUDED."blockIndex"`,values:e}))}))}static async updateMods(t){await Promise.all(wt(t,5e3).map(t=>{const e=t.flatMap(({rev:t,mod:e})=>[t,e]);return rt.none(new Ht({name:`Output.update.${Math.random()}`,text:`UPDATE "Output" AS o\n              SET "mod" = v.mod\n              FROM (\n                VALUES\n                  ${yt(e.length)}\n              ) AS v(rev, mod)\n              WHERE o.rev = v.rev\n                AND o.mod is NULL`,values:e}))}))}static async eraseBlockHash(t){await Promise.all(wt(t,1e4).map(t=>{const e=t.join("','");return rt.none(new Ht({name:`Output.eraseBlockHash.${Math.random()}`,text:`UPDATE "Output" SET "blockHash" = NULL WHERE "blockHash" IN ('${e}')`}))}))}static async getAncestorTxs(t){const e=new Ht({name:`NonStandard.recursiveUpdates.${Math.random()}`,text:' WITH RECURSIVE RecursiveCTE AS (\n        SELECT SUBSTRING("rev" FROM 1 FOR 64) AS "rev", SUBSTRING(o."previous" FROM 1 FOR 64) as "previous"\n        FROM "Output" o\n        where o."isObject" = true and SUBSTRING(o."rev" FROM 1 FOR 64) = $1\n        UNION ALL\n        SELECT SUBSTRING(o."rev" FROM 1 FOR 64),  SUBSTRING(o.previous FROM 1 FOR 64)\n        FROM "Output" o\n        INNER JOIN RecursiveCTE r ON SUBSTRING(r."previous" FROM 1 FOR 64) = SUBSTRING(o."rev" FROM 1 FOR 64)\n      )\n      select distinct rev as "txId"\n      FROM RecursiveCTE;\n      ',values:[t]});return(await rt.any(e)).map(t=>t.txId)}static async firstByMod(t){const e=new Ht({name:`Output.getIdsByMod.${Math.random()}`,text:'SELECT "rev" FROM "Output" WHERE "mod" = $1',values:[t]});return(await rt.any(e)).map(t=>t.rev)}static sqlSuffix(t,e,s){let a="";return s&&(a+=` order by "timestamp" ${s}`),(t||M)&&(a+=` limit ${t||M}`),e&&(a+=` offset ${e}`),a}static async unspentByMod(t,e,s,a){const n=await this.firstByMod(t);const r=await Promise.all(n.map(this.latest));const o=new Ht({name:`Output.unspentByMod.${Math.random()}`,text:`SELECT "rev" FROM "Output" WHERE "rev" = ANY($1) \n      AND NOT EXISTS (SELECT 1 FROM "Input" ip WHERE "ip"."outputSpent" = "Output"."rev")\n      ${this.sqlSuffix(e,s,a)}`,values:[r]});return(await rt.any(o)).map(t=>t.rev)}static async unspentByPublicKey(t,e,s,a){const n=new Ht({name:`Output.unspentByPublicKey.${Math.random()}`,text:`SELECT "rev" FROM "Output" WHERE "isObject" = true AND asm LIKE '%' || $1 || '%' \n      AND NOT EXISTS (SELECT 1 FROM "Input" ip WHERE "ip"."outputSpent" = "Output"."rev") \n      ${this.sqlSuffix(e,s,a)}`,values:[t]});return(await rt.any(n)).map(t=>t.rev)}static async unspentByModPublicKey(t,e,s,a,n){const r=await this.unspentByPublicKey(e,s,a,n);const o=await Promise.all(r.map(t=>this.first(t)));const i=new Ht({name:`Output.unspentByModPublicKey1.${Math.random()}`,text:'SELECT "rev" FROM "Output" WHERE "mod" = $1 AND "rev" = ANY($2)',values:[t,o]});const c=(await rt.any(i)).map(t=>t.rev);const p=await Promise.all(c.map(this.latest));const u=new Ht({name:`Output.unspentByModPublicKey2.${Math.random()}`,text:`SELECT "rev" FROM "Output" WHERE "rev" = ANY($1) ${this.sqlSuffix(s,a,n)}`,values:[p]});return(await rt.any(u)).map(t=>t.rev)}static async unspent(t,e,s){const a=new Ht({name:`Output.getUnspentTbcOutputs.${Math.random()}`,text:`SELECT "rev", "address", "satoshis", "asm", "timestamp"\n        FROM "Output" WHERE "isObject" = true AND NOT EXISTS\n        (SELECT 1 FROM "Input" ip WHERE "ip"."outputSpent" = "Output"."rev") ${this.sqlSuffix(t,e,s)}`});return(await rt.any(a)).map(t=>t.rev)}static async query(t){const{publicKey:e,limit:s,offset:a,mod:n,order:r}=t;if(s&&M&&parseInt(s||"",10)>M)throw new Error(`Can't fetch more than ${M} revs.`);if(r&&"ASC"!==r&&"DESC"!==r)throw new Error("Invalid order. Should be ASC or DESC.");return n&&!e?this.unspentByMod(n,s,a,r):!n&&e?this.unspentByPublicKey(e,s,a,r):n&&e?this.unspentByModPublicKey(n,e,s,a,r):this.unspent(s,a,r)}static async getTXOs(t){const{verbosity:e,rev:s,address:a,satoshis:n,asm:r,isObject:o,mod:i,previous:c,expHash:p,blockHash:u,blockHeight:l,blockIndex:d,isSpent:h,isConfirmed:m,publicKey:w,limit:y,order:E="ASC",offset:$=0}=t;const g=[];const S=[];let O=1;s&&(g.push('"rev" = $'+O++),S.push(s)),a&&(g.push('"address" = $'+O++),S.push(a)),n&&(g.push('"satoshis" = $'+O++),S.push(n.toString())),r&&(g.push('"asm" = $'+O++),S.push(`${r}`)),void 0!==o&&(g.push('"isObject" = $'+O++),S.push(o)),i&&(g.push('"mod" = $'+O++),S.push(i)),c&&(g.push('"previous" = $'+O++),S.push(c)),p&&(g.push('"expHash" = $'+O++),S.push(p)),u&&(g.push('"blockHash" = $'+O++),S.push(u)),l&&(g.push('"blockHeight" = $'+O++),S.push(l)),d&&(g.push('"blockIndex" = $'+O++),S.push(d)),void 0!==h&&(h?g.push('EXISTS (SELECT 1 FROM "Input" ip WHERE ip."outputSpent" = "Output"."rev")'):g.push('NOT EXISTS (SELECT 1 FROM "Input" ip WHERE ip."outputSpent" = "Output"."rev")')),void 0!==m&&(m?g.push('"blockHash" IS NOT NULL'):g.push('"blockHash" IS NULL')),w&&(g.push('"asm" LIKE $'+O++),S.push(`%${w}%`));const v=g.length>0?`WHERE ${g.join(" AND ")}`:"";let T="";void 0!==y?(S.push(y),S.push($||0),T=`LIMIT $${O++} OFFSET $${O++}`):M&&(S.push(M),S.push($||0),T=`LIMIT $${O++} OFFSET $${O++}`);const f="DESC"===E?"DESC":"ASC";const I=0===e?'"rev"':'"rev", "address", "satoshis", "asm", "isObject", "mod", "previous", "expHash", "blockHash", "blockHeight", "blockIndex"';const R=new Ht({name:`Output.getTxos.${Math.random()}`,text:`\n        SELECT ${I}\n        FROM "Output"\n        ${v}\n        ORDER BY "rev" ${f}\n        ${T}\n      `,values:[...S]});const k=await rt.any(R);return 0===e?k.map(t=>t.rev):k}static async first(t){const e=new Ht({name:`NonStandard.first.${Math.random()}`,text:'WITH RECURSIVE revUpdates AS (\n        SELECT "rev", "previous" FROM "Output" WHERE "isObject" = true and "rev" = $1\n        UNION ALL\n        SELECT o."rev", o."previous" FROM "Output" o\n        INNER JOIN revUpdates r ON r."previous" = o."rev"\n      )\n      SELECT * FROM revUpdates',values:[t]});const s=await rt.any(e);if(0===s.length)throw new Error("Rev not found");return s.filter(t=>null===t.previous)[0].rev}static async next(t){const e=new Ht({name:`Output.next.${Math.random()}`,text:'SELECT "rev" FROM "Output" WHERE "previous" = $1',values:[t]});const s=await rt.any(e);if(s.length>0)return s;const a=new Ht({name:`Output.next2.${Math.random()}`,text:'SELECT "rev" FROM "Output" WHERE "rev" = $1 AND "isObject" = true',values:[t]});if(!((await rt.any(a)).length>0))throw new Error("Rev not found")}static async prev(t){const e=new Ht({name:`Output.prev.${Math.random()}`,text:'SELECT "previous" FROM "Output" WHERE "rev" = $1 and "isObject" = true',values:[t]});const s=await rt.any(e);if(0===s.length)throw new Error("Rev not found");return s}static async descendants(t){const e=new Ht({name:`NonStandard.descendants.${Math.random()}`,text:'WITH RECURSIVE descendants_cte AS (\n        SELECT "rev", "previous" FROM "Output" WHERE "isObject" = true and "rev" = $1\n        UNION ALL\n        SELECT o."rev", o."previous" FROM "Output" o\n        INNER JOIN descendants_cte d ON o."previous" = d."rev"\n      )\n      SELECT * FROM descendants_cte',values:[t]});return(await rt.any(e)).map(t=>t.rev)}static async latest(t){const e=new Ht({name:`NonStandard.latest.${Math.random()}`,text:'WITH RECURSIVE revUpdates AS (\n        SELECT "rev", "previous" FROM "Output" WHERE "isObject" = true and "rev" = $1\n        UNION ALL\n        SELECT o."rev", o."previous" FROM "Output" o\n        INNER JOIN revUpdates r ON o."previous" = r."rev"\n      )\n      SELECT * FROM revUpdates',values:[t]});const s=await rt.any(e);if(0===s.length)throw new Error("Rev not found");const a=Object.fromEntries(s.map(t=>[t.previous,t.rev]));let n=t;for(;a[n];)n=a[n];return n}}class Ct{static async select(t){return Nt.select(t)}static async selectByRev(t){return Nt.selectByRev(t)}static async insert(t){return Nt.insert(t)}static async eraseBlockHash(t){return Nt.eraseBlockHash(t)}static updateMods=async t=>{await Nt.updateMods(t)};static async listSentOutputs(t){return Nt.listSentOutputs(t)}static async listReceivedOutputs(t){return Nt.listReceivedOutputs(t)}static async listTxs(t){return Nt.listTxs(t)}static async getAncestorTxs(t){return Nt.getAncestorTxs(t)}static async query(t){return Nt.query(t)}static async getTXOs(t){return Nt.getTXOs(t)}static async first(t){return Nt.first(t)}static async prev(t){return Nt.prev(t)}static async descendants(t){return Nt.descendants(t)}static async next(t){return Nt.next(t)}static async latest(t){return Nt.latest(t)}}const At=function(t=S,s=O){switch(t){case"BTC":switch(s){case"mainnet":return e.bitcoin;case"testnet":return e.testnet;case"regtest":return e.regtest;default:throw new Error(`Invalid network ${s}`)}case"LTC":switch(s){case"mainnet":return e.litecoin;case"testnet":return e.litecointestnet;case"regtest":return e.litecoinregtest;default:throw new Error(`Invalid network ${s}`)}case"PEPE":switch(s){case"mainnet":return e.pepecoin;case"testnet":return e.pepecointestnet;case"regtest":return e.pepecoinregtest;default:throw new Error(`Invalid network ${s}`)}case"DOGE":switch(s){case"mainnet":return e.dogecoin;case"testnet":return e.dogecointestnet;case"regtest":return e.dogecoinregtest;default:throw new Error(`Invalid network ${s}`)}default:throw new Error(`Invalid chain ${t}`)}}(S,O);class Lt{static insert(t){return Ct.insert(t)}static buildQueryKey(t){return st.filter(e=>void 0!==t[e]).map(e=>`${e}=${encodeURIComponent(t[e])}`).join("&")}static async getSubscriptionKeys(t){const e=new Set;const s={};void 0!==t.satoshis&&(s.satoshis=t.satoshis.toString()),t.asm&&(s.asm=t.asm),t.mod&&(s.mod=t.mod),t.expHash&&(s.expHash=t.expHash);const a=Object.keys(s);for(let t=1;t<1<<a.length;t++){const n={};for(let e=0;e<a.length;e++)if(t&1<<e){const t=a[e];n[t]=s[t]}e.add(this.buildQueryKey(n))}try{const s=await Lt.first(t.rev);s&&e.add(`id=${encodeURIComponent(s)}`)}catch{}return e}static insertAndUpdateMod=async(t,e)=>{await Promise.all([Lt.insert(t),xt.insert(e)]);const s=await Lt.getModUpates(t);return await Lt.updateMods(s),t.map(t=>({...t,mod:s.find(e=>e.rev===t.rev)?.mod||t.mod}))};static getOutputs=(t,e=null,s=null)=>t.flatMap(({outs:t,txId:o,zip:i,onChainMetaData:c},p)=>{const{exp:u="",mod:l=null}=c;return t.map(({script:t,value:c},d)=>{const h=d<i.length;let m;try{m=a.toASM(t)}catch(t){m="[error]"}const w=h&&void 0===i[d][0];return{rev:`${o}:${d}`,address:gt(()=>r.fromOutputScript(t,At)),satoshis:c,asm:m,isObject:h,mod:w?l:null,previous:h?i[d][0]:null,expHash:h?n.sha256(Buffer.from(u)).toString("hex"):null,blockHash:s,blockHeight:e,blockIndex:p}})});static getModUpates=async t=>{const e=[];return await Promise.all(t.map(async t=>{const s=await Lt.getModUpdatesForOutput(t);s&&(await Ct.descendants(t.rev)).forEach(t=>{e.push({rev:t,mod:s})})})),e};static async getModUpdatesForOutput({isObject:t,previous:e,rev:s,mod:a}){if(!t)return null;if(void 0===e)return a;const n=await Ct.selectByRev(e);return n?.mod?.length>0?n.mod:null}static updateMods=async t=>{await Ct.updateMods(t)};static getAncestorTxs=async t=>Ct.getAncestorTxs(t);static select=async t=>Ct.select(t);static eraseBlockHash=async t=>{await Ct.eraseBlockHash(t)};static listSentOutputs=async t=>Ct.listSentOutputs(t);static listReceivedOutputs=async t=>Ct.listReceivedOutputs(t);static listTxs=async t=>Ct.listTxs(t);static latest=async t=>Ct.latest(t);static first=async t=>Ct.first(t);static query=async t=>Ct.query(t);static getTXOs=async t=>Ct.getTXOs(t)}class Ft{static update=async t=>ct.update(t);static insertBatch=async t=>ct.insertBatch(t);static deleteAll=async()=>ct.deleteAll();static count=async()=>ct.count();static waitUntilSetup=async(t,e)=>{Q.debug(`WorkerId ${t} waiting for master worker to reorg up to ${e} workers...`),await h(async()=>{const s=await ct.count();if(s===e)return!0;throw Q.info(`WorkerId ${t} waiting until setup done. Actual ${s}, numWorkers ${e}`),new Error("Not all workers have reorged")},{startingDelay:500})};static selectByWorkerId=async t=>ct.selectByWorkerId(t);static setup=async t=>{0===await lt.count()&&(await dt.insert(1),Q.info(`[wid 0 pid: ${process.pid}: registering block sync status on block 1`)),await ct.count()===t?Q.debug(`[wid 1 pid: ${process.pid}: all workers have already registered`):await Ft.register(t,await ct.min());const e=await kt.selectAll();if(e.length>0){Q.info(`[wid 0 pid: ${process.pid}: found ${e.length} orphans`);const s=e.map(t=>t.hash);await Tt.deleteByHash(s),await xt.eraseBlockHash(s),await Lt.eraseBlockHash(s);const a=await ct.min();const n=Math.min(e[0].height-1,a);Q.info(`[wid 0 pid: ${process.pid}: last block synced from workers ${a}`),Q.info(`[wid 0 pid: ${process.pid}: last valid block at ${e[0].height-1}`),Q.info(`[wid 0 pid: ${process.pid}: resuming at ${n}`),await Ft.register(t,n),await kt.process(e)}};static register=async(t,e)=>{const s=[];let a=Math.max(1,e);for(let e=1;e<=t;e+=1,a+=1)s.push(e,a);Q.info(`[wid 0 pid: ${process.pid}: reorging sync status for ${t} workers...${s}`),await ct.deleteAll(),await ct.insertBatch(s)};static min=async()=>ct.min()}const Ut=new $({protocol:U,user:C,pass:A,host:L,port:parseInt(F,10)});const Pt=g.promisify($.prototype.createwallet.bind(Ut));const Wt=g.promisify($.prototype.generateToAddress.bind(Ut));const Dt=g.promisify($.prototype.getaddressinfo.bind(Ut));const _t=g.promisify($.prototype.getBlock.bind(Ut));const jt=g.promisify($.prototype.getBlockchainInfo.bind(Ut));const Gt=g.promisify($.prototype.getBlockHash.bind(Ut));const Kt=g.promisify($.prototype.getRawTransaction.bind(Ut));const Yt=g.promisify($.prototype.getRawTransaction.bind(Ut));const Xt=g.promisify($.prototype.getTransaction.bind(Ut));const Vt=g.promisify($.prototype.getNewAddress.bind(Ut));const qt={createwallet:Pt,generateToAddress:Wt,getaddressinfo:Dt,getBlock:_t,getBlockchainInfo:jt,getBlockHash:Gt,getRawTransaction:Kt,getTransaction:Xt,importaddress:g.promisify($.prototype.importaddress.bind(Ut)),invalidateBlock:g.promisify($.prototype.invalidateBlock.bind(Ut)),listunspent:g.promisify($.prototype.listunspent.bind(Ut)),sendRawTransaction:g.promisify($.prototype.sendRawTransaction.bind(Ut)),getNewAddress:Vt,sendToAddress:g.promisify($.prototype.sendToAddress.bind(Ut)),getRawTransactionJSON:Yt,validateaddress:g.promisify($.prototype.validateaddress.bind(Ut))};class Jt{static async getBulkTransactions(t){return(await Promise.all(t.map(t=>qt.getRawTransaction(t,0)))).map(t=>t.result)}static async getRawTransaction(t,e){const{result:s}=await qt.getRawTransaction(t,e);return"object"==typeof s&&s.vout.forEach(t=>{t.value=BigInt(Math.round(1e8*t.value))}),s}static async getRawTransactionsJSON(t){return{txId:(e=(await qt.getRawTransactionJSON(t,1)).result).txid,txHex:e.hex,vsize:e.vsize,version:e.version,locktime:e.locktime,ins:e.vin.map(t=>t.coinbase?{coinbase:t.coinbase,sequence:t.sequence}:{txId:t.txid,vout:t.vout,script:t.scriptSig.hex,sequence:t.sequence}),outs:e.vout.map(t=>{let e;return t.scriptPubKey.addresses?[e]=t.scriptPubKey.addresses:e=t.scriptPubKey.address?t.scriptPubKey.address:void 0,{address:e,script:t.scriptPubKey.hex,value:BigInt(Math.round(1e8*t.value)).toString()}})};var e}static async sendRawTransaction(t){const{result:e,error:s}=await qt.sendRawTransaction(t);if(s)throw Q.error(s),new Error("Error sending transaction");return e}static getUtxos=async t=>{let e;e="DOGE"===S||"PEPE"===S?await qt.validateaddress(t):await qt.getaddressinfo(t),void 0===e.result.timestamp&&(Q.info(`Importing address: ${t}`),await qt.importaddress(t,!1));const s=await qt.listunspent(0,999999,[t]);return s.result.forEach(t=>{t.amount=BigInt(t.amount)}),s.result};static walletSetup=async()=>{if("regtest"===O){if(Q.info(`Node is starting for chain ${S} and network ${O} \n\nStarting Wallet setup`),"LTC"===S){const{result:t}=await qt.getBlockchainInfo();const e=t.blocks;if(e<tt){const{result:t}=await qt.getNewAddress("","legacy");const s=tt-e-1;s&&await qt.generateToAddress(s,t);const{result:a}=await qt.getNewAddress("mweb","mweb");await qt.sendToAddress(a,1),await qt.generateToAddress(1,t),Q.info("MWEB setup is complete")}}if("BTC"===S){const{result:t}=await qt.getNewAddress("","legacy");await qt.generateToAddress(200,t),Q.info("Wallet setup is complete")}if("PEPE"===S||"DOGE"===S){const{result:t}=await qt.getNewAddress("");await qt.generateToAddress(200,t),Q.info("Wallet setup is complete")}}};static createWallet=async()=>{try{await qt.createwallet(P,!1,!1,"",!1,!1)}catch(t){if(t.message.includes("already exists"))return void Q.info(`Wallet ${P} already exists`);Q.warn(`Wallet creation failed with error '${t.message}'`)}};static checkBlockchainProgress=async t=>{const e=await h(async()=>{const e=await qt.getBlockchainInfo();const s=(100*parseFloat(e.result.verificationprogress)).toFixed(4);const{blocks:a}=e.result;if(Q.info(`Zmq. Bitcoind { percentage:${s}%, blocks:${a} }`),parseFloat(e.result.verificationprogress)<=t)throw new Error("Node not ready yet");return e},{startingDelay:6e4,timeMultiple:1,numOfAttempts:8760});const s=(100*parseFloat(e.result.verificationprogress)).toFixed(4);const a=e.result.blocks;Q.info(`BCN reaches sync end...at { bitcoind.progress:${s}%, bitcoindSyncedHeight:${a} }`)}}class zt{static getRawHexs=async t=>Jt.getBulkTransactions(t);static getRawHEX=async t=>Jt.getRawTransaction(t,0);static getRawJSON=async t=>Jt.getRawTransactionsJSON(t);static sendRaw=async t=>Jt.sendRawTransaction(t);static getUtxos=async t=>Jt.getUtxos(t);static parseTransactions=async(t,e,s,a,n)=>{let r=t;"LTC"===e&&(r=t.filter(t=>"08"!==t.hex.slice(10,12)));const o=[];for(const t of r)try{let{hex:r}=t;r||(r=(await Jt.getRawTransaction(t.txid,1)).hex);const i=E.fromHex(r);i&&("BTC"===e&&"mainnet"===s&&et.some(t=>t.height===n&&t.txId===i.txId)?Q.warn(`wid ${a} pid: ${process.pid}: skipping conflicting transaction ${i.txId} in block ${n}`):o.push(i))}catch(e){Q.error(`[wid ${a} pid: ${process.pid}: failed to parse transaction in block ${n}\n          error message: ${e.message}\n          transaction: ${JSON.stringify(t)}`)}return o};static walletSetup=async()=>Jt.walletSetup()}class Qt{static getTxBatch=async(t,e,s,a=S,n=O)=>{const r=[];const o=[];const i=[];let c;let p;let u=!1;for(;9*r.length<1e4&&3*o.length<1e4;){try{const{result:e}=await qt.getBlockHash(t);p=e;const{result:s}=await qt.getBlock(e,2);c=s}catch(s){Q.debug(`[wid ${e} pid: ${process.pid}]: waiting to get block hash or block for height: ${t} ${s.message}`),u=!0;break}try{const s=await zt.parseTransactions(c.tx,a,n,e,t);r.push(...Lt.getOutputs(s,t,p)),o.push(...xt.getInputs(s,p))}catch(t){Q.error(`[wid ${e} pid: ${process.pid}]: failed to get inputs or outputs for hash: ${p} ${t.message} ${t.stack}`)}i.push(t),t+=s}return{outputs:r,inputs:o,batchBlockToSync:t,atTip:u,blocks:i}};static syncTxs=async(t,e,s)=>{let a=t;for(Q.debug(`[wid ${e} pid: ${process.pid}]: starting to sync txs from block: ${a} - numWorkers: ${s}`);;)try{const{outputs:t,inputs:n,blocks:r,batchBlockToSync:o,atTip:i}=await this.getTxBatch(a,e,s);if(t.length>0||n.length>0){try{await Lt.insertAndUpdateMod(t,n)}catch(s){Q.error(`[wid ${e} pid: ${process.pid}: error ${s.message} ${s.stack} cannot insert outputs or inputs. \n                blocks ${r} - #outputs ${t.length} #inputs ${n.length}`)}await Ft.update({blockToSync:o,workerId:e}),Q.debug(`[wid ${e} pid: ${process.pid}: backfilling range [${a}-${o-1}] - #outputs ${t.length} #inputs ${n.length} `),a=o}i&&await mt(2e3)}catch(t){Q.error(`[wid ${e} pid: ${process.pid}]: sync failed to process block ${a} ${t.message} ${t.stack}`)}};static findOrphans=async t=>{let e;try{const{result:s}=await qt.getBlock(t,2);e=s}catch(t){return await mt(2e3),[]}if(1===e?.height)return[];const s=await Tt.selectByHeight(e.height-1);if(!s)return[];if(e?.previousblockhash===s?.hash)return[];const a=await Qt.findOrphans(e.previousblockhash);const{hash:n,height:r}=s;return[...a,{hash:n,height:r,processed:!1}]};static updateStatus=async(t,e)=>{await dt.update(t);const s=await ct.min();const a=Math.min(s,t);Q.warn(`[wid 0 pid: ${process.pid}: reorg detected, resuming at block min(${s},${t}) = ${a}`),await Ft.register(e,a)};static registerOrphans=async(t,e,s)=>{Q.warn(`[wid 0 pid: ${process.pid}: detected ${t.length} orphaned blocks resuming at height ${e}`),await kt.insertAll(t),await this.updateStatus(e,s)};static getBlockBatch=async(t,e,s,a)=>{const n=[];for(let r=t;n.length<a;r+=1){let a;try{const{result:t}=await qt.getBlockHash(r);a=t}catch(t){break}n.push({hash:a,height:t,previousHash:e});try{if(t>parseInt(N||"",10)){const e=await this.findOrphans(a);e.length&&(ht(s),await this.registerOrphans(e,t-e.length,s.length),Q.warn(`[wid 0 pid: ${process.pid}: exiting ...`),process.exit(0))}}catch(t){Q.error(`[wid 0 pid: ${process.pid}: ${t.message} error at checking block reorgs ${t.stack}`)}t+=1,e=a}return{blockHashes:n,blockToSync:t,previousDbHash:e}};static syncBlocks=async(t,e,s)=>{let a=t;let n=(await Tt.selectByHeight(t-1))?.hash||"";Q.debug(`[wid ${e} pid: ${process.pid}]: starting to sync block: ${t} prev hash: ${n}`);const r=Math.floor(3333.3333333333335);for(;;)try{const t=await this.getBlockBatch(a,n,s,r);t.blockHashes.length&&(await dt.update(t.blockToSync),a=t.blockToSync,n=t.previousDbHash,await Tt.insertBatch(t.blockHashes),Q.debug(`[wip ${e} pid: ${process.pid}: synchronizing up to block num ${t.blockToSync}`)),t.blockHashes.length<r&&await mt(2e3)}catch(t){Q.error(`[wid ${e} pid: ${process.pid}]: failed to process block ${a} ${t.message} ${t.stack}`)}}}o(t);const Zt=[];const te=b?parseInt(b,10):Math.max(i()-1,1);const ee=parseInt(B||"0",10);Q.debug(`[wid ${ee} pid: ${process.pid}]: starting with ${te} threads`);try{if(await(async()=>{await h(async()=>{await rt.one("SELECT 1"),Q.info("Database connection established")},{startingDelay:500})})(),0===ee){Q.info(`[wid  ${ee} pid: ${process.pid}]: connected to the database successfully`),Q.info(`[wid  ${ee} pid: ${process.pid}]: parameters { url: ${x}, chain:${S} network:${O} numWorkers: ${te}}`),await Ft.setup(te);for(let t=1;t<=te;t+=1){Q.debug(`[wid ${ee} pid: ${process.pid}]: spawning worker ${t}`);const e=c("node",["dist/bcn.sync.es.mjs"],{env:{...process.env,BCN_WORKER_ID:`${t}`,BCN_NUM_WORKERS:`${te}`},stdio:"inherit"});e.pid||(Q.error(`[wid ${ee} pid: ${process.pid}]: failed to spawn worker ${t}`),ht(Zt),p(1)),Zt.push(e.pid)}Q.debug(`Spawned workers: ${Zt.map(t=>t).join(", ")}`);const t=await dt.select();await Qt.syncBlocks(t,0,Zt)}else{Q.info(`[wid ${ee} pid: ${process.pid}]: worker ${ee} started`),await Ft.waitUntilSetup(ee,te);const t=await Ft.selectByWorkerId(ee);await Qt.syncTxs(t.blockToSync,t.workerId,te)}}catch(t){Q.error(`[wid ${ee} pid: ${process.pid}]: synchronizing failed with error '${t.message} ${t.stack}'`),ht(Zt),p(1)}
