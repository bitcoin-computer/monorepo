import*as t from"@bitcoin-computer/secp256k1";import{bufferUtils as e,networks as s,crypto as a,address as n,initEccLib as r}from"@bitcoin-computer/nakamotojs";import o from"node:cluster";import{availableParallelism as i}from"node:os";import c from"dotenv";import l from"winston";import p from"winston-daily-rotate-file";import u from"bitcoind-rpc";import d from"util";import h from"pg-promise";import y from"pg-monitor";import{backOff as m}from"exponential-backoff";import w from"fs";import{Transaction as g,Computer as E}from"@bitcoin-computer/lib";c.config();const $=process.env.BCN_CHAIN;const v=process.env.BCN_NETWORK;const{BCN_PORT:f}=process.env;process.env,process.env;const{BCN_DEBUG_MODE:O}=process.env;const{BCN_LOG_MAX_FILES:T}=process.env;const{BCN_LOG_MAX_SIZE:S}=process.env;const{BCN_LOG_ZIP:R}=process.env;const{BCN_SHOW_CONSOLE_LOGS:I}=process.env;const{BCN_SHOW_DB_LOGS:B}=process.env;process.env,process.env,process.env,process.env,process.env;const{BCN_THREADS:k}=process.env;process.env,process.env;const b=process.env.BCN_QUERY_LIMIT||"1000";const x=process.env.BCN_URL||`http://127.0.0.1:${f}`;process.env.BCN_ENV;const{BITCOIN_RPC_USER:M}=process.env;const{BITCOIN_RPC_PASSWORD:H}=process.env;const{BITCOIN_RPC_HOST:N}=process.env;const{BITCOIN_RPC_PORT:A}=process.env;const{BITCOIN_RPC_PROTOCOL:C}=process.env;const{BITCOIN_DEFAULT_WALLET:L}=process.env;const{POSTGRES_USER:P}=process.env;const{POSTGRES_PASSWORD:D}=process.env;const{POSTGRES_DB:F}=process.env;const{POSTGRES_HOST:U}=process.env;const{POSTGRES_PORT:W}=process.env;l.addColors({error:"red",warn:"yellow",info:"green",http:"magenta",debug:"white"});const _=l.format.combine(l.format.colorize(),l.format.timestamp({format:"YYYY-MM-DD HH:mm:ss:ms"}),l.format.json(),l.format.printf((t=>`${t.timestamp} [${t.level.slice(5).slice(0,-5)}] ${t.message}`)));const Y={zippedArchive:"true"===R,maxSize:S,maxFiles:T,dirname:"logs"};const K=[];"true"===I&&K.push(new l.transports.Console({format:l.format.combine(l.format.colorize(),l.format.timestamp({format:"MM-DD-YYYY HH:mm:ss"}),l.format.printf((t=>`${t.timestamp} ${t.level} ${t.message}`)))}));const G=parseInt(O,10);G>=0&&K.push(new p({filename:"error-%DATE%.log",datePattern:"YYYY-MM-DD",level:"error",...Y})),G>=1&&K.push(new p({filename:"warn-%DATE%.log",datePattern:"YYYY-MM-DD",level:"warn",...Y})),G>=2&&K.push(new p({filename:"info-%DATE%.log",datePattern:"YYYY-MM-DD",level:"info",...Y})),G>=3&&K.push(new p({filename:"http-%DATE%.log",datePattern:"YYYY-MM-DD",level:"http",...Y})),G>=4&&K.push(new p({filename:"debug-%DATE%.log",datePattern:"YYYY-MM-DD",level:"debug",...Y}));const V=l.createLogger({levels:{error:0,warn:1,info:2,http:3,debug:4},format:_,transports:K,exceptionHandlers:[new l.transports.File({filename:"logs/exceptions.log"})],rejectionHandlers:[new l.transports.File({filename:"logs/rejections.log"})]});const j=new u({protocol:C,user:M,pass:H,host:N,port:parseInt(A,10)});const q=d.promisify(u.prototype.createwallet.bind(j));const J=d.promisify(u.prototype.generateToAddress.bind(j));const z=d.promisify(u.prototype.getaddressinfo.bind(j));const X=d.promisify(u.prototype.getBlock.bind(j));const Z=d.promisify(u.prototype.getBlockchainInfo.bind(j));const Q=d.promisify(u.prototype.getBlockHash.bind(j));const tt=d.promisify(u.prototype.getRawTransaction.bind(j));const et=d.promisify(u.prototype.getRawTransaction.bind(j));const st=d.promisify(u.prototype.getTransaction.bind(j));const at=d.promisify(u.prototype.getNewAddress.bind(j));const nt={createwallet:q,generateToAddress:J,getaddressinfo:z,getBlock:X,getBlockchainInfo:Z,getBlockHash:Q,getRawTransaction:tt,getTransaction:st,importaddress:d.promisify(u.prototype.importaddress.bind(j)),invalidateBlock:d.promisify(u.prototype.invalidateBlock.bind(j)),listunspent:d.promisify(u.prototype.listunspent.bind(j)),sendRawTransaction:d.promisify(u.prototype.sendRawTransaction.bind(j)),getNewAddress:at,sendToAddress:d.promisify(u.prototype.sendToAddress.bind(j)),getRawTransactionJSON:et};c.config();const{version:rt}=JSON.parse(w.readFileSync("package.json","utf8"));rt||process.env.BCN_SERVER_VERSION;const ot=parseInt(process.env.MWEB_HEIGHT||"",10)||432;const it={error:(t,e)=>{if(e.cn){const{host:s,port:a,database:n,user:r,password:o}=e.cn;V.debug(`Waiting for db to start { message:${t.message} host:${s}, port:${a}, database:${n}, user:${r}, password: ${o}`)}},noWarnings:!0};"true"===B&&(y.isAttached()?y.detach():(y.attach(it),y.setTheme("matrix")));const ct=h(it)({host:U,port:parseInt(W,10),database:F,user:P,password:D,allowExitOnIdle:!0,idleTimeoutMillis:100});const{PreparedStatement:lt}=h;class pt{static async selectByWorkerId(t){const e=new lt({name:`TxStatus.select.${Math.random()}`,text:'SELECT "blockToSync", "workerId" FROM "TxStatus" WHERE "workerId" = $1',values:[t]});return ct.oneOrNone(e)}static async update({blockToSync:t,workerId:e}){const s=new lt({name:`TxStatus.update.${Math.random()}`,text:'UPDATE "TxStatus" SET "blockToSync" = $1 WHERE "workerId" = $2',values:[t,e]});await ct.any(s)}static async count(){const t=new lt({name:`TxStatus.count.${Math.random()}`,text:'SELECT COUNT(*) FROM "TxStatus"'});const e=await ct.oneOrNone(t);return parseInt(e?.count,10)||0}static async min(){const t=new lt({name:`TxStatus.min.${Math.random()}`,text:'SELECT MIN("blockToSync") FROM "TxStatus"'});const e=await ct.oneOrNone(t);return parseInt(e?.min,10)||0}static async deleteAll(){const t=new lt({name:`TxStatus.delete.${Math.random()}`,text:'DELETE FROM "TxStatus"'});await ct.any(t)}static async insertBatch(t){const e=[];for(let s=1;s<=t.length;s+=2)e.push(`($${s}, $${s+1})`);const s=e.join(",");const a=new lt({name:`TxStatus.reorg.${Math.random()}`,text:`INSERT INTO "TxStatus"("workerId", "blockToSync") VALUES ${s}`,values:t});await ct.any(a)}}class ut{static async selectByWorkerId(t){return pt.selectByWorkerId(t)}static async update(t){await pt.update(t)}static async count(){return pt.count()}static async insertBatch(t){await pt.insertBatch(t)}static async min(){return pt.min()}static async deleteAll(){await pt.deleteAll()}}const{PreparedStatement:dt}=h;class ht{static async select(){const t=new dt({name:`BlockStatus.select.${Math.random()}`,text:'SELECT "blockToSync" FROM "BlockStatus"'});const e=await ct.oneOrNone(t);return parseInt(e?.blockToSync,10)||null}static async update(t){const e=new dt({name:`BlockStatus.update.${Math.random()}`,text:'UPDATE "BlockStatus" SET "blockToSync" = $1',values:[t]});await ct.any(e)}static async insert(t){const e=new dt({name:`BlockStatus.insert.${Math.random()}`,text:'INSERT INTO "BlockStatus"("blockToSync") VALUES ($1)',values:[t]});await ct.any(e)}static async count(){const t=new dt({name:`BlockStatus.count.${Math.random()}`,text:'SELECT COUNT(*) FROM "BlockStatus"'});const e=await ct.oneOrNone(t);return parseInt(e?.count,10)||0}static async delete(){const t=new dt({name:`BlockStatus.delete.${Math.random()}`,text:'DELETE FROM "BlockStatus"'});await ct.any(t)}}class yt{static async select(){return ht.select()}static async update(t){await ht.update(t)}static async insert(t){await ht.insert(t)}static async count(){return ht.count()}static async delete(){await ht.delete()}}class mt{static update=async t=>yt.update(t);static select=async()=>yt.select();static insert=async t=>yt.insert(t);static count=async()=>yt.count();static delete=async()=>yt.delete()}const{PreparedStatement:wt}=h;class gt{static async selectByHeight(t){const e=new wt({name:`Block.select.${Math.random()}`,text:'SELECT "hash", "height", "previousHash" FROM "Block" WHERE "height" = $1',values:[t]});return ct.one(e)}static async insert(t){const e=new wt({name:`Block.insert.${Math.random()}`,text:'INSERT INTO "Block" ("hash", "height", "previousHash") VALUES ($1, $2, $3)',values:[t.hash,t.height,t.previousHash]});await ct.none(e)}static async deleteAll(){const t=new wt({name:`Block.delete.${Math.random()}`,text:'DELETE FROM "Block"',values:[]});await ct.none(t)}static async deleteByHash(t){const e=t.map((t=>t)).join("', '");const s=new wt({name:`Block.deleteByHash.${Math.random()}`,text:`DELETE FROM "Block" WHERE "hash" IN ('${e}')`});await ct.none(s)}}class Et{static selectByHeight=async t=>gt.selectByHeight(t);static insert=async t=>gt.insert(t);static deleteAll=async()=>gt.deleteAll();static deleteByHash=async t=>gt.deleteByHash(t);static waitForDbBlockHash=async(t,e)=>(await m((async()=>{let s;try{s=await gt.selectByHeight(t)}catch(s){throw V.info(`[wid ${e} pid: ${process.pid}]: waiting for DB to get block ${t} ...`),s}return s}),{startingDelay:1e4,timeMultiple:1,numOfAttempts:720})).hash}class $t{static selectByHeight=async t=>Et.selectByHeight(t);static insert=async t=>Et.insert(t);static deleteAll=async()=>Et.deleteAll();static deleteByHash=async t=>Et.deleteByHash(t);static waitForDbBlockHash=async(t,e)=>Et.waitForDbBlockHash(t,e)}const{PreparedStatement:vt}=h;class ft{static async selectAll(){const t=new vt({name:`Orphan.select.${Math.random()}`,text:'SELECT * FROM "Orphan"'});return(await ct.any(t)).map((t=>t.hash))}static async insertAll(t){const e=t.map((t=>`('${t}')`)).join(",");const s=new vt({name:`Orphan.insert.${Math.random()}`,text:`INSERT INTO "Orphan" (hash) VALUES ${e}`});await ct.none(s)}static async deleteAll(){const t=new vt({name:`Orphan.delete.${Math.random()}`,text:'DELETE FROM "Orphan"',values:[]});await ct.none(t)}}class Ot{static selectAll=async()=>ft.selectAll();static insertAll=async t=>ft.insertAll(t);static deleteAll=async()=>ft.deleteAll()}class Tt{static selectAll=async()=>Ot.selectAll();static insertAll=async t=>Ot.insertAll(t);static deleteAll=async()=>Ot.deleteAll()}const St=(t,e)=>{const s=[];for(let a=0;a<t.length;a+=e){const n=Math.min(a+e,t.length);const r=t.slice(a,n);s.push(r)}return s};const Rt=t=>{const e=[];for(let s=1;s<=t;s+=3){const t=`($${s},$${s+1},$${s+2})`;e.push(t)}return e.join(",")};const It=t=>{const e=[];for(let s=1;s<=t;s+=10){const t=`($${s},$${s+1},$${s+2},$${s+3},$${s+4},$${s+5},$${s+6},$${s+7},$${s+8},$${s+9})`;e.push(t)}return e.join(",")};const Bt=t=>{try{return t()}catch{return null}};const{PreparedStatement:kt}=h;class bt{static async select(t){const e=new kt({name:`Input.select.${Math.random()}`,text:'SELECT "outputSpent", "spendingInput", "blockHash" FROM "Input" WHERE "outputSpent" = $1',values:[t]});return ct.any(e)}static async insert(t){await Promise.all(St(t,3333).map((t=>{const e=t.flatMap((({outputSpent:t,spendingInput:e,blockHash:s})=>[t,e,s]));return ct.none(new kt({name:`Input.insert.${Math.random()}`,text:`INSERT INTO "Input"("outputSpent", "spendingInput", "blockHash") VALUES ${Rt(e.length)} ON CONFLICT DO NOTHING`,values:e}))})))}static async updateBlockHash(t,e){await Promise.all(St(t,1e4).map((t=>{const s=t.join("','");return ct.none(new kt({name:`Input.updateBlockHash.${Math.random()}`,text:`UPDATE "Input" SET "blockHash" = $1 WHERE "spendingInput" IN ('${s}')`,values:[e]}))})))}static async eraseBlockHash(t){await Promise.all(St(t,1e4).map((t=>{const e=t.join("','");return ct.none(new kt({name:`Input.eraseBlockHash.${Math.random()}`,text:`UPDATE "Input" SET "blockHash" = NULL WHERE "blockHash" IN ('${e}')`}))})))}static async count(t){const e=t.map((t=>t.outputSpent));const s=new kt({name:`Input.belong.${Math.random()}`,text:'SELECT count(*) FROM "Input" WHERE "outputSpent" LIKE ANY ($1)',values:[[e]]});const a=await ct.oneOrNone(s);return parseInt(a?.count,10)||0}}class xt{static async select(t){return bt.select(t)}static async insert(t){return bt.insert(t)}static async updateBlockHash(t,e){return bt.updateBlockHash(t,e)}static async eraseBlockHash(t){return bt.eraseBlockHash(t)}}class Mt{static insert=async(t,s=null)=>{const a=t.flatMap((({ins:t,txId:e})=>t.map(((t,s)=>({input:t,index:s,txId:e}))))).filter((({input:t})=>!g.isCoinbaseHash(t.hash))).map((({input:t,index:s,txId:a})=>{return{outputSpent:`${n=t.hash,e.reverseBuffer(Buffer.from(n)).toString("hex")}:${t.index}`,spendingInput:`${a}:${s}`,blockHash:null};var n}));if(await xt.insert(a),s){const t=a.map((({spendingInput:t})=>t));await xt.updateBlockHash(t,s)}};static select=async t=>xt.select(t);static updateBlockHash=async(t,e)=>{await xt.updateBlockHash(t,e)};static eraseBlockHash=async t=>{await xt.eraseBlockHash(t)}}function Ht(t){if(!function(t){return/^[0-9A-Fa-f]{64}:\d+$/.test(t)}(t))throw new Error("Invalid rev")}const{PreparedStatement:Nt}=h;class At{static async listSentOutputs(t){const e=new Nt({name:`Output.listSentTxs.${Math.random()}`,text:'SELECT "Input"."spendingInput" AS "output", "Output"."satoshis" AS "amount"\n        FROM "Output" INNER JOIN "Input" ON "Output".rev = "Input"."outputSpent" \n        WHERE "Output"."address" = $1',values:[t]});return(await ct.any(e)).map((t=>({...t,amount:parseInt(t.amount,10)||0})))}static async listReceivedOutputs(t){const e=new Nt({name:`Output.listReceivedTxs.${Math.random()}`,text:'SELECT "Output"."rev" as "output", "Output"."satoshis" as "amount" FROM "Output" WHERE "address" = $1',values:[t]});return(await ct.any(e)).map((t=>({...t,amount:parseInt(t.amount,10)||0})))}static async listTxs(t){const e=new Nt({name:`Output.listTxs.${Math.random()}`,text:'WITH\n              -- List all txs sent from a given address\n              SENT AS (\n                SELECT split_part("Input"."spendingInput",\':\',1) as "txId", SUM("Output".satoshis) as "satoshis"\n                FROM "Output" INNER JOIN "Input" ON "Output".rev = "Input"."outputSpent"  \n                WHERE "Output".address = $1\n                GROUP BY split_part("Input"."spendingInput",\':\',1)\n              ),\n              -- List all tx received from a given address\n              RECEIVED AS (\n                SELECT SPLIT_PART("Output"."rev",\':\',1) as "txId", SUM("Output"."satoshis") as "satoshis" \n                FROM "Output" \n                WHERE "address" = $1\n                GROUP BY "txId"\n              )\n\n            SELECT\n              RECEIVED."txId", \n              coalesce(SENT."satoshis", 0) as "inputsSatoshis", \n              coalesce(RECEIVED."satoshis", 0) as "outputsSatoshis", \n              coalesce(RECEIVED."satoshis",0) - coalesce(SENT."satoshis",0) as "satoshis"\n            FROM\n              SENT RIGHT JOIN RECEIVED ON SENT."txId" = RECEIVED."txId";',values:[t]});const s=(await ct.any(e)).map((t=>({...t,inputsSatoshis:parseInt(t.inputsSatoshis,10)||0,outputsSatoshis:parseInt(t.outputsSatoshis,10)||0,satoshis:parseInt(t.satoshis,10)||0})));return{sentTxs:s.filter((t=>t.satoshis<0)).map((t=>({...t,satoshis:Math.abs(t.satoshis)}))),receivedTxs:s.filter((t=>t.satoshis>=0))}}static async select(t){const e=new Nt({name:`Output.select.${Math.random()}`,text:'SELECT "address", "satoshis", "scriptPubKey", "rev", "publicKeys", "hash", "mod", "isTbcOutput", "previous", "blockHash" FROM "Output" WHERE "address" = $1',values:[t]});return ct.any(e)}static async insert(t){await Promise.all(St(t,1e3).map((t=>{const e=t.flatMap((({rev:t,address:e,satoshis:s,scriptPubKey:a,isTbcOutput:n,publicKeys:r,mod:o,previous:i,hash:c,blockHash:l})=>[t,e,s,a,n,r,o,i,c,l]));return ct.none(new Nt({name:`Output.insert.${Math.random()}`,text:`INSERT INTO "Output"("rev", "address", "satoshis", "scriptPubKey", "isTbcOutput",\n             "publicKeys", "mod", "previous", "hash", "blockHash") VALUES ${It(e.length)} ON CONFLICT DO NOTHING`,values:e}))})))}static async eraseBlockHash(t){await Promise.all(St(t,1e4).map((t=>{const e=t.join("','");return ct.none(new Nt({name:`Output.eraseBlockHash.${Math.random()}`,text:`UPDATE "Output" SET "blockHash" = NULL WHERE "blockHash" IN ('${e}')`}))})))}static async updateBlockHash(t,e){await Promise.all(St(t,1e4).map((t=>{const s=t.join("','");return ct.none(new Nt({name:`Output.updateBlockHash.${Math.random()}`,text:`UPDATE "Output" SET "blockHash" = $1 WHERE "rev" IN ('${s}')`,values:[e]}))})))}static async getIdByRev(t){const e=new Nt({name:`NonStandard.recursiveUpdates.${Math.random()}`,text:'WITH RECURSIVE revUpdates AS (\n        SELECT "rev", "previous" FROM "Output" WHERE "isTbcOutput" = true and "rev" = $1\n        UNION ALL\n        SELECT o."rev", o."previous" FROM "Output" o\n        INNER JOIN revUpdates r ON r."previous" = o."rev"\n      )\n      SELECT * FROM revUpdates',values:[t]});const s=(await ct.any(e)).filter((t=>null===t.previous));return s[0]?.rev}static async getIdsByRevs(t){return Promise.all(t.map((t=>this.getIdByRev(t))))}static async getLatestRev(t){const e=new Nt({name:`NonStandard.recursiveUpdates.${Math.random()}`,text:'WITH RECURSIVE revUpdates AS (\n        SELECT "rev", "previous" FROM "Output" WHERE "isTbcOutput" = true and "rev" = $1\n        UNION ALL\n        SELECT o."rev", o."previous" FROM "Output" o\n        INNER JOIN revUpdates r ON o."previous" = r."rev"\n      )\n      SELECT * FROM revUpdates',values:[t]});const s=await ct.any(e);const a=Object.fromEntries(s.map((t=>[t.previous,t.rev])));let n=t;for(;a[n];)n=a[n];return n}static async getLatestRevs(t){return Promise.all(t.map(this.getLatestRev))}static async getIdsByMod(t){const e=new Nt({name:`Output.getIdsByMod.${Math.random()}`,text:'SELECT "rev" FROM "Output" WHERE "mod" = $1',values:[t]});return(await ct.any(e)).map((t=>t.rev))}static sqlSuffix(t,e,s){let a="";return s&&(a+=` order by "timestamp" ${s}`),a+=` limit ${t||b}`,e&&(a+=` offset ${e}`),a}static async getRevsByPublicKey(t){const e=new Nt({name:`Output.getRevsByPublicKey.${Math.random()}`,text:'SELECT "rev" FROM "Output" WHERE $1 = ANY("publicKeys")',values:[t]});return(await ct.any(e)).map((t=>t.rev))}static async getUnspentRevsByMod(t,e,s,a){const n=await this.getIdsByMod(t);const r=await this.getLatestRevs(n);const o=new Nt({name:`Output.getUnspentRevsByMod.${Math.random()}`,text:`SELECT "rev" FROM "Output" WHERE "rev" = ANY($1) ${this.sqlSuffix(e,s,a)}`,values:[r]});return(await ct.any(o)).map((t=>t.rev))}static async getUnspentRevsByPublicKey(t,e,s,a){const n=new Nt({name:`Output.getUnspentRevsByPublicKey.${Math.random()}`,text:`SELECT "rev" FROM "Output" WHERE $1 = ANY("publicKeys") AND "isTbcOutput" = true \n      AND NOT EXISTS (SELECT 1 FROM "Input" ip WHERE "ip"."outputSpent" = "Output"."rev") \n      ${this.sqlSuffix(e,s,a)}`,values:[t]});return(await ct.any(n)).map((t=>t.rev))}static async getUnspentRevsByModAndPublicKey(t,e,s,a,n){const r=await this.getUnspentRevsByPublicKey(e,s,a,n);const o=await this.getIdsByRevs(r);const i=new Nt({name:`Output.getLatestRevsByModAndPublicKey.${Math.random()}`,text:'SELECT "rev" FROM "Output" WHERE "mod" = $1 AND "rev" = ANY($2)',values:[t,o]});const c=(await ct.any(i)).map((t=>t.rev));const l=await this.getLatestRevs(c);const p=new Nt({name:`Output.getLatestRevsByModAndPublicKey.${Math.random()}`,text:`SELECT "rev" FROM "Output" WHERE "rev" = ANY($1) ${this.sqlSuffix(s,a,n)}`,values:[l]});return(await ct.any(p)).map((t=>t.rev))}static async getUnspentTbcOutputs(t,e,s){const a=new Nt({name:`Output.getUnspentTbcOutputs.${Math.random()}`,text:`SELECT "rev", "address", "satoshis", "scriptPubKey", "publicKeys", "timestamp"\n        FROM "Output" WHERE "isTbcOutput" = true AND NOT EXISTS\n        (SELECT 1 FROM "Input" ip WHERE "ip"."outputSpent" = "Output"."rev") ${this.sqlSuffix(t,e,s)}`});return(await ct.any(a)).map((t=>t.rev))}static async query(t){const{publicKey:e,limit:s,offset:a,ids:n,mod:r,order:o}=t;const i=parseInt(b||"",10);if(s&&parseInt(s||"",10)>i||n&&n.length>i)throw new Error(`Can't fetch more than ${b} revs.`);if(o&&"ASC"!==o&&"DESC"!==o)throw new Error("Invalid order. Should be ASC or DESC.");return n?(n.map(Ht),this.getLatestRevs(n)):r&&!e?this.getUnspentRevsByMod(r,s,a,o):!r&&e?this.getUnspentRevsByPublicKey(e,s,a,o):r&&e?this.getUnspentRevsByModAndPublicKey(r,e,s,a,o):this.getUnspentTbcOutputs(s,a,o)}}class Ct{static async select(t){return At.select(t)}static async insert(t){return At.insert(t)}static async eraseBlockHash(t){return At.eraseBlockHash(t)}static async updateBlockHash(t,e){return At.updateBlockHash(t,e)}static async listSentOutputs(t){return At.listSentOutputs(t)}static async listReceivedOutputs(t){return At.listReceivedOutputs(t)}static async listTxs(t){return At.listTxs(t)}static async getLatestRev(t){return At.getLatestRev(t)}static async getLatestRevs(t){return At.getLatestRevs(t)}static async getIdByRev(t){return At.getIdByRev(t)}static async query(t){return At.query(t)}}class Lt{static insert=async(t,e=null)=>{const r=function(t=$,e=v){switch(t){case"BTC":switch(e){case"mainnet":return s.bitcoin;case"testnet":return s.testnet;case"regtest":return s.regtest;default:throw new Error(`Invalid network ${e}`)}case"LTC":switch(e){case"mainnet":return s.litecoin;case"testnet":return s.litecointestnet;case"regtest":return s.litecoinregtest;default:throw new Error(`Invalid network ${e}`)}case"PEPE":switch(e){case"mainnet":return s.pepecoin;case"testnet":return s.pepecointestnet;case"regtest":return s.pepecoinregtest;default:throw new Error(`Invalid network ${e}`)}default:throw new Error(`Invalid chain ${t}`)}}($,v);const o=t.flatMap((({outs:t,txId:e,zip:s,ownerData:o,onChainMetaData:i})=>{const{exp:c="",mod:l=""}=i;return t.map((({script:t,value:i},p)=>{const u=p<s.length;return{rev:`${e}:${p}`,address:Bt((()=>n.fromOutputScript(t,r))),satoshis:Math.round(i),scriptPubKey:t.toString("hex"),isTbcOutput:u,publicKeys:u?o[p]._owners:[],mod:u?l:"",previous:u?s[p][0]:null,hash:u?a.sha256(Buffer.from(c)).toString("hex"):null,blockHash:null}}))}));if(await Ct.insert(o),e){const t=o.map((({rev:t})=>t));await Ct.updateBlockHash(t,e)}};static eraseBlockHash=async t=>{await Ct.eraseBlockHash(t)};static listSentOutputs=async t=>Ct.listSentOutputs(t);static listReceivedOutputs=async t=>Ct.listReceivedOutputs(t);static listTxs=async t=>Ct.listTxs(t);static getLatestRev=async t=>Ct.getLatestRev(t);static getLatestRevs=async t=>Ct.getLatestRevs(t);static getIdByRev=async t=>Ct.getIdByRev(t);static query=async t=>Ct.query(t)}class Pt{static update=async t=>ut.update(t);static selectByWorkerId=async t=>ut.selectByWorkerId(t);static deleteAll=async()=>ut.deleteAll();static setup=async t=>{0===await yt.count()&&(await mt.insert(1),V.info(`[wid 0 pid: ${process.pid}: registering block sync status on block 1`)),await ut.count()===t?V.info(`[wid 1 pid: ${process.pid}: all ${t} workers have already registered`):await Pt.register(t,await ut.min());const e=await Tt.selectAll();e.length>0&&(V.info(`[wid 0 pid: ${process.pid}: found ${e.length} orphans`),await $t.deleteByHash(e),await Mt.eraseBlockHash(e),await Lt.eraseBlockHash(e),await Tt.deleteAll())};static register=async(t,e)=>{const s=[];let a=Math.max(1,e);for(let e=1;e<=t;e+=1,a+=1)s.push(e,a);V.info(`[wid 0 pid: ${process.pid}: reorging sync status for ${t} workers...${s}`),await ut.deleteAll(),await ut.insertBatch(s)}}class Dt{static async getTransaction(t){const{result:e}=await nt.getTransaction(t);return e}static async getBulkTransactions(t){return(await Promise.all(t.map((t=>nt.getRawTransaction(t,0))))).map((t=>t.result))}static async getRawTransaction(t,e){const{result:s}=await nt.getRawTransaction(t,e);return s}static async getRawTransactionsJSON(t){return{txId:(e=(await nt.getRawTransactionJSON(t,1)).result).txid,txHex:e.hex,vsize:e.vsize,version:e.version,locktime:e.locktime,ins:e.vin.map((t=>t.coinbase?{coinbase:t.coinbase,sequence:t.sequence}:{txId:t.txid,vout:t.vout,script:t.scriptSig.hex,sequence:t.sequence})),outs:e.vout.map((t=>{let e;return t.scriptPubKey.addresses?[e]=t.scriptPubKey.addresses:e=t.scriptPubKey.address?t.scriptPubKey.address:void 0,{address:e,script:t.scriptPubKey.hex,value:Math.round(1e8*t.value)}}))};var e}static async sendRawTransaction(t){const{result:e,error:s}=await nt.sendRawTransaction(t);if(s)throw V.error(s),new Error("Error sending transaction");return e}static getUtxos=async t=>(void 0===(await nt.getaddressinfo(t)).result.timestamp&&(V.info(`Importing address: ${t}`),await nt.importaddress(t,!1)),(await nt.listunspent(0,999999,[t])).result);static waitForRpcBlockHash=async(t,e)=>(await m((async()=>{let s;try{s=await nt.getBlockHash(t)}catch(s){throw V.info(`[wid ${e} pid: ${process.pid}]: waiting for RPC to get block ${t} ...`),s}return s}),{startingDelay:1e4,timeMultiple:1,numOfAttempts:720})).result;static getBlock=async(t,e)=>nt.getBlock(t,e);static walletSetup=async()=>{if("regtest"===v){if(V.info(`Node is starting for chain ${$} and network ${v}, \n\n. Starting Wallet setup.`),"LTC"===$){const{result:t}=await nt.getBlockchainInfo();const e=t.blocks;if(e<ot){const{result:t}=await nt.getNewAddress("","legacy");const s=ot-e-1;s&&await nt.generateToAddress(s,t);const{result:a}=await nt.getNewAddress("mweb","mweb");await nt.sendToAddress(a,1),await nt.generateToAddress(1,t),V.info("MWEB setup is complete")}}if("BTC"===$){const{result:t}=await nt.getNewAddress("","legacy");await nt.generateToAddress(200,t),V.info("Wallet setup is complete")}if("PEPE"===$){const{result:t}=await nt.getNewAddress("");await nt.generateToAddress(200,t),V.info("Wallet setup is complete")}}};static createWallet=async()=>{try{await nt.createwallet(L,!1,!1,"",!1,!1)}catch(t){if(t.message.includes("already exists"))return void V.info(`Wallet ${L} already exists`);V.error(`Wallet creation failed with error '${t.message}'`)}};static checkBlockchainProgress=async()=>{const t=await m((async()=>{const t=await nt.getBlockchainInfo();const e=(100*parseFloat(t.result.verificationprogress)).toFixed(4);const{blocks:s}=t.result;if(V.info(`Zmq. Bitcoind { percentage:${e}%, blocks:${s} }`),parseFloat(t.result.verificationprogress)<=.7)throw new Error("Node not ready yet");return t}),{startingDelay:6e4,timeMultiple:1,numOfAttempts:8760});const e=(100*parseFloat(t.result.verificationprogress)).toFixed(4);const s=t.result.blocks;V.info(`BCN reaches sync end...at { bitcoind.progress:${e}%, bitcoindSyncedHeight:${s} }`)}}class Ft{static get=async t=>Dt.getTransaction(t);static getRaw=async t=>Dt.getBulkTransactions(t);static getRawJSON=async t=>Dt.getRawTransactionsJSON(t);static sendRaw=async t=>Dt.sendRawTransaction(t);static getUtxos=async t=>Dt.getUtxos(t);static waitForRpcBlockHash=async(t,e)=>Dt.waitForRpcBlockHash(t,e);static insertRpcBlock=async(t,e,s="LTC")=>{const{result:a}=await Dt.getBlock(t,2);const{tx:n}=a;let r=n;"LTC"===s&&(r=n.filter((t=>"08"!==t.hex.slice(10,12))));const o=`[wid ${e} pid: ${process.pid}: backfilling height ${a.height} - backfilling ${r.length} txs `;"LTC"===s&&o.concat(`(${n.length-r.length} mweb tx's filtered)...`),V.info(o);const i=[];for(const t of r)try{let{hex:e}=t;e||(e=(await Dt.getRawTransaction(t.txid,1)).hex);const s=E.txFromHex({hex:e});s&&i.push(s)}catch(s){V.error(`[wid ${e} pid: ${process.pid}: failed to parse transaction in block ${a.height}\n          error message: ${s.message}\n          transaction: ${JSON.stringify(t)}`)}try{await Lt.insert(i,t),await Mt.insert(i,t)}catch(t){V.error(`[wid ${e} pid: ${process.pid}: inserting inputs and outputs for block ${a.height} failed with error '${t.message}'`)}};static walletSetup=async()=>Dt.walletSetup()}class Ut{static syncTxs=async(t,e,s)=>{for(V.info(`[wid ${e} pid: ${process.pid}]: starting to sync txs from block: ${t} - numWorkers: ${s}`);;){try{const s=await $t.waitForDbBlockHash(t,e);await Ft.insertRpcBlock(s,e,$)}catch(s){V.error(`[wid ${e} pid: ${process.pid}: syncing block num ${t} failed with error '${s.message}'`)}t+=s,await Pt.update({blockToSync:t,workerId:e})}};static findOrphans=async t=>{const e=await nt.getBlock(t,2);if(1===e?.result.height)return[];const s=await $t.selectByHeight(e.result.height-1);return e?.result.previousblockhash===s.hash?[]:[...await Ut.findOrphans(e.result.previousblockhash),s.hash]};static updateStatus=async(t,e)=>{await mt.update(t);const s=await ut.min();V.info(`[wid 0 pid: ${process.pid}: min: ${s}, height to resume: ${t}`);const a=Math.min(s,t);V.info(`[wid 0 pid: ${process.pid}: reorg detected, resuming at block ${a}`),await Pt.register(e,a)};static registerOrphans=async(t,e,s)=>{try{V.info(`[wid 0 pid: ${process.pid}: block reorg detected at height ${e} [!] orphans ${t}`),await Tt.insertAll(t),V.info(`[wid 0 pid: ${process.pid}: detected ${t.length} orphaned blocks`),await this.updateStatus(e,s),V.info(`[wid 0 pid: ${process.pid}: resuming at height ${e} [!] exiting ...`)}catch(t){V.error(`[wid 0 pid: ${process.pid}: failed to register orphans with error '${t.message}'`)}};static syncBlocks=async(t,e,s)=>{let a="";let n="";for(V.info(`[wid ${e} pid: ${process.pid}]: starting to sync block: ${t}`);;){try{n=await Ft.waitForRpcBlockHash(t,e),V.info(`[wip ${e} pid: ${process.pid}: synchronizing block num ${t} hash ${n}`);const r=await this.findOrphans(n);r.length&&(await this.registerOrphans(r,t-r.length,s),process.exit(0)),await $t.insert({hash:n,height:t,previousHash:a})}catch(s){V.error(`[wid ${e} pid: ${process.pid}: error block num ${t} failed to sync with error '${s.message}'`)}t+=1,a=n,await mt.update(t)}}}r(t);let Wt=i();k&&parseInt(k,10)>0&&(Wt=parseInt(k,10));const _t=o.worker?o.worker.id:0;V.info(`[wid ${_t} pid: ${process.pid}]: starting with ${Wt} threads`);try{if(await(async()=>{await m((()=>ct.connect()),{startingDelay:500})})(),V.info(`[wid ${_t} pid: ${process.pid}]: connected to the database successfully`),o.isPrimary){V.info(`[wid ${_t} pid: ${process.pid}]: parameters { url: ${x}, chain:${$} network:${v} numWorkers: ${Wt}}`),await Pt.setup(Wt);for(let t=1;t<=Wt;t+=1)V.info(`[wid ${_t} pid: ${process.pid}: launching worker ${t}`),o.fork();o.on("exit",((t,e,s)=>{V.info(`[wid ${_t} pid: ${process.pid}]: worker ${t.process.pid} died with code ${e} and signal ${s}`),V.error(`[wid ${_t} pid: ${process.pid}]: aborting`),process.exit(0)}));const t=await mt.select();await Ut.syncBlocks(t,_t,Wt)}else{const t=await Pt.selectByWorkerId(_t);await Ut.syncTxs(t.blockToSync,t.workerId,Wt)}}catch(t){V.error(`[wid ${_t} pid: ${process.pid}]: synchronizing failed with error '${t.message}'`)}
