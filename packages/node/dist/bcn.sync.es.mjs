import*as t from"@bitcoin-computer/secp256k1";import{networks as e,bufferUtils as s,script as a,crypto as n,address as o,initEccLib as r}from"@bitcoin-computer/nakamotojs";import{availableParallelism as c}from"node:os";import{spawn as i}from"node:child_process";import{exit as p}from"node:process";import l from"dotenv";import u from"winston";import d from"winston-daily-rotate-file";import{backOff as h}from"exponential-backoff";import m from"pg-promise";import y from"pg-monitor";import w from"fs";import{Transaction as g,Computer as $}from"@bitcoin-computer/lib";import E from"bitcoind-rpc";import v from"util";l.config();const T=process.env.BCN_CHAIN;const f=process.env.BCN_NETWORK;const{BCN_PORT:S}=process.env;process.env,process.env;const{BCN_DEBUG_MODE:O}=process.env;const{BCN_LOG_MAX_FILES:k}=process.env;const{BCN_LOG_MAX_SIZE:I}=process.env;const{BCN_LOG_ZIP:R}=process.env;const{BCN_SHOW_CONSOLE_LOGS:B}=process.env;const{BCN_SHOW_DB_LOGS:b}=process.env;process.env,process.env,process.env,process.env,process.env;const{BCN_NUM_WORKERS:M}=process.env;const{BCN_WORKER_ID:N}=process.env;process.env,process.env;const H=process.env.BCN_QUERY_LIMIT||"1000";const x=process.env.BCN_URL||`http://127.0.0.1:${S}`;process.env.BCN_ENV;const C=process.env.BCN_ZMQ_ACTIVATION_HEIGHT||"100000";const{BITCOIN_RPC_USER:A}=process.env;const{BITCOIN_RPC_PASSWORD:L}=process.env;const{BITCOIN_RPC_HOST:P}=process.env;const{BITCOIN_RPC_PORT:D}=process.env;const{BITCOIN_RPC_PROTOCOL:_}=process.env;const{BITCOIN_DEFAULT_WALLET:U}=process.env;const{POSTGRES_USER:W}=process.env;const{POSTGRES_PASSWORD:F}=process.env;const{POSTGRES_DB:Y}=process.env;const{POSTGRES_HOST:G}=process.env;const{POSTGRES_PORT:K}=process.env;const{POSTGRES_MAX_CONNECTIONS:V}=process.env;const{POSTGRES_IDLE_TIMEOUT_MILLIS:j}=process.env;u.addColors({error:"red",warn:"yellow",info:"green",http:"magenta",debug:"white"});const q=u.format.combine(u.format.colorize(),u.format.timestamp({format:"YYYY-MM-DD HH:mm:ss:ms"}),u.format.json(),u.format.printf((t=>`${t.timestamp} [${t.level.slice(5).slice(0,-5)}] ${t.message}`)));const J={zippedArchive:"true"===R,maxSize:I,maxFiles:k,dirname:"logs"};const z=[];"true"===B&&z.push(new u.transports.Console({format:u.format.combine(u.format.colorize(),u.format.timestamp({format:"MM-DD-YYYY HH:mm:ss"}),u.format.printf((t=>`${t.timestamp} ${t.level} ${t.message}`)))}));const X=parseInt(O,10);X>=0&&z.push(new d({filename:"error-%DATE%.log",datePattern:"YYYY-MM-DD",level:"error",...J})),X>=1&&z.push(new d({filename:"warn-%DATE%.log",datePattern:"YYYY-MM-DD",level:"warn",...J})),X>=2&&z.push(new d({filename:"info-%DATE%.log",datePattern:"YYYY-MM-DD",level:"info",...J})),X>=3&&z.push(new d({filename:"http-%DATE%.log",datePattern:"YYYY-MM-DD",level:"http",...J})),X>=4&&z.push(new d({filename:"debug-%DATE%.log",datePattern:"YYYY-MM-DD",level:"debug",...J}));const Z=u.createLogger({levels:{error:0,warn:1,info:2,http:3,debug:4},format:q,transports:z,exceptionHandlers:[new u.transports.File({filename:"logs/exceptions.log"})],rejectionHandlers:[new u.transports.File({filename:"logs/rejections.log"})]});l.config();const{version:Q}=JSON.parse(w.readFileSync("package.json","utf8"));Q||process.env.BCN_SERVER_VERSION;const tt=parseInt(process.env.MWEB_HEIGHT||"",10)||432;const et={error:(t,e)=>{if(e.cn){const{host:s,port:a,database:n,user:o,password:r}=e.cn;Z.debug(`Waiting for db to start { message:${t.message} host:${s}, port:${a}, database:${n}, user:${o}, password: ${r}`)}},noWarnings:!0};"true"===b&&(y.isAttached()?y.detach():(y.attach(et),y.setTheme("matrix")));const st=m(et)({host:G,port:parseInt(K,10),database:Y,user:W,password:F,max:parseInt(V,10),allowExitOnIdle:!0,idleTimeoutMillis:parseInt(j,10)});const{PreparedStatement:at}=m;class nt{static async selectByWorkerId(t){const e=new at({name:`TxStatus.select.${Math.random()}`,text:'SELECT "blockToSync", "workerId" FROM "TxStatus" WHERE "workerId" = $1',values:[t]});return st.oneOrNone(e)}static async update({blockToSync:t,workerId:e}){const s=new at({name:`TxStatus.update.${Math.random()}`,text:'UPDATE "TxStatus" SET "blockToSync" = $1 WHERE "workerId" = $2',values:[t,e]});await st.any(s)}static async count(){const t=new at({name:`TxStatus.count.${Math.random()}`,text:'SELECT COUNT(*) FROM "TxStatus"'});const e=await st.oneOrNone(t);return parseInt(e?.count,10)||0}static async min(){const t=new at({name:`TxStatus.min.${Math.random()}`,text:'SELECT MIN("blockToSync") FROM "TxStatus"'});const e=await st.oneOrNone(t);return parseInt(e?.min,10)||0}static async deleteAll(){const t=new at({name:`TxStatus.delete.${Math.random()}`,text:'DELETE FROM "TxStatus"'});await st.any(t)}static async insertBatch(t){const e=[];for(let s=1;s<=t.length;s+=2)e.push(`($${s}, $${s+1})`);const s=e.join(",");const a=new at({name:`TxStatus.reorg.${Math.random()}`,text:`INSERT INTO "TxStatus"("workerId", "blockToSync") VALUES ${s}`,values:t});await st.any(a)}}class ot{static async selectByWorkerId(t){return nt.selectByWorkerId(t)}static async update(t){await nt.update(t)}static async count(){return nt.count()}static async insertBatch(t){await nt.insertBatch(t)}static async min(){return nt.min()}static async deleteAll(){await nt.deleteAll()}}const{PreparedStatement:rt}=m;class ct{static async select(){const t=new rt({name:`BlockStatus.select.${Math.random()}`,text:'SELECT "blockToSync" FROM "BlockStatus"'});const e=await st.oneOrNone(t);return parseInt(e?.blockToSync,10)||null}static async update(t){const e=new rt({name:`BlockStatus.update.${Math.random()}`,text:'UPDATE "BlockStatus" SET "blockToSync" = $1',values:[t]});await st.any(e)}static async insert(t){const e=new rt({name:`BlockStatus.insert.${Math.random()}`,text:'INSERT INTO "BlockStatus"("blockToSync") VALUES ($1)',values:[t]});await st.any(e)}static async count(){const t=new rt({name:`BlockStatus.count.${Math.random()}`,text:'SELECT COUNT(*) FROM "BlockStatus"'});const e=await st.oneOrNone(t);return parseInt(e?.count,10)||0}static async delete(){const t=new rt({name:`BlockStatus.delete.${Math.random()}`,text:'DELETE FROM "BlockStatus"'});await st.any(t)}}class it{static async select(){return ct.select()}static async update(t){await ct.update(t)}static async insert(t){await ct.insert(t)}static async count(){return ct.count()}static async delete(){await ct.delete()}}class pt{static update=async t=>it.update(t);static select=async()=>it.select();static insert=async t=>it.insert(t);static count=async()=>it.count();static delete=async()=>it.delete()}function lt(t){t.forEach((t=>{Z.info(`[wid 0 pid: ${process.pid}]: killing worker ${t}`);try{Z.info(`[wid 0 pid: ${process.pid}]: killing worker (SIGTERM) ${t}: ${process.kill(t,"SIGTERM")}`),process.kill(t,"SIGTERM")}catch(e){Z.info(`[wid 0 pid: ${process.pid}]: killing worker ${t}: ${process.kill(t)}`),process.kill(t,"SIGKILL")}}))}const ut=t=>new Promise((e=>{setTimeout(e,t)}));const dt=(t,e)=>{const s=[];for(let a=0;a<t.length;a+=e){const n=Math.min(a+e,t.length);const o=t.slice(a,n);s.push(o)}return s};const ht=t=>{const e=[];for(let s=1;s<=t;s+=3){const t=`($${s},$${s+1},$${s+2})`;e.push(t)}return e.join(",")};const mt=t=>{const e=[];for(let s=1;s<=t;s+=9){const t=`($${s},$${s+1},$${s+2},$${s+3},$${s+4},$${s+5},$${s+6},$${s+7},$${s+8})`;e.push(t)}return e.join(",")};const yt=t=>{try{return t()}catch{return null}};const{PreparedStatement:wt}=m;class gt{static async selectByHeight(t){const e=new wt({name:`Block.select.${Math.random()}`,text:'SELECT "hash", "height", "previousHash" FROM "Block" WHERE "height" = $1',values:[t]});return st.oneOrNone(e)}static async insert(t){const e=new wt({name:`Block.insert.${Math.random()}`,text:'INSERT INTO "Block" ("hash", "height", "previousHash") VALUES ($1, $2, $3)',values:[t.hash,t.height,t.previousHash]});await st.none(e)}static async insertBatch(t){const e=t.flatMap((({hash:t,height:e,previousHash:s})=>[t,e,s]));const s=new wt({name:`Block.insertBatch.${Math.random()}`,text:`INSERT INTO "Block" ("hash", "height", "previousHash") VALUES ${ht(e.length)}`,values:e});await st.none(s)}static async deleteAll(){const t=new wt({name:`Block.delete.${Math.random()}`,text:'DELETE FROM "Block"',values:[]});await st.none(t)}static async deleteByHash(t){const e=t.map((t=>t)).join("', '");const s=new wt({name:`Block.deleteByHash.${Math.random()}`,text:`DELETE FROM "Block" WHERE "hash" IN ('${e}')`});await st.none(s)}}class $t{static selectByHeight=async t=>gt.selectByHeight(t);static insert=async t=>gt.insert(t);static insertBatch=async t=>gt.insertBatch(t);static deleteAll=async()=>gt.deleteAll();static deleteByHash=async t=>gt.deleteByHash(t);static waitForDbBlockHash=async(t,e)=>(await h((async()=>{let s;try{s=await gt.selectByHeight(t)}catch(s){throw Z.info(`[wid ${e} pid: ${process.pid}]: waiting for DB to get block ${t} ...`),s}return s}),{startingDelay:1e4,timeMultiple:1,numOfAttempts:720})).hash}class Et{static selectByHeight=async t=>$t.selectByHeight(t);static insert=async t=>$t.insert(t);static insertBatch=async t=>$t.insertBatch(t);static deleteAll=async()=>$t.deleteAll();static deleteByHash=async t=>$t.deleteByHash(t);static waitForDbBlockHash=async(t,e)=>$t.waitForDbBlockHash(t,e)}const{PreparedStatement:vt}=m;class Tt{static async selectAll(){const t=new vt({name:`Orphan.select.${Math.random()}`,text:'SELECT * FROM "Orphan"'});return st.any(t)}static async insertAll(t){const e=t.map((t=>`('${t.hash}',${t.height}, ${t.processed})`)).join(",");const s=new vt({name:`Orphan.insert.${Math.random()}`,text:`INSERT INTO "Orphan" (hash, height, processed) VALUES ${e}`});await st.none(s)}static async process(t){const e=t.map((t=>t.height)).join(",");const s=new vt({name:`Orphan.process.${Math.random()}`,text:`UPDATE "Orphan" SET processed = true WHERE height IN (${e})`});await st.none(s)}}class ft{static selectAll=async()=>Tt.selectAll();static insertAll=async t=>Tt.insertAll(t);static process=async t=>Tt.process(t)}class St{static selectAll=async()=>ft.selectAll();static insertAll=async t=>ft.insertAll(t);static process=async t=>ft.process(t)}const{PreparedStatement:Ot}=m;class kt{static async select(t){const e=new Ot({name:`Input.select.${Math.random()}`,text:'SELECT "outputSpent", "spendingInput", "blockHash" FROM "Input" WHERE "outputSpent" = $1',values:[t]});return st.any(e)}static async insert(t){await Promise.all(dt(t,3333).map((t=>{const e=t.flatMap((({outputSpent:t,spendingInput:e,blockHash:s})=>[t,e,s]));return st.none(new Ot({name:`Input.insert.${Math.random()}`,text:`INSERT INTO "Input"("outputSpent", "spendingInput", "blockHash") VALUES ${ht(e.length)} \n              ON CONFLICT ("spendingInput") \n              DO UPDATE SET "blockHash" = COALESCE("Input"."blockHash", EXCLUDED."blockHash")`,values:e}))})))}static async updateBlockHash(t,e){await Promise.all(dt(t,1e4).map((t=>{const s=t.join("','");return st.none(new Ot({name:`Input.updateBlockHash.${Math.random()}`,text:`UPDATE "Input" SET "blockHash" = $1 WHERE "spendingInput" IN ('${s}')`,values:[e]}))})))}static async eraseBlockHash(t){await Promise.all(dt(t,1e4).map((t=>{const e=t.join("','");return st.none(new Ot({name:`Input.eraseBlockHash.${Math.random()}`,text:`UPDATE "Input" SET "blockHash" = NULL WHERE "blockHash" IN ('${e}')`}))})))}static async count(t){const e=t.map((t=>t.outputSpent));const s=new Ot({name:`Input.belong.${Math.random()}`,text:'SELECT count(*) FROM "Input" WHERE "outputSpent" LIKE ANY ($1)',values:[[e]]});const a=await st.oneOrNone(s);return parseInt(a?.count,10)||0}}class It{static async select(t){return kt.select(t)}static async insert(t){return kt.insert(t)}static async updateBlockHash(t,e){return kt.updateBlockHash(t,e)}static async eraseBlockHash(t){return kt.eraseBlockHash(t)}}class Rt{static insert=async t=>{await It.insert(t)};static getInputs=(t,e=null)=>t.flatMap((({ins:t,txId:e})=>t.map(((t,s)=>({input:t,index:s,txId:e}))))).filter((({input:t})=>!g.isCoinbaseHash(t.hash))).map((({input:t,index:a,txId:n})=>{return{outputSpent:`${o=t.hash,s.reverseBuffer(Buffer.from(o)).toString("hex")}:${t.index}`,spendingInput:`${n}:${a}`,blockHash:e};var o}));static select=async t=>It.select(t);static updateBlockHash=async(t,e)=>{await It.updateBlockHash(t,e)};static eraseBlockHash=async t=>{await It.eraseBlockHash(t)}}function Bt(t){if(!function(t){return/^[0-9A-Fa-f]{64}:\d+$/.test(t)}(t))throw new Error("Invalid rev")}const{PreparedStatement:bt}=m;class Mt{static async listSentOutputs(t){const e=new bt({name:`Output.listSentTxs.${Math.random()}`,text:'SELECT "Input"."spendingInput" AS "output", "Output"."satoshis" AS "amount"\n        FROM "Output" INNER JOIN "Input" ON "Output".rev = "Input"."outputSpent" \n        WHERE "Output"."address" = $1',values:[t]});return(await st.any(e)).map((t=>({...t,amount:parseInt(t.amount,10)||0})))}static async listReceivedOutputs(t){const e=new bt({name:`Output.listReceivedTxs.${Math.random()}`,text:'SELECT "Output"."rev" as "output", "Output"."satoshis" as "amount" FROM "Output" WHERE "address" = $1',values:[t]});return(await st.any(e)).map((t=>({...t,amount:parseInt(t.amount,10)||0})))}static async listTxs(t){const e=new bt({name:`Output.listTxs.${Math.random()}`,text:'WITH\n              -- List all txs sent from a given address\n              SENT AS (\n                SELECT split_part("Input"."spendingInput",\':\',1) as "txId", SUM("Output".satoshis) as "satoshis"\n                FROM "Output" INNER JOIN "Input" ON "Output".rev = "Input"."outputSpent"  \n                WHERE "Output".address = $1\n                GROUP BY split_part("Input"."spendingInput",\':\',1)\n              ),\n              -- List all tx received from a given address\n              RECEIVED AS (\n                SELECT SPLIT_PART("Output"."rev",\':\',1) as "txId", SUM("Output"."satoshis") as "satoshis" \n                FROM "Output" \n                WHERE "address" = $1\n                GROUP BY "txId"\n              )\n\n            SELECT\n              RECEIVED."txId", \n              coalesce(SENT."satoshis", 0) as "inputsSatoshis", \n              coalesce(RECEIVED."satoshis", 0) as "outputsSatoshis", \n              coalesce(RECEIVED."satoshis",0) - coalesce(SENT."satoshis",0) as "satoshis"\n            FROM\n              SENT RIGHT JOIN RECEIVED ON SENT."txId" = RECEIVED."txId";',values:[t]});const s=(await st.any(e)).map((t=>({...t,inputsSatoshis:parseInt(t.inputsSatoshis,10)||0,outputsSatoshis:parseInt(t.outputsSatoshis,10)||0,satoshis:parseInt(t.satoshis,10)||0})));return{sentTxs:s.filter((t=>t.satoshis<0)).map((t=>({...t,satoshis:Math.abs(t.satoshis)}))),receivedTxs:s.filter((t=>t.satoshis>=0))}}static async select(t){const e=new bt({name:`Output.select.${Math.random()}`,text:'SELECT "address", "satoshis", "asm", "rev", "hash", "mod", "isTbcOutput", "previous", "blockHash" FROM "Output" WHERE "address" = $1',values:[t]});return st.any(e)}static async insert(t){await Promise.all(dt(t,1111).map((t=>{const e=t.flatMap((({rev:t,address:e,satoshis:s,asm:a,isTbcOutput:n,mod:o,previous:r,hash:c,blockHash:i})=>[t,e,s,a,n,o,r,c,i]));return st.none(new bt({name:`Output.insert.${Math.random()}`,text:`INSERT INTO "Output"("rev", "address", "satoshis", "asm", "isTbcOutput",\n              "mod", "previous", "hash", "blockHash") VALUES ${mt(e.length)} ON CONFLICT DO NOTHING`,values:e}))})))}static async eraseBlockHash(t){await Promise.all(dt(t,1e4).map((t=>{const e=t.join("','");return st.none(new bt({name:`Output.eraseBlockHash.${Math.random()}`,text:`UPDATE "Output" SET "blockHash" = NULL WHERE "blockHash" IN ('${e}')`}))})))}static async updateBlockHash(t,e){await Promise.all(dt(t,1e4).map((t=>{const s=t.join("','");return st.none(new bt({name:`Output.updateBlockHash.${Math.random()}`,text:`UPDATE "Output" SET "blockHash" = $1 WHERE "rev" IN ('${s}')`,values:[e]}))})))}static async getIdByRev(t){const e=new bt({name:`NonStandard.recursiveUpdates.${Math.random()}`,text:'WITH RECURSIVE revUpdates AS (\n        SELECT "rev", "previous" FROM "Output" WHERE "isTbcOutput" = true and "rev" = $1\n        UNION ALL\n        SELECT o."rev", o."previous" FROM "Output" o\n        INNER JOIN revUpdates r ON r."previous" = o."rev"\n      )\n      SELECT * FROM revUpdates',values:[t]});const s=(await st.any(e)).filter((t=>null===t.previous));return s[0]?.rev}static async getIdsByRevs(t){return Promise.all(t.map((t=>this.getIdByRev(t))))}static async getLatestRev(t){const e=new bt({name:`NonStandard.recursiveUpdates.${Math.random()}`,text:'WITH RECURSIVE revUpdates AS (\n        SELECT "rev", "previous" FROM "Output" WHERE "isTbcOutput" = true and "rev" = $1\n        UNION ALL\n        SELECT o."rev", o."previous" FROM "Output" o\n        INNER JOIN revUpdates r ON o."previous" = r."rev"\n      )\n      SELECT * FROM revUpdates',values:[t]});const s=await st.any(e);const a=Object.fromEntries(s.map((t=>[t.previous,t.rev])));let n=t;for(;a[n];)n=a[n];return n}static async getLatestRevs(t){return Promise.all(t.map(this.getLatestRev))}static async getIdsByMod(t){const e=new bt({name:`Output.getIdsByMod.${Math.random()}`,text:'SELECT "rev" FROM "Output" WHERE "mod" = $1',values:[t]});return(await st.any(e)).map((t=>t.rev))}static sqlSuffix(t,e,s){let a="";return s&&(a+=` order by "timestamp" ${s}`),a+=` limit ${t||H}`,e&&(a+=` offset ${e}`),a}static async getUnspentRevsByMod(t,e,s,a){const n=await this.getIdsByMod(t);const o=await this.getLatestRevs(n);const r=new bt({name:`Output.getUnspentRevsByMod.${Math.random()}`,text:`SELECT "rev" FROM "Output" WHERE "rev" = ANY($1) ${this.sqlSuffix(e,s,a)}`,values:[o]});return(await st.any(r)).map((t=>t.rev))}static async getUnspentRevsByPublicKey(t,e,s,a){const n=new bt({name:`Output.getUnspentRevsByPublicKey.${Math.random()}`,text:`SELECT "rev" FROM "Output" WHERE asm LIKE '%${t}%' AND "isTbcOutput" = true \n      AND NOT EXISTS (SELECT 1 FROM "Input" ip WHERE "ip"."outputSpent" = "Output"."rev") \n      ${this.sqlSuffix(e,s,a)}`});return(await st.any(n)).map((t=>t.rev))}static async getUnspentRevsByModAndPublicKey(t,e,s,a,n){const o=await this.getUnspentRevsByPublicKey(e,s,a,n);const r=await this.getIdsByRevs(o);const c=new bt({name:`Output.getLatestRevsByModAndPublicKey.${Math.random()}`,text:'SELECT "rev" FROM "Output" WHERE "mod" = $1 AND "rev" = ANY($2)',values:[t,r]});const i=(await st.any(c)).map((t=>t.rev));const p=await this.getLatestRevs(i);const l=new bt({name:`Output.getLatestRevsByModAndPublicKey.${Math.random()}`,text:`SELECT "rev" FROM "Output" WHERE "rev" = ANY($1) ${this.sqlSuffix(s,a,n)}`,values:[p]});return(await st.any(l)).map((t=>t.rev))}static async getUnspentTbcOutputs(t,e,s){const a=new bt({name:`Output.getUnspentTbcOutputs.${Math.random()}`,text:`SELECT "rev", "address", "satoshis", "asm", "timestamp"\n        FROM "Output" WHERE "isTbcOutput" = true AND NOT EXISTS\n        (SELECT 1 FROM "Input" ip WHERE "ip"."outputSpent" = "Output"."rev") ${this.sqlSuffix(t,e,s)}`});return(await st.any(a)).map((t=>t.rev))}static async query(t){const{publicKey:e,limit:s,offset:a,ids:n,mod:o,order:r}=t;const c=parseInt(H||"",10);if(s&&parseInt(s||"",10)>c||n&&n.length>c)throw new Error(`Can't fetch more than ${H} revs.`);if(r&&"ASC"!==r&&"DESC"!==r)throw new Error("Invalid order. Should be ASC or DESC.");return n?(n.map(Bt),this.getLatestRevs(n)):o&&!e?this.getUnspentRevsByMod(o,s,a,r):!o&&e?this.getUnspentRevsByPublicKey(e,s,a,r):o&&e?this.getUnspentRevsByModAndPublicKey(o,e,s,a,r):this.getUnspentTbcOutputs(s,a,r)}static async selectNext(t){const e=new bt({name:`Output.selectNext.${Math.random()}`,text:'SELECT "rev" FROM "Output" WHERE "previous" = $1',values:[t]});return st.any(e)}static async selectPrev(t){const e=new bt({name:`Output.selectPrev.${Math.random()}`,text:'SELECT "previous" FROM "Output" WHERE "rev" = $1',values:[t]});return st.any(e)}}class Nt{static async select(t){return Mt.select(t)}static async insert(t){return Mt.insert(t)}static async eraseBlockHash(t){return Mt.eraseBlockHash(t)}static async updateBlockHash(t,e){return Mt.updateBlockHash(t,e)}static async listSentOutputs(t){return Mt.listSentOutputs(t)}static async listReceivedOutputs(t){return Mt.listReceivedOutputs(t)}static async listTxs(t){return Mt.listTxs(t)}static async getLatestRev(t){return Mt.getLatestRev(t)}static async getLatestRevs(t){return Mt.getLatestRevs(t)}static async getIdByRev(t){return Mt.getIdByRev(t)}static async query(t){return Mt.query(t)}static async selectNext(t){return Mt.selectNext(t)}static async selectPrev(t){return Mt.selectPrev(t)}}const Ht=function(t=T,s=f){switch(t){case"BTC":switch(s){case"mainnet":return e.bitcoin;case"testnet":return e.testnet;case"regtest":return e.regtest;default:throw new Error(`Invalid network ${s}`)}case"LTC":switch(s){case"mainnet":return e.litecoin;case"testnet":return e.litecointestnet;case"regtest":return e.litecoinregtest;default:throw new Error(`Invalid network ${s}`)}case"PEPE":switch(s){case"mainnet":return e.pepecoin;case"testnet":return e.pepecointestnet;case"regtest":return e.pepecoinregtest;default:throw new Error(`Invalid network ${s}`)}default:throw new Error(`Invalid chain ${t}`)}}(T,f);class xt{static insert(t){return Nt.insert(t)}static getOutputs=(t,e=null)=>t.flatMap((({outs:t,txId:s,zip:r,onChainMetaData:c})=>{const{exp:i="",mod:p=""}=c;return t.map((({script:t,value:c},l)=>{const u=l<r.length;return{rev:`${s}:${l}`,address:yt((()=>o.fromOutputScript(t,Ht))),satoshis:Math.round(c),asm:a.toASM(t),isTbcOutput:u,mod:u?p:"",previous:u?r[l][0]:null,hash:u?n.sha256(Buffer.from(i)).toString("hex"):null,blockHash:e}}))}));static select=async t=>Nt.select(t);static eraseBlockHash=async t=>{await Nt.eraseBlockHash(t)};static updateBlockHash=async(t,e)=>{await Nt.updateBlockHash(t,e)};static listSentOutputs=async t=>Nt.listSentOutputs(t);static listReceivedOutputs=async t=>Nt.listReceivedOutputs(t);static listTxs=async t=>Nt.listTxs(t);static getLatestRev=async t=>Nt.getLatestRev(t);static getLatestRevs=async t=>Nt.getLatestRevs(t);static getIdByRev=async t=>Nt.getIdByRev(t);static query=async t=>Nt.query(t)}class Ct{static update=async t=>ot.update(t);static insertBatch=async t=>ot.insertBatch(t);static deleteAll=async()=>ot.deleteAll();static count=async()=>ot.count();static waitUntilSetup=async(t,e)=>{Z.info(`WorkerId ${t} waiting for master worker to reorg up to ${e} workers...`),await h((async()=>{const s=await ot.count();if(s===e)return!0;throw Z.info(`WorkerId ${t} waiting until setup done. Actual ${s}, numWorkers ${e}`),new Error("Not all workers have reorged")}),{startingDelay:500})};static selectByWorkerId=async t=>ot.selectByWorkerId(t);static setup=async t=>{0===await it.count()&&(await pt.insert(1),Z.info(`[wid 0 pid: ${process.pid}: registering block sync status on block 1`)),await ot.count()===t?Z.info(`[wid 1 pid: ${process.pid}: all workers have already registered`):await Ct.register(t,await ot.min());const e=await St.selectAll();if(e.length>0){Z.info(`[wid 0 pid: ${process.pid}: found ${e.length} orphans`);const s=e.map((t=>t.hash));await Et.deleteByHash(s),await Rt.eraseBlockHash(s),await xt.eraseBlockHash(s);const a=await ot.min();const n=Math.min(e[0].height-1,a);Z.info(`[wid 0 pid: ${process.pid}: last block synced from workers ${a}`),Z.info(`[wid 0 pid: ${process.pid}: last valid block at ${e[0].height-1}`),Z.info(`[wid 0 pid: ${process.pid}: resuming at ${n}`),await Ct.register(t,n),await St.process(e)}};static register=async(t,e)=>{const s=[];let a=Math.max(1,e);for(let e=1;e<=t;e+=1,a+=1)s.push(e,a);Z.info(`[wid 0 pid: ${process.pid}: reorging sync status for ${t} workers...${s}`),await ot.deleteAll(),await ot.insertBatch(s)};static min=async()=>ot.min()}const At=new E({protocol:_,user:A,pass:L,host:P,port:parseInt(D,10)});const Lt=v.promisify(E.prototype.createwallet.bind(At));const Pt=v.promisify(E.prototype.generateToAddress.bind(At));const Dt=v.promisify(E.prototype.getaddressinfo.bind(At));const _t=v.promisify(E.prototype.getBlock.bind(At));const Ut=v.promisify(E.prototype.getBlockchainInfo.bind(At));const Wt=v.promisify(E.prototype.getBlockHash.bind(At));const Ft=v.promisify(E.prototype.getRawTransaction.bind(At));const Yt=v.promisify(E.prototype.getRawTransaction.bind(At));const Gt=v.promisify(E.prototype.getTransaction.bind(At));const Kt=v.promisify(E.prototype.getNewAddress.bind(At));const Vt={createwallet:Lt,generateToAddress:Pt,getaddressinfo:Dt,getBlock:_t,getBlockchainInfo:Ut,getBlockHash:Wt,getRawTransaction:Ft,getTransaction:Gt,importaddress:v.promisify(E.prototype.importaddress.bind(At)),invalidateBlock:v.promisify(E.prototype.invalidateBlock.bind(At)),listunspent:v.promisify(E.prototype.listunspent.bind(At)),sendRawTransaction:v.promisify(E.prototype.sendRawTransaction.bind(At)),getNewAddress:Kt,sendToAddress:v.promisify(E.prototype.sendToAddress.bind(At)),getRawTransactionJSON:Yt};class jt{static async getTransaction(t){const{result:e}=await Vt.getTransaction(t);return e}static async getBulkTransactions(t){return(await Promise.all(t.map((t=>Vt.getRawTransaction(t,0))))).map((t=>t.result))}static async getRawTransaction(t,e){const{result:s}=await Vt.getRawTransaction(t,e);return s}static async getRawTransactionsJSON(t){return{txId:(e=(await Vt.getRawTransactionJSON(t,1)).result).txid,txHex:e.hex,vsize:e.vsize,version:e.version,locktime:e.locktime,ins:e.vin.map((t=>t.coinbase?{coinbase:t.coinbase,sequence:t.sequence}:{txId:t.txid,vout:t.vout,script:t.scriptSig.hex,sequence:t.sequence})),outs:e.vout.map((t=>{let e;return t.scriptPubKey.addresses?[e]=t.scriptPubKey.addresses:e=t.scriptPubKey.address?t.scriptPubKey.address:void 0,{address:e,script:t.scriptPubKey.hex,value:Math.round(1e8*t.value)}}))};var e}static async sendRawTransaction(t){const{result:e,error:s}=await Vt.sendRawTransaction(t);if(s)throw Z.error(s),new Error("Error sending transaction");return e}static getUtxos=async t=>(void 0===(await Vt.getaddressinfo(t)).result.timestamp&&(Z.info(`Importing address: ${t}`),await Vt.importaddress(t,!1)),(await Vt.listunspent(0,999999,[t])).result);static getBlockHash=async(t,e)=>{const s={hash:null,error:!1};try{const{result:e}=await Vt.getBlockHash(t);s.hash=e}catch(a){Z.info(`[wid ${e} pid: ${process.pid}]: waiting for RPC to get blockHash of height ${t} ...`),s.error=!0,await ut(5e3)}return s};static getBlock=async(t,e,s,a)=>{const n={block:null,error:!1};try{const{result:e}=await Vt.getBlock(t,s);n.block=e}catch(t){Z.info(`[wid ${a} pid: ${process.pid}]: waiting for RPC to get block ${e} ...`),n.error=!0,await ut(5e3)}return n};static walletSetup=async()=>{if("regtest"===f){if(Z.info(`Node is starting for chain ${T} and network ${f}, \n\n. Starting Wallet setup.`),"LTC"===T){const{result:t}=await Vt.getBlockchainInfo();const e=t.blocks;if(e<tt){const{result:t}=await Vt.getNewAddress("","legacy");const s=tt-e-1;s&&await Vt.generateToAddress(s,t);const{result:a}=await Vt.getNewAddress("mweb","mweb");await Vt.sendToAddress(a,1),await Vt.generateToAddress(1,t),Z.info("MWEB setup is complete")}}if("BTC"===T){const{result:t}=await Vt.getNewAddress("","legacy");await Vt.generateToAddress(200,t),Z.info("Wallet setup is complete")}if("PEPE"===T){const{result:t}=await Vt.getNewAddress("");await Vt.generateToAddress(200,t),Z.info("Wallet setup is complete")}}};static createWallet=async()=>{try{await Vt.createwallet(U,!1,!1,"",!1,!1)}catch(t){if(t.message.includes("already exists"))return void Z.info(`Wallet ${U} already exists`);Z.error(`Wallet creation failed with error '${t.message}'`)}};static checkBlockchainProgress=async t=>{const e=await h((async()=>{const e=await Vt.getBlockchainInfo();const s=(100*parseFloat(e.result.verificationprogress)).toFixed(4);const{blocks:a}=e.result;if(Z.info(`Zmq. Bitcoind { percentage:${s}%, blocks:${a} }`),parseFloat(e.result.verificationprogress)<=t)throw new Error("Node not ready yet");return e}),{startingDelay:6e4,timeMultiple:1,numOfAttempts:8760});const s=(100*parseFloat(e.result.verificationprogress)).toFixed(4);const a=e.result.blocks;Z.info(`BCN reaches sync end...at { bitcoind.progress:${s}%, bitcoindSyncedHeight:${a} }`)}}class qt{static get=async t=>jt.getTransaction(t);static getRaw=async t=>jt.getBulkTransactions(t);static getRawJSON=async t=>jt.getRawTransactionsJSON(t);static sendRaw=async t=>jt.sendRawTransaction(t);static getUtxos=async t=>jt.getUtxos(t);static parseTransactions=async(t,e,s,a)=>{let n=t;"LTC"===e&&(n=t.filter((t=>"08"!==t.hex.slice(10,12))));const o=[];for(const t of n)try{let{hex:e}=t;e||(e=(await jt.getRawTransaction(t.txid,1)).hex);const s=$.txFromHex({hex:e});s&&o.push(s)}catch(e){Z.error(`[wid ${s} pid: ${process.pid}: failed to parse transaction in block ${a}\n          error message: ${e.message}\n          transaction: ${JSON.stringify(t)}`)}return o};static walletSetup=async()=>jt.walletSetup()}class Jt{static getTxBatch=async(t,e,s,a=T)=>{const n=[];const o=[];for(;10*n.length<1e4&&3*o.length<1e4;){let r;let c;try{const{result:e}=await Vt.getBlockHash(t);r=e;const{result:s}=await Vt.getBlock(e,2);c=s}catch(s){Z.info(`[wid ${e} pid: ${process.pid}]: waiting to get block hash or block for height: ${t} ${s.message}`),await ut(5e3);break}try{const s=await qt.parseTransactions(c.tx,a,e,t);n.push(...xt.getOutputs(s,r)),o.push(...Rt.getInputs(s,r))}catch(t){Z.error(`[wid ${e} pid: ${process.pid}]: failed to get inputs or outputs for hash: ${r} ${t.message} ${t.stack}`)}t+=s}return{outputs:n,inputs:o,blockToSync:t}};static syncTxs=async(t,e,s)=>{let a=t;for(Z.info(`[wid ${e} pid: ${process.pid}]: starting to sync txs from block: ${a} - numWorkers: ${s}`);;)try{const t=await this.getTxBatch(a,e,s);(t.outputs.length>0||t.inputs.length>0)&&(await Promise.all([xt.insert(t.outputs),Rt.insert(t.inputs)]),await Ct.update({blockToSync:t.blockToSync,workerId:e}),a=t.blockToSync,Z.info(`[wid ${e} pid: ${process.pid}: backfilling up to ${t.blockToSync-1} - #outputs ${t.outputs.length} #inputs ${t.inputs.length} `))}catch(t){Z.error(`[wid ${e} pid: ${process.pid}]: failed to process block ${a} ${t.message} ${t.stack}`)}};static findOrphans=async(t,e)=>{const{error:s,block:a}=await jt.getBlock(t,e,2,0);if(s)return[];if(1===a?.height)return[];const n=await Et.selectByHeight(a.height-1);if(!n)return[];if(a?.previousblockhash===n?.hash)return[];const o=await Jt.findOrphans(a.previousblockhash,a.height-1);const{hash:r,height:c}=n;return[...o,{hash:r,height:c,processed:!1}]};static updateStatus=async(t,e)=>{await pt.update(t);const s=await ot.min();const a=Math.min(s,t);Z.info(`[wid 0 pid: ${process.pid}: reorg detected, resuming at block  min(${s},${t}) = ${a}`),await Ct.register(e,a)};static registerOrphans=async(t,e,s)=>{Z.info(`[wid 0 pid: ${process.pid}: detected ${t.length} orphaned blocks resuming at height ${e}`),await St.insertAll(t),await this.updateStatus(e,s)};static checkReorg=async(t,e,s)=>{if(t>parseInt(C||"",10))try{const a=await this.findOrphans(e,t);a.length&&(lt(s),await this.registerOrphans(a,t-a.length,s.length),Z.info(`[wid 0 pid: ${process.pid}: exiting ...`),process.exit(0))}catch(t){Z.error(`[wid 0 pid: ${process.pid}: ${t.message} error at checking block reorgs ${t.stack}`)}};static getBlockBatch=async(t,e,s,a,n)=>{const o=[];for(let r=t;o.length<n;r+=1){const{error:n,hash:c}=await jt.getBlockHash(r,s);if(n)break;o.push({hash:c,height:t,previousHash:e}),await this.checkReorg(t,c,a),t+=1,e=c}return{blockHashes:o,blockToSync:t,previousDbHash:e}};static syncBlocks=async(t,e,s)=>{let a=t;let n=(await Et.selectByHeight(t-1))?.hash||"";Z.info(`[wid ${e} pid: ${process.pid}]: starting to sync block: ${t} prev hash: ${n}`);const o=Math.floor(3333.3333333333335);for(;;)try{const t=await this.getBlockBatch(a,n,e,s,o);t.blockHashes.length&&(await pt.update(t.blockToSync),a=t.blockToSync,n=t.previousDbHash,await Et.insertBatch(t.blockHashes),Z.info(`[wip ${e} pid: ${process.pid}: synchronizing up to block num ${t.blockToSync}`))}catch(t){Z.error(`[wid ${e} pid: ${process.pid}]: failed to process block ${a} ${t.message} ${t.stack}`)}}}r(t);const zt=[];const Xt=M?parseInt(M,10):c()-1;const Zt=parseInt(N||"0",10);Z.info(`[wid ${Zt} pid: ${process.pid}]: starting with ${Xt} threads`);try{if(await(async()=>{await h((()=>st.connect()),{startingDelay:500})})(),0===Zt){Z.info(`[wid  ${Zt} pid: ${process.pid}]: connected to the database successfully`),Z.info(`[wid  ${Zt} pid: ${process.pid}]: parameters { url: ${x}, chain:${T} network:${f} numWorkers: ${Xt}}`),await Ct.setup(Xt);for(let t=1;t<=Xt;t+=1){Z.info(`[wid ${Zt} pid: ${process.pid}]: spawning worker ${t}`);const e=i("node",["dist/bcn.sync.es.mjs"],{env:{...process.env,BCN_WORKER_ID:`${t}`,BCN_NUM_WORKERS:`${Xt}`},stdio:"inherit"});e.pid||(Z.error(`[wid ${Zt} pid: ${process.pid}]: failed to spawn worker ${t}`),lt(zt),p(1)),zt.push(e.pid)}Z.info(`Spawned workers: ${zt.map((t=>t)).join(", ")}`);const t=await pt.select();await Jt.syncBlocks(t,0,zt)}else{await Ct.waitUntilSetup(Zt,Xt);const t=await Ct.selectByWorkerId(Zt);await Jt.syncTxs(t.blockToSync,t.workerId,Xt)}}catch(t){Z.error(`[wid ${Zt} pid: ${process.pid}]: synchronizing failed with error '${t.message} ${t.stack}'`),lt(zt),p(1)}
